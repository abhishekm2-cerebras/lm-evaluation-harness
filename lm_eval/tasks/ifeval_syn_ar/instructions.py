from lm_eval.tasks.ifeval import instructions 
import re
import json
import string
import unicodedata
import ast 
from collections import Counter


class IFevalSynArInstructions(instructions.Instruction):
    def __init__(self, instruction_id):
        super().__init__(instruction_id)

    def build_description(self, **kwargs):
        return "No kwargs needed just pass in the response and check if it is correct"

    def get_instruction_args(self):
        return {}
    
    def get_instruction_args_keys(self):
        return []






class DataIdx0InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_0')

    def check_following(self, value):
        """
        Checks if the response is a table with 3 columns ('وجه المقارنة',
        'التعليم التقليدي', 'التعليم عن بعد') and at least 5 data rows.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.strip().split('\n')
        if not lines:
            return False
        header_idx = -1
        required_headers = ['وجه المقارنة', 'التعليم التقليدي', 'التعليم عن بعد']
        for i, line in enumerate(lines):
            line_stripped = line.strip()
            if not line_stripped:
                continue
            h0_idx = line.find(required_headers[0])
            h1_idx = line.find(required_headers[1])
            h2_idx = line.find(required_headers[2])
            if h0_idx != -1 and h1_idx != -1 and (h2_idx != -1) and (h0_idx < h1_idx < h2_idx):
                header_idx = i
                break
        if header_idx == -1:
            return False
        data_row_count = 0
        separator_pattern = re.compile('^\\s*\\|?\\s*[-=:]+\\s*\\|?\\s*[-=:]+\\s*\\|?\\s*[-=:]+\\s*\\|?\\s*$', re.ASCII)
        for i in range(header_idx + 1, len(lines)):
            line = lines[i]
            cleaned_line = line.strip()
            if not cleaned_line:
                continue
            if separator_pattern.fullmatch(cleaned_line):
                continue
            parts = [part.strip() for part in line.split('|')]
            content_parts = [part for part in parts if part]
            if len(content_parts) >= 3:
                data_row_count += 1
        return data_row_count >= 5



class DataIdx1InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1')

    def check_following(self, value):
        """Checks if the response follows the instruction to not contain specific Arabic vowel letters.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain the letters ا, و, or ي, False otherwise.
        """
        disallowed_letters = {'ا', 'و', 'ي'}
        for char in value:
            if char in disallowed_letters:
                return False
        return True



class DataIdx2InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_2')

    def check_following(self, value):
        """Checks if the response ends with the required phrase.

        Args:
            value: A string representing the response.

        Returns:
            True if the response ends with 'مع خالص حبي وتقديري', False otherwise.
        """
        required_ending = 'مع خالص حبي وتقديري'
        return value.rstrip().endswith(required_ending)



class DataIdx3InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_3')

    def check_following(self, value):
        """Checks if the response defines 'الكتاب' in Arabic within 20-30 words and without using 'هو'.
        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        arabic_punctuation = string.punctuation + '«»٪٫٬٭∴†⁂؟'
        words = re.split('\\s+', value)
        cleaned_words = [word.strip(arabic_punctuation) for word in words if word.strip(arabic_punctuation)]
        word_count = len(cleaned_words)
        length_constraint_met = 20 <= word_count <= 30
        forbidden_word = 'هو'
        forbidden_word_used = forbidden_word in cleaned_words
        return length_constraint_met and (not forbidden_word_used)



class DataIdx4InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_4')

    def check_following(self, value):
        """
        Checks if the response string ends exactly with 'هل هناك أي شيء آخر يمكنني مساعدتك به؟'
        and has content before it, ensuring no characters follow the required phrase.
        """
        required_ending = 'هل هناك أي شيء آخر يمكنني مساعدتك به؟'
        if len(value) <= len(required_ending):
            return False
        if not value.endswith(required_ending):
            return False
        return True



class DataIdx5InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_5')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 5.

        Constraints:
        1. Must include the reason for being late (Cannot be checked programmatically).
        2. Must be brief as possible (Checked using word count).
        3. Must NOT use the word 'آسف'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the programmatically checkable instructions, False otherwise.
        """
        words = value.split()
        if 'آسف' in words:
            return False
        max_word_count = 25
        if len(words) > max_word_count:
            return False
        return True



class DataIdx6InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_6')

    def check_following(self, value):
        """Checks if the response includes key terms related to 'program name' and 'reason for interest' based on the prompt.

        Args:
            value: A string representing the response.

        Returns:
            True if the response appears to follow the key content constraints, False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        has_program = 'برنامج' in value
        has_name = 'اسم' in value
        has_reason = 'سبب' in value
        has_interest = 'اهتمام' in value
        return has_program and has_name and has_reason and has_interest



class DataIdx7InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_7')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 7.
        Instructions:
        1. Must contain a simile (تشبيه).
        2. Must be at least 15 words long.
        3. Must not use any punctuation except the Arabic comma (،).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        if len(words) < 15:
            return False
        allowed_chars = ' ،'
        arabic_letters_range = ''.join((chr(i) for i in range(1536, 1791 + 1)))
        allowed_chars += arabic_letters_range
        for char in value:
            if char not in allowed_chars:
                return False
        simile_detected = False
        if any((word == 'مثل' for word in words)):
            simile_detected = True
        elif 'كأن' in value:
            simile_detected = True
        elif any((word.startswith('ك') and len(word) > 1 for word in words)):
            simile_detected = True
        if not simile_detected:
            return False
        return True



class DataIdx8InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_8')

    def check_following(self, value):
        """Checks if the response follows the instruction constraints.
        Constraints:
        - Do not use the word 'لكن'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if 'لكن' in value:
            return False
        return True



class DataIdx9InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_9')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or len(value) > 280:
            return False
        mentions_competition = 'مسابقة' in value
        date_keywords = ['تاريخ', 'موعد', 'انتهاء', 'نهاية']
        mentions_date_or_deadline = any((keyword in value for keyword in date_keywords))
        return mentions_competition and mentions_date_or_deadline



class DataIdx10InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_10')

    def check_following(self, value):
        """Checks if the response is a comment expressing admiration for nature,
        includes the word 'جمال', and contains a suitable emoji.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        has_jamal = 'جمال' in value
        emoji_pattern = re.compile('[^\\u0600-\\u06FF0-9\\s.,!?"\\\']')
        has_emoji = bool(emoji_pattern.search(value))
        return has_jamal and has_emoji



class DataIdx11InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_11')

    def check_following(self, value):
        """Checks if the response lists exactly three types of renewable energy sources,
           each starting with the word 'الطاقة'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        items = re.split('[,\\n]', value)
        valid_count = 0
        prefix = 'الطاقة'
        min_len = len(prefix) + 1
        for item in items:
            cleaned_item = item.strip()
            if cleaned_item.startswith(prefix) and len(cleaned_item) > len(prefix):
                valid_count += 1
        return valid_count == 3



class DataIdx12InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_12')

    def check_following(self, value):
        """Checks if the response is a sentence longer than 20 words.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return word_count > 20



class DataIdx13InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_13')

    def check_following(self, value):
        """Checks if the response consists of three sentences at most.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentences = re.split('[.!?]', value)
        non_empty_sentences = [s.strip() for s in sentences if s.strip()]
        sentence_count = len(non_empty_sentences)
        return sentence_count <= 3



class DataIdx14InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_14')

    def check_following(self, value):
        """Checks if the response consists of exactly two words and the first word is 'ال'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        words = cleaned_value.split()
        if len(words) != 2:
            return False
        if words[0] != 'ال':
            return False
        return True



class DataIdx15InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_15')

    def check_following(self, value):
        """Checks if the response uses the word 'واجب' at least twice.
        Args:
            value: A string representing the response.

        Returns:
            True if the response uses 'واجب' at least two times, False otherwise.
        """
        if not isinstance(value, str):
            return False
        punctuation = '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~،؛؟!'
        words = value.split()
        wajeb_count = 0
        wajeb_word = 'واجب'
        for word in words:
            cleaned_word = word.strip(punctuation)
            if cleaned_word == wajeb_word:
                wajeb_count += 1
        return wajeb_count >= 2



class DataIdx16InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_16')

    def check_following(self, value):
        """Checks if the response is a paragraph between 40 and 50 words.

        Args:
            value: A string representing the response (expected in Arabic).

        Returns:
            True if the word count of the response is between 40 and 50 (inclusive),
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return 40 <= word_count <= 50



class DataIdx17InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_17')

    def check_following(self, value):
        """Checks if the response is a list of 5 items, where each item starts with
        a character commonly used at the beginning of Arabic present tense verbs (أ, ن, ي, ت).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = [line.strip() for line in value.split('\n') if line.strip()]
        if len(lines) != 5:
            return False
        present_tense_prefixes = ['أ', 'ن', 'ي', 'ت']
        for line in lines:
            if not line:
                return False
            first_char = line[0]
            if first_char not in present_tense_prefixes:
                return False
        return True



class DataIdx18InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_18')

    def check_following(self, value):
        """Checks if the response has exactly 18 words and contains the word 'ضروري' exactly once.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        if len(words) != 18:
            return False
        dorory_count = 0
        punctuation = '.,!?;:،'
        for word in words:
            cleaned_word = word.strip(punctuation)
            if cleaned_word == 'ضروري':
                dorory_count += 1
        if dorory_count != 1:
            return False
        return True



class DataIdx19InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_19')

    def check_following(self, value):
        """Checks if the response is a short play script with exactly two characters,
        each with two non-empty lines of dialogue, separated by exactly one '***'.
        Assumes the structure is: CharacterName
Dialogue Line 1
Dialogue Line 2
***
CharacterName
Dialogue Line 1
Dialogue Line 2.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        parts = value.strip().split('***')
        if len(parts) != 2:
            return False
        characters_info = {}
        for i, part in enumerate(parts):
            lines = [line.strip() for line in part.strip().splitlines() if line.strip()]
            if len(lines) != 3:
                return False
            character_name = lines[0]
            dialogue_lines = lines[1:]
            if not character_name:
                return False
            characters_info[f'char{i + 1}'] = {'name': character_name, 'dialogue': dialogue_lines}
        if len(characters_info) == 2 and characters_info['char1']['name'] == characters_info['char2']['name']:
            return False
        if len(characters_info) != 2:
            return False
        return True



class DataIdx20InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_20')

    def check_following(self, value):
        """Checks if the response is a short advertising text about a new product
        that does not exceed 4 lines and uses double quotation marks (" ") at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        num_lines = len(lines)
        if num_lines > 4:
            return False
        if '"' not in value:
            return False
        return True



class DataIdx21InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_21')

    def check_following(self, value):
        """Checks if the response follows the instruction:
        - Exactly four sentences (ending in ., !, or ؟).
        - Uses the word 'رحلة' exactly twice.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentence_count = len(re.findall('[.!?؟]', value))
        word_count = len(re.findall('\\bرحلة\\b', value))
        return sentence_count == 4 and word_count == 2



class DataIdx22InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_22')

    def check_following(self, value):
        """Checks if the response is the correct single word opposite of "قصير" in Arabic.
        Args:
            value: A string representing the response.

        Returns:
            True if the response is exactly "طويل" (case and space insensitive check might be needed depending on expected input, but exact match is safer here), False otherwise.
        """
        correct_answer = 'طويل'
        return value.strip() == correct_answer



class DataIdx23InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_23')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 23.
        Constraints:
        1. Must mention three benefits (not checked programmatically).
        2. Must be a paragraph (assumed input format).
        3. Paragraph must not exceed 180 words.
        4. Paragraph must start with 'من فوائد وجبة الإفطار...'

        Args:
            value: A string representing the response paragraph.

        Returns:
            True if the response follows the verifiable constraints, False otherwise.
        """
        if not isinstance(value, str):
            return False
        required_start = 'من فوائد وجبة الإفطار...'
        if not value.strip().startswith(required_start):
            return False
        words = value.split()
        max_word_count = 180
        if len(words) > max_word_count:
            return False
        return True



class DataIdx24InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_24')

    def check_following(self, value):
        """Checks if the response is a single Arabic question in Fusha about exercise benefits,
        starts with 'ما', and ends with exactly one '?'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        starts_with_ma = value.lstrip().startswith('ما')
        ends_with_question_mark = value.rstrip().endswith('?')
        exactly_one_question_mark = value.count('?') == 1
        return starts_with_ma and ends_with_question_mark and exactly_one_question_mark



class DataIdx25InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_25')

    def check_following(self, value):
        """Checks if the response appears to be a short piece of text predominantly in Arabic.

        Note: This checker cannot verify if the content is actually a news report
        about a recent local event, as this requires external knowledge and complex NLP.
        It checks feasible constraints: language (Arabic) and approximate length ("short").

        Args:
            value: A string representing the response.

        Returns:
            True if the response meets the language and length criteria, False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value or len(cleaned_value) < 100:
            return False
        if len(cleaned_value) > 2000:
            return False
        arabic_char_count = 0
        total_alpha_count = 0
        for char in cleaned_value:
            if '\u0600' <= char <= 'ۿ' or 'ﹰ' <= char <= '\ufeff':
                arabic_char_count += 1
            if char.isalpha():
                total_alpha_count += 1
        min_arabic_chars_threshold = 50
        min_arabic_proportion_threshold = 0.7
        if arabic_char_count < min_arabic_chars_threshold:
            return False
        if total_alpha_count > 0:
            if arabic_char_count / total_alpha_count < min_arabic_proportion_threshold:
                return False
        return True



class DataIdx26InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_26')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 26.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        haya_count = 0
        for word in words:
            cleaned_word = word.rstrip('.')
            if cleaned_word == 'الحياة':
                haya_count += 1
        if haya_count < 3:
            return False
        if not value.endswith('.') or len(value) < 2:
            return False
        text_before_period = value[:-1]
        forbidden_punctuation = set('!"#$%&\'()*+,-/:;<=>?@[\\]^_`{|}~،؛؟')
        for char in text_before_period:
            if char in forbidden_punctuation:
                return False
            if char == '.':
                return False
        return True



class DataIdx27InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_27')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 27.
        Instructions:
        - Describe benefits of exercising. (Content, not checked)
        - Use at least 6 sentences. (Checked by counting terminators)
        - Highlight at least 3 benefits using hyphens, e.g., -benefit-. (Checked by regex pattern)

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the structural constraints, False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentence_terminators = ['.', '!', '?']
        sentence_count = sum((value.count(term) for term in sentence_terminators))
        try:
            highlighted_benefits = re.findall('-[^-]+-', value)
            highlight_count = len(highlighted_benefits)
        except NameError:
            return False
        return sentence_count >= 6 and highlight_count >= 3



class DataIdx28InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_28')

    def check_following(self, value):
        """Checks if the response follows the instruction regarding format.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        first_tip_marker = 'النصيحة الأولى:'
        second_tip_marker = 'النصيحة الثانية:'
        if first_tip_marker not in value or second_tip_marker not in value:
            return False
        first_marker_index = value.find(first_tip_marker)
        second_marker_index = value.find(second_tip_marker)
        if first_marker_index == -1 or second_marker_index == -1:
            return False
        if first_marker_index >= second_marker_index:
            return False
        return True



class DataIdx29InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_29')

    def check_following(self, value):
        """Checks if the response follows the instruction for IDX 29.
        Constraints:
        1. Exactly three sentences.
        2. Must start with the word 'النوم'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value:
            return False
        if not value.strip().startswith('النوم'):
            return False
        normalized_value = value.strip()
        normalized_value = normalized_value.replace('?', '.')
        normalized_value = normalized_value.replace('!', '.')
        sentences = [s.strip() for s in normalized_value.split('.') if s.strip()]
        if len(sentences) != 3:
            return False
        return True



class DataIdx30InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_30')

    def check_following(self, value):
        """Checks if the response describes the hobby in exactly two points.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (exactly two non-empty lines) or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.split('\n')
        non_empty_lines = [line for line in lines if line.strip()]
        return len(non_empty_lines) == 2



class DataIdx31InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_31')

    def check_following(self, value):
        """
        Checks if the response follows the constraints for question IDX 31.
        Constraints:
        - Dialogue should have exactly six dialogue lines.
        - The word 'كتاب' must appear at least twice.
        - Single quotes (') must be used to indicate direct speech.
        - No exclamation marks (!) should be used.

        Args:
            value: A string representing the response (the dialogue).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if '!' in value:
            return False
        if value.count('كتاب') < 2:
            return False
        lines = value.splitlines()
        dialogue_line_count = 0
        for line in lines:
            if "'" in line:
                dialogue_line_count += 1
        if dialogue_line_count != 6:
            return False
        return True



class DataIdx32InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_32')

    def check_following(self, value):
        """Checks if the response follows the instruction for IDX 32.
        The instruction is to write a thank you letter not exceeding 50 words.

        Args:
            value: A string representing the response (the thank you letter).

        Returns:
            True if the response has 50 words or less, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        return len(words) <= 50



class DataIdx33InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_33')

    def check_following(self, value):
        """Checks if the email is at least 30 words long.

        Args:
            value: A string representing the response (the email).

        Returns:
            True if the word count is 30 or more, False otherwise.
        """
        words = value.split()
        word_count = len(words)
        return word_count >= 30



class DataIdx34InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_34')

    def check_following(self, value):
        """Checks if the response is a single line of Arabic text containing 'قمر' and 'ليل'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        contains_qamar = 'قمر' in value
        contains_lail = 'ليل' in value
        if not (contains_qamar and contains_lail):
            return False
        cleaned_value = value.rstrip()
        is_single_line = '\n' not in cleaned_value
        return is_single_line



class DataIdx35InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_35')

    def check_following(self, value):
        """Checks if the response follows the instruction to use the word 'الشمس' at least once.
        Args:
            value: A string representing the response.

        Returns:
            True if the response contains the word 'الشمس', False otherwise.
        """
        return 'الشمس' in value



class DataIdx36InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_36')

    def check_following(self, value):
        """Checks if the response is a single imperative sentence encouraging cleanliness and starts with an imperative verb.
        Note: Checks for "encourages cleanliness" and "starts with imperative verb" are based on heuristics (keyword/verb lists)
        due to the complexity of full NLP parsing for Arabic.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        terminators = ['.', '!', '?']
        text_to_check_terminators = cleaned_value[:-1] if cleaned_value and cleaned_value[-1] in terminators else cleaned_value
        if any((char in terminators for char in text_to_check_terminators)):
            return False
        cleanliness_keywords = ['نظافة', 'نظيف', 'نظّف', 'اغسل', 'حافظ', 'اهتم', 'كن', 'اجعل', 'ارم', 'طهارة', 'طاهر', 'طهّر']
        has_cleanliness_keyword = any((keyword in cleaned_value for keyword in cleanliness_keywords))
        imperative_verbs = ['نظّف', 'اغسل', 'حافظ', 'اهتم', 'كن', 'اجعل', 'ارم', 'طهّر']
        words = cleaned_value.split()
        first_word = words[0]
        starts_with_imperative = first_word in imperative_verbs
        return has_cleanliness_keyword and starts_with_imperative



class DataIdx37InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_37')

    def check_following(self, value):
        """Checks if the response contains exactly four numbered steps.

        Args:
            value: A string representing the response (recipe).

        Returns:
            True if the response contains exactly four numbered steps, False otherwise.
        """
        if not isinstance(value, str):
            return False
        numbered_step_pattern = re.compile('^\\s*[\\d٠-٩]+[\\.\\)]')
        lines = value.splitlines()
        numbered_step_count = 0
        for line in lines:
            if numbered_step_pattern.match(line):
                numbered_step_count += 1
        return numbered_step_count == 4



class DataIdx38InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_38')

    def check_following(self, value):
        """Checks if the response is an Arabic paragraph of at least 70 words using at least 3 exclamation marks.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        word_count = len(words)
        length_ok = word_count >= 70
        exclamation_count = value.count('!')
        exclamation_ok = exclamation_count >= 3
        return length_ok and exclamation_ok



class DataIdx39InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_39')

    def check_following(self, value):
        """Checks if the response is a single conditional sentence in Arabic,
        starting with 'إذا...' and using an appropriate conditional tool,
        and expresses the result of an action.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value.startswith('إذا'):
            return False
        sentence_enders = ['.', '!', '?']
        if not cleaned_value or cleaned_value[-1] not in sentence_enders:
            return False
        end_punctuation_count = sum((cleaned_value.count(end) for end in sentence_enders))
        if end_punctuation_count != 1:
            return False
        if any((char in sentence_enders for char in cleaned_value[:-1])):
            return False
        if len(cleaned_value) <= len('إذا'):
            return False
        if len(cleaned_value) == len('إذا') + 1 and cleaned_value[-1] in sentence_enders:
            return False
        return True



class DataIdx40InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_40')

    def check_following(self, value):
        """
        Checks if the response is a single Arabic sentence containing two synonyms.
        Note: Programmatic checking for the semantic correctness of synonyms is not feasible
        without external resources (like a lexicon). This checker verifies the structural
        requirements: single Arabic sentence format and minimum length.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the structural instructions, False otherwise.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        if not stripped_value:
            return False
        arabic_char_pattern = re.compile('[\\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF\\uFB50-\\uFDFF\\uFE70-\\uFEFF]')
        if not arabic_char_pattern.search(stripped_value):
            return False
        ending_punctuation = ['.', '!', '?']
        if not stripped_value.endswith(tuple(ending_punctuation)):
            return False
        if sum((stripped_value[:-1].count(p) for p in ending_punctuation)) > 0:
            return False
        words = stripped_value.split()
        if len(words) < 3:
            return False
        return True



class DataIdx41InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_41')

    def check_following(self, value):
        """Checks if the response starts with 'العنصر الكيميائي'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response starts with 'العنصر الكيميائي', False otherwise.
        """
        required_prefix = 'العنصر الكيميائي'
        return value.strip().startswith(required_prefix)



class DataIdx42InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_42')

    def check_following(self, value):
        """Checks if the response connects 'الشمس مشرقة' and 'الجو دافئ' using 'و'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        required_phrase1 = 'الشمس مشرقة'
        required_phrase2 = 'الجو دافئ'
        required_conjunction = 'و'
        has_phrase1 = required_phrase1 in value
        has_phrase2 = required_phrase2 in value
        has_conjunction = required_conjunction in value
        return has_phrase1 and has_phrase2 and has_conjunction



class DataIdx43InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_43')

    def check_following(self, value):
        """Checks if the response mentions exactly three points and uses 'تطوير' in each point.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = [line.strip() for line in value.splitlines() if line.strip()]
        if len(lines) != 3:
            return False
        keyword = 'تطوير'
        for line in lines:
            if keyword not in line:
                return False
        return True



def get_paragraphs(text):
    potential_paragraphs = re.split('\\n\\s*\\n+', text.strip())
    paragraphs = [p.strip() for p in potential_paragraphs if p.strip()]
    return paragraphs

class DataIdx44InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_44')
        self.first_person_pattern = re.compile('\\bأنا\\b|\\bنحن\\b|\\w+تُ\\b|\\w+نا\\b')
        self.third_person_pattern = re.compile('\\bهو\\b|\\bهي\\b|\\bهم\\b|\\bهن\\b|\\bهما\\b|\\w+وا\\b|\\w+تْ\\b|\\w+ه\\b|\\w+ها\\b|\\w+هم\\b|\\w+هن\\b|\\w+هما\\b')

    def check_following(self, value):
        """Checks if the response has two paragraphs, first in first-person, second in third-person.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction (2 paragraphs, para1 first-person, para2 third-person), False otherwise.
        """
        paragraphs = get_paragraphs(value)
        if len(paragraphs) != 2:
            return False
        para1 = paragraphs[0]
        para2 = paragraphs[1]
        is_para1_first_person = bool(self.first_person_pattern.search(para1))
        is_para2_third_person = bool(self.third_person_pattern.search(para2))
        return is_para1_first_person and is_para2_third_person



def compare_arabic_letters(char1, char2):
    return -1 if char1 < char2 else 1 if char1 > char2 else 0

class DataIdx45InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_45')

    def check_following(self, value: str) -> bool:
        """Checks if the response is a numbered list of 3 Arabic fruit names, sorted alphabetically.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        lines = [line.strip() for line in value.strip().split('\n') if line.strip()]
        item_pattern = re.compile('^\\s*(\\d+)[\\.\\-\\)]\\s*(.+?)\\s*$')
        items = []
        for line in lines:
            match = item_pattern.match(line)
            if not match:
                return False
            number = int(match.group(1))
            text = match.group(2).strip()
            if not re.search('[\\u0600-\\u06FF]', text):
                return False
            items.append((number, text))
        if len(items) != 3:
            return False
        expected_number = 1
        for number, _ in items:
            if number != expected_number:
                return False
            expected_number += 1
        fruit_names = [text for _, text in items]
        sorted_fruit_names = sorted(fruit_names)
        if fruit_names != sorted_fruit_names:
            return False
        return True



class DataIdx46InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_46')

    def check_following(self, value):
        """Checks if the response lists steps using numbers.

        Args:
            value: A string representing the response.

        Returns:
            True if the response appears to contain numbered steps, False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        numbered_step_pattern = re.compile('^\\s*\\d+[\\.\\)]?\\s+')
        numbered_lines_count = 0
        for line in lines:
            if numbered_step_pattern.match(line):
                numbered_lines_count += 1
        return numbered_lines_count >= 2



class DataIdx47InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_47')

    def check_following(self, value):
        """Checks if the response describes a historical city, mentions its name,
        and at least one historical landmark in it, in Arabic, as a paragraph.
        Args:
            value: A string representing the response (expected in Arabic).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        text = value.strip()
        arabic_char_count = len(re.findall('[\\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF]', text))
        if arabic_char_count < 10:
            return False
        if len(text) < 100:
            return False
        sentence_enders = ['.', '!', '؟']
        if not any((ender in text for ender in sentence_enders)):
            return False
        city_name_patterns = [re.compile('مدينة\\s+\\S+'), re.compile('\\S+\\s+مدينة\\b'), re.compile('المدينة\\s+\\S+'), re.compile('\\S+\\s+المدينة\\b'), re.compile('\\S+\\s+مدينة تاريخية')]
        city_name_found = any((pattern.search(text) for pattern in city_name_patterns))
        landmark_keywords = ['معلم', 'أثري', 'قلعة', 'مسجد', 'كنيسة', 'متحف', 'قصر', 'سوق', 'موقع', 'هيكل', 'معبد', 'سور']
        landmark_name_patterns = []
        for kw in landmark_keywords:
            landmark_name_patterns.append(re.compile(f'\\S+\\s+\\b{kw}\\b'))
            landmark_name_patterns.append(re.compile(f'\\b{kw}\\s+\\S+'))
        landmark_name_patterns.append(re.compile('\\bمعلم تاريخي\\s+\\S+'))
        landmark_name_patterns.append(re.compile('\\S+\\s+\\bمعلم تاريخي\\b'))
        landmark_name_patterns.append(re.compile('\\bموقع تاريخي\\s+\\S+'))
        landmark_name_patterns.append(re.compile('\\S+\\s+\\bموقع تاريخي\\b'))
        landmark_name_patterns.append(re.compile('\\bموقع أثري\\s+\\S+'))
        landmark_name_patterns.append(re.compile('\\S+\\s+\\bموقع أثري\\b'))
        landmark_name_found = any((pattern.search(text) for pattern in landmark_name_patterns))
        return city_name_found and landmark_name_found



class DataIdx48InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_48')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 48.

        Instructions:
        - Write a short thank-you message. (Cannot reliably check 'short')
        - Divide the message into two sections. (Check for paragraph break)
        - Do not use the word "شكراً" (shukran) in the message.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if 'شكراً' in value:
            return False
        has_paragraph_break = False
        if '\n\n' in value:
            has_paragraph_break = True
        elif '\r\n\r\n' in value:
            has_paragraph_break = True
        elif '\n \n' in value or '\n\t\n' in value:
            has_paragraph_break = True
        if not has_paragraph_break:
            return False
        return True



class DataIdx49InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_49')

    def check_following(self, value):
        """Checks if the response is a short essay about the importance of reading,
           including an introduction and a conclusion.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the structural constraints (length, paragraph breaks)
            implied by the instruction, False otherwise.
        """
        if not isinstance(value, str):
            return False
        text = value.strip()
        if not text:
            return False
        words = text.split()
        word_count = len(words)
        min_words = 100
        max_words = 400
        if word_count < min_words or word_count > max_words:
            return False
        has_multiple_paragraphs = '\n\n' in text or '\r\n\r\n' in text
        if not has_multiple_paragraphs:
            return False
        return True



class DataIdx50InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_50')

    def check_following(self, value):
        """Checks if the response is a single question in colloquial Arabic about the best way to learn a new language, ending with a question mark.
        Due to the difficulty of programmatically verifying "colloquial Arabic" and the exact "topic" without advanced NLP,
        this checker primarily focuses on the structural constraints: being a single question ending with '?'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the strictly checkable instructions (ends with '?' and appears to be a single sentence), False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value.endswith('?'):
            return False
        chars_to_check = cleaned_value[:-1].replace(' ', '')
        if any((char in chars_to_check for char in ['.', '!', '?'])):
            return False
        return True



class DataIdx51InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_51')

    def check_following(self, value):
        """Checks if the response (a string) has a word count not exceeding 30.

        Args:
            value: A string representing the response.

        Returns:
            True if the word count is 30 or less, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return word_count <= 30



class DataIdx52InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_52')

    def check_following(self, value):
        """Checks if the response follows the instruction for question idx_52.

        The instruction requires a news report of no less than 200 words.
        This function checks the word count constraint.

        Args:
            value: A string representing the response.

        Returns:
            True if the response has at least 200 words, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        return len(words) >= 200



class DataIdx53InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_53')

    def check_following(self, value):
        """
        Checks if the response contains common Arabic copula words often present in 'X is Y' structures,
        as a very simplified heuristic for detecting a potential metaphor.
        Note: This check is highly unreliable and prone to false positives/negatives
        as it does not perform actual metaphor detection based on meaning or context.
        It assumes that a simple metaphor is likely to use a form of "to be".
        Args:
            value: A string representing the response.

        Returns:
            True if the response contains common copula words, False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        copula_forms = ['كان', 'يكون', 'هو', 'هي', 'كانت', 'تكون', 'لست', 'ليس', 'ليست']
        for form in copula_forms:
            if form in value:
                return True
        return False



class DataIdx54InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_54')

    def check_following(self, value):
        """Checks if the response string contains any commas.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain any commas, False otherwise.
        """
        return ',' not in value



class DataIdx55InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_55')

    def check_following(self, value):
        """Checks if the response starts with 'سيدي المدير' and contains exactly three sentences."""
        if not isinstance(value, str):
            return False
        trimmed_value = value.strip()
        if not trimmed_value.startswith('سيدي المدير'):
            return False
        sentences = re.split('[.!?]+', trimmed_value)
        valid_sentences = [s.strip() for s in sentences if s.strip()]
        if len(valid_sentences) != 3:
            return False
        return True



class DataIdx56InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_56')

    def check_following(self, value):
        """Checks if the response is a polite request to a neighbor for help carrying something heavy.
        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        value = value.strip()
        neighbor_terms = ['جاري', 'جارك', 'يا جاري', 'يا جارتي', 'جارنا']
        help_terms = ['مساعدة', 'تساعدني', 'تساعديني', 'تساعدونا', 'يساعدني', 'أسألك المساعدة', 'ممكن تساعد', 'هل يمكنك المساعدة', 'أحتاج مساعدة']
        heavy_carrying_terms = ['شيء ثقيل', 'ثقيل', 'حمله', 'أحمل', 'نحمل', 'رفعه', 'أرفع', 'نرفع', 'وزنه كبير', 'حمل', 'نقل شيء ثقيل', 'صعب علي حمله', 'لا أستطيع حمله']
        polite_terms = ['من فضلك', 'لو سمحت', 'لو سمحتِ', 'شكراً', 'أرجو', 'تكرماً', 'مع الشكر', 'آسف للإزعاج', 'رجاءً', 'لطفاً', 'بعد إذنك', 'أرجو المعذرة']
        has_neighbor = any((term in value for term in neighbor_terms))
        has_help = any((term in value for term in help_terms))
        has_heavy_carrying = any((term in value for term in heavy_carrying_terms))
        has_polite = any((term in value for term in polite_terms))
        return has_neighbor and has_help and has_heavy_carrying and has_polite



class DataIdx57InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('57')

    def check_following(self, value):
        """Checks if the response is an interrogative sentence in Arabic, starts with 'ما هي',
           and ends with '?'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        starts_with_ma_hiya = cleaned_value.startswith('ما هي')
        ends_with_question_mark = cleaned_value.endswith('?')
        is_sufficiently_long = len(cleaned_value) > len('ما هي?')
        return starts_with_ma_hiya and ends_with_question_mark and is_sufficiently_long



class DataIdx58InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_58')

    def check_following(self, value):
        """Checks if the response follows the instruction regarding word count.

        Args:
            value: A string representing the response (the paragraph).

        Returns:
            True if the response contains between 70 and 80 words (inclusive),
            False otherwise.
        """
        words = value.split()
        word_count = len(words)
        return 70 <= word_count <= 80



class DataIdx59InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_59')

    def check_following(self, value):
        """Checks if the response is a short joke in exactly two sentences, containing a question and an answer.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if '?' not in value:
            return False
        sentences = [s.strip() for s in re.split('[.?!]', value) if s.strip()]
        if len(sentences) != 2:
            return False
        return True



class DataIdx60InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_60')

    def check_following(self, value):
        """Checks if the response is a summary with less than 10 words.

        Args:
            value: A string representing the response (the summary).

        Returns:
            True if the response has fewer than 10 words, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return word_count < 10



class DataIdx61InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_61')

    def check_following(self, value):
        """Checks if the response is a short paragraph not exceeding five lines.

        Args:
            value: A string representing the response.

        Returns:
            True if the response has 5 or fewer lines, False otherwise.
        """
        lines = value.strip().split('\n')
        line_count = len(lines)
        return line_count <= 5



class DataIdx62InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_62')

    def check_following(self, value: str) -> bool:
        """
        Checks if the response is an informal Arabic message inviting to a movie.
        Constraints checked:
        1. Is in Arabic (basic check for presence of Arabic characters).
        2. Mentions movie or cinema (keywords: "فيلم", "سينما").
        3. Contains words suggesting invitation or shared activity
           (keywords: "نذهب", "نشاهد", "تعال", "معاً", "هل", "ما رأيك", "تود", "ممكن").
        """
        if not isinstance(value, str):
            return False
        value = value.strip()
        arabic_char_pattern = re.compile('[\\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF\\uFB50-\\uFDFF\\uFE70-\\uFEFF]')
        if not arabic_char_pattern.search(value):
            return False
        movie_keywords = ['فيلم', 'سينما']
        has_movie_topic = any((keyword in value for keyword in movie_keywords))
        if not has_movie_topic:
            return False
        invitation_keywords = ['نذهب', 'نشاهد', 'تعال', 'معاً', 'هل', 'ما رأيك', 'تود', 'ممكن']
        has_suggestion_indicator = any((keyword in value for keyword in invitation_keywords))
        return has_movie_topic and has_suggestion_indicator



class DataIdx63InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_63')

    def check_following(self, value):
        """Checks if the value is a string starting and ending with double quotes.

        Args:
            value: A string representing the response.

        Returns:
            True if the response starts and ends with double quotes, False otherwise.
        """
        if not isinstance(value, str):
            return False
        return len(value) >= 2 and value.startswith('"') and value.endswith('"')



class DataIdx64InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_64')

    def check_following(self, value):
        """
        Checks if the response is a single paragraph between 75 and 85 words.
        Note: Checking for the complete absence of adjectives is not reliably
        possible with basic string manipulation or regex in Arabic and requires
        advanced NLP techniques (like POS tagging), which are outside the scope
        of this basic checker. Therefore, this constraint is not programmatically verified here.
        """
        if not isinstance(value, str):
            return False
        single_paragraph = '\n\n' not in value.strip()
        if not value.strip():
            return False
        words = re.findall('\\b\\w+\\b', value)
        word_count = len(words)
        word_count_ok = 75 <= word_count <= 85
        return single_paragraph and word_count_ok



class DataIdx65InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_65')

    def check_following(self, value):
        """Checks if the response lists three sentences, each containing exactly seven words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        sentences = [line.strip() for line in value.strip().split('\n') if line.strip()]
        if len(sentences) != 3:
            return False
        for sentence in sentences:
            words = [word for word in sentence.split(' ') if word]
            if len(words) != 7:
                return False
        return True



class DataIdx66InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_66')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 66.

        Args:
            value: A string representing the response (cake recipe).

        Returns:
            True if the response has at least 6 steps (lines) and does not
            contain the word 'سكر', False otherwise.
        """
        if 'سكر' in value:
            return False
        steps = value.strip().split('\n')
        num_steps = len([step for step in steps if step.strip()])
        if num_steps < 6:
            return False
        return True



class DataIdx67InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_67')

    def check_following(self, value):
        """Checks if the response for IDX 67 (Activity Proposal) includes objectives and target audience.
        Args:
            value: A string representing the student's response.

        Returns:
            True if the response includes terms related to objectives and target audience, False otherwise.
        """
        if not isinstance(value, str):
            return False
        objective_keywords = ['أهداف', 'الهدف', 'تهدف', 'يهدف']
        audience_keywords = ['الجمهور المستهدف', 'الفئة المستهدفة', 'الطلاب المستهدفين']
        has_objectives = any((keyword in value for keyword in objective_keywords))
        has_audience = any((keyword in value for keyword in audience_keywords))
        return has_objectives and has_audience



class DataIdx68InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('68')

    def check_following(self, value):
        """Checks if the response contains the required Arabic words 'ابتكار' and 'تكنولوجيا'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        required_word1 = 'ابتكار'
        required_word2 = 'تكنولوجيا'
        return required_word1 in value and required_word2 in value



class DataIdx69InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_69')

    def check_following(self, value):
        """Checks if the response is a non-empty string, contains Arabic characters, and is different from the original sentence.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the basic structural instructions (is a different, non-empty string with Arabic characters), False otherwise.
        """
        if not isinstance(value, str):
            return False
        if not value.strip():
            return False
        if not any(('\u0600' <= c <= 'ۿ' for c in value)):
            return False
        original_sentence = 'الولد ذهب إلى المدرسة.'
        if value.strip() == original_sentence.strip():
            return False
        return True



class DataIdx70InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_70')

    def check_following(self, value):
        """Checks if the response follows the constraints for question 70.
        Constraints:
        1. A brief recipe for making a cup of tea. (Checked heuristically by ensuring at least 3 significant lines)
        2. Each step must start with an imperative verb. (Checked heuristically by ensuring each significant line starts with an Arabic word that doesn't start with 'ال')

        Args:
            value: A string representing the response (the recipe).

        Returns:
            True if the response follows the constraints, False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        significant_lines = [line.strip() for line in lines if line.strip()]
        if len(significant_lines) < 3:
            return False
        arabic_letter_range = range(1536, 1791 + 1)
        for line in significant_lines:
            words = line.split(maxsplit=1)
            if not words:
                return False
            first_word = words[0]
            if not first_word:
                return False
            first_char_of_word = first_word[0]
            if not 1536 <= ord(first_char_of_word) <= 1791:
                return False
            if len(first_word) >= 2 and first_word[0] == 'ا' and (first_word[1] == 'ل'):
                return False
        return True



class DataIdx71InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_71')

    def check_following(self, value):
        """Checks if the response is a formal apology letter in Arabic that includes the word 'responsibility' and ends with the required phrase.

        Args:
            value: A string representing the response (the apology letter).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        contains_responsibility = 'مسؤولية' in value
        ends_with_respectful_closing = value.strip().endswith('وتقبلوا فائق الاحترام')
        return contains_responsibility and ends_with_respectful_closing



class DataIdx72InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_72')

    def check_following(self, value):
        """Checks if the response is a valid JSON, contains 'توابل' at least twice,
           and is solely JSON output.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instructions, False otherwise.
        """
        try:
            json.loads(value)
        except json.JSONDecodeError:
            return False
        keyword = 'توابل'
        count = value.count(keyword)
        if count < 2:
            return False
        return True



class DataIdx73InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_73')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 73.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        max_length = 200
        required_start = 'عزيزي المستلم،'
        required_keyword = 'التواصل'
        if not isinstance(value, str) or not value.strip():
            return False
        if not value.strip().startswith(required_start):
            return False
        if required_keyword not in value:
            return False
        if len(value) > max_length:
            return False
        return True



class DataIdx74InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_74')

    def check_following(self, value):
        """Checks if the response is a single exclamation sentence starting with 'ما أجمل'
           and ending with '!' describing a natural scenery.
           Note: The check for describing a natural scenery is structural/syntactic.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        start_phrase = 'ما أجمل'
        end_char = '!'
        if not cleaned_value.startswith(start_phrase):
            return False
        if not cleaned_value.endswith(end_char):
            return False
        if len(cleaned_value) <= len(start_phrase):
            return False
        content_before_end = cleaned_value[:-1]
        if '.' in content_before_end or '?' in content_before_end:
            return False
        return True



class DataIdx75InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_75')

    def check_following(self, value):
        """
        Checks if the response is a single sentence describing the importance of time,
        and contains the word 'الوقت' exactly three times.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        response = value.strip()
        terminators = ['.', '!', '?']
        terminator_count = sum((response.count(t) for t in terminators))
        is_single_sentence_heuristic = terminator_count == 1
        word_count = 0
        target_word = 'الوقت'
        punctuation_to_remove = '.,!?;:،؛«»()[]{}'
        words = response.split()
        for word in words:
            cleaned_word = word.strip(punctuation_to_remove)
            if cleaned_word == target_word:
                word_count += 1
        return is_single_sentence_heuristic and word_count == 3



class DataIdx76InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_76')

    def check_following(self, value):
        """Checks if the response is a numbered list of 5 items,
        where each item has exactly two words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.splitlines()
        lines = [line for line in lines if line.strip()]
        if len(lines) != 5:
            return False
        item_regex = re.compile('^\\s*(\\d+)\\s*[-).]?\\s*(.*)$')
        expected_number = 1
        for line in lines:
            match = item_regex.match(line)
            if not match:
                return False
            try:
                number = int(match.group(1))
                content = match.group(2).strip()
                if number != expected_number:
                    return False
                words = content.split()
                word_count = len([word for word in words if word])
                if word_count != 2:
                    return False
                expected_number += 1
            except ValueError:
                return False
            except IndexError:
                return False
        return True



class DataIdx77InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_77')

    def check_following(self, value):
        """Checks if the response contains three types of famous Arabic sweets with a brief taste description for each, all in Arabic, presented in a numbered list format (1., 2., 3. or ١., ٢., ٣.).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        has_arabic = any(('\u0600' <= c <= 'ۿ' for c in value))
        if not has_arabic:
            return False
        lines = value.splitlines()
        lines = [line for line in lines if line.strip()]
        if not lines:
            return False
        markers_regex = [re.compile('^\\s*[1١]\\.\\s*'), re.compile('^\\s*[2٢]\\.\\s*'), re.compile('^\\s*[3٣]\\.\\s*')]
        marker_line_indices = []
        last_line_idx = -1
        for marker_re in markers_regex:
            found_idx = -1
            for j in range(last_line_idx + 1, len(lines)):
                if marker_re.match(lines[j]):
                    found_idx = j
                    break
            if found_idx == -1:
                return False
            marker_line_indices.append(found_idx)
            last_line_idx = found_idx
        segment_ranges = [(marker_line_indices[0], marker_line_indices[1]), (marker_line_indices[1], marker_line_indices[2]), (marker_line_indices[2], len(lines))]
        segments = ['\n'.join(lines[start:end]) for start, end in segment_ranges]
        taste_keywords = ['حلو', 'مقرمش', 'طري', 'كريمي', 'غني', 'لذيذ', 'مر', 'مالح', 'حامض', 'مقلي', 'مشوي', 'بارد', 'ساخن', 'مذاق', 'طعم', 'بنكهة', 'سكر', 'عسل', 'قطر', 'شيرة', 'محلى']
        for i, segment in enumerate(segments):
            match = markers_regex[i].match(segment)
            if match:
                segment_text_after_marker = segment[match.end():].strip()
                if i < 2:
                    next_marker_start_in_value = value.find(lines[marker_line_indices[i + 1]])
                    segment_text_after_marker = value[value.find(lines[marker_line_indices[i]]) + match.end():next_marker_start_in_value].strip()
                else:
                    segment_text_after_marker = value[value.find(lines[marker_line_indices[i]]) + match.end():].strip()
            else:
                segment_text_after_marker = segment.strip()
            has_description = False
            for keyword in taste_keywords:
                if keyword in segment_text_after_marker:
                    has_description = True
                    break
            if not has_description:
                return False
        return True



class DataIdx78InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_78')

    def check_following(self, value):
        """Checks if the response summarizes the importance of reading in exactly three sentences
           and uses synonyms for "important".
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value:
            return False
        temp_value = value.replace('!', '.').replace('?', '.')
        sentences = [s for s in temp_value.split('.') if s.strip()]
        sentence_count = len(sentences)
        synonyms = ['ضروري', 'أساسي', 'حيوي', 'جوهري', 'لازم', 'هام']
        uses_synonym = False
        for synonym in synonyms:
            if synonym in value:
                uses_synonym = True
                break
        return sentence_count == 3 and uses_synonym



class DataIdx79InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_79')

    def check_following(self, value):
        """
        Checks if the response includes both a description of a historical landmark
        and an attempt at a drawing, based on text-based heuristics.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        lines = value.splitlines()
        num_lines = len(lines)
        arabic_char_count = sum((1 for char in value if '\u0600' <= char <= 'ۿ' or char.isspace()))
        MIN_DESC_CHARS = 30
        has_description_attempt = arabic_char_count >= MIN_DESC_CHARS
        drawing_chars = '+-*#_\\/|^<>(){}[]='
        drawing_char_count = sum((1 for char in value if char in drawing_chars))
        MIN_DRAW_CHARS = 5
        MIN_LINES_FOR_DRAWING = 3
        has_drawing_attempt = drawing_char_count >= MIN_DRAW_CHARS and num_lines >= MIN_LINES_FOR_DRAWING
        return has_description_attempt and has_drawing_attempt



class DataIdx80InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_80')

    def check_following(self, value):
        """
        Checks if the response uses only exclamation marks at the end of each sentence.
        Specifically, checks if the response contains '.' or '?' anywhere, and if it ends with '!'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        trimmed_value = value.strip()
        if not trimmed_value:
            return False
        if '.' in trimmed_value or '?' in trimmed_value:
            return False
        if not trimmed_value.endswith('!'):
            return False
        return True



class DataIdx81InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        self.idx = 'idx_81'

    def check_following(self, value):
        """Checks if the response lists exactly 5 items in a numbered list format."""
        if not isinstance(value, str):
            return False
        lines = value.strip().splitlines()
        if not lines:
            return False
        list_item_pattern = re.compile('^\\s*[\\d٠١٢٣٤٥٦٧٨٩]+[\\.\\-\\)]\\s*.+')
        numbered_items_count = 0
        for line in lines:
            if list_item_pattern.match(line):
                numbered_items_count += 1
        return numbered_items_count == 5



class DataIdx82InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_82')

    def check_following(self, value):
        """Checks if the response is a short advertisement (max 30 words) in Arabic containing 'استدامة' exactly once.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count > 30:
            return False
        sustainability_count = len(re.findall('\\bاستدامة\\b', value))
        if sustainability_count != 1:
            return False
        return True



class DataIdx83InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_83')

    def check_following(self, value):
        """Checks if the response has content before and ends with a title in square brackets [].
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        pattern = '.+\\[.*?\\]$'
        return re.fullmatch(pattern, value) is not None



class DataIdx84InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_84')

    def check_following(self, value):
        """Checks if the response contains at least 3 steps (lines) as required.
        Note: Checking for imperative verbs requires sophisticated NLP and is not included in this basic checker.
        This checker only verifies the number of distinct non-empty lines.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains at least 3 non-empty lines, False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.splitlines()
        non_empty_lines = [line for line in lines if line.strip()]
        return len(non_empty_lines) >= 3



class DataIdx85InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_85')

    def check_following(self, value):
        """Checks if the response mentions a date in Arabic text.
        Args:
            value: A string representing the response.

        Returns:
            True if a date is detected, False otherwise.
        """
        if not isinstance(value, str) or not value:
            return False
        month_names = ['يناير', 'فبراير', 'مارس', 'أبريل', 'مايو', 'يونيو', 'يوليو', 'أغسطس', 'سبتمبر', 'أكتوبر', 'نوفمبر', 'ديسمبر', 'كانون الثاني', 'شباط', 'آذار', 'نيسان', 'أيار', 'حزيران', 'تموز', 'آب', 'أيلول', 'تشرين الأول', 'تشرين الثاني', 'كانون الأول', 'محرم', 'صفر', 'ربيع الأول', 'ربيع الثاني', 'جمادى الأولى', 'جمادى الآخرة', 'رجب', 'شعبان', 'رمضان', 'شوال', 'ذو القعدة', 'ذو الحجة']
        month_names_escaped = sorted(map(re.escape, month_names), key=len, reverse=True)
        month_names_pattern = '|'.join(month_names_escaped)
        digit_pattern = '[0-9٠-٩]'
        pattern1 = f'{digit_pattern}+[-/.]' + f'{digit_pattern}+[-/.]' + f'{digit_pattern}+'
        pattern2 = f'{digit_pattern}+\\s+(?:{month_names_pattern})[\\s,]*{digit_pattern}*?'
        pattern3 = f'(?:{month_names_pattern})\\s+{digit_pattern}+[\\s,]*{digit_pattern}*?'
        pattern4 = f'{digit_pattern}+\\s+(?:{month_names_pattern})\\s+{digit_pattern}+'
        full_pattern = f'(?:{pattern1})|(?:{pattern2})|(?:{pattern3})|(?:{pattern4})'
        if re.search(full_pattern, value, re.UNICODE):
            return True
        else:
            return False



class DataIdx86InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_86')

    def check_following(self, value):
        """Checks if the response describes a landscape using at least five sensory details (sight, hearing, smell, taste, touch).
        Args:
            value: A string representing the response.

        Returns:
            True if the response includes indicators for all five senses, False otherwise.
        """
        sense_keywords = {'sight': set(['لون', 'ألوان', 'ضوء', 'شمس', 'قمر', 'سماء', 'نجم', 'غيم', 'جبل', 'شجر', 'ورد', 'منظر', 'شكل', 'يرى', 'يبدو', 'لامع', 'ساطع', 'داكن', 'بصر', 'مرئي', 'واسع', 'جميل', 'أزرق', 'أخضر', 'أحمر', 'ذهبي', 'فضي', 'تدرجات', 'لمعان', 'عين', 'عيون', 'نظر', 'بصري', 'بصرية', 'صورة', 'مناظر', 'مرأى', 'بصريات', 'رؤية', 'بصرياً']), 'hearing': set(['صوت', 'أصوات', 'يسمع', 'سمع', 'صدى', 'همس', 'غناء', 'زقزقة', 'خرير', 'حفيف', 'دندنة', 'صاخب', 'هادئ', 'لحن', 'طنين', 'صرير', 'أذن', 'أصداء', 'مسموع', 'سمعية', 'ضجيج', 'سمعياً', 'سمعيات']), 'smell': set(['رائحة', 'عبير', 'عطر', 'يشم', 'شم', 'فواح', 'زكي', 'أريج', 'بخّور', 'أنف', 'شّمية', 'روائح', 'شمية', 'شمياً', 'شمم']), 'taste': set(['طعم', 'مذاق', 'يتذوق', 'تذوق', 'حلو', 'مر', 'حامض', 'مالح', 'لذيذ', 'نكهة', 'فاكهة', 'لسان', 'فم', 'تذوّق', 'مذاقات', 'طعوم', 'ذوق', 'تذوقي', 'حاسة التذوق', 'تذوقاً']), 'touch': set(['ملمس', 'ناعم', 'خشن', 'دافئ', 'بارد', 'حرارة', 'يلمس', 'لمس', 'يشعر', 'صلب', 'لين', 'رطب', 'جاف', 'حرير', 'صخر', 'برودة', 'سخونة', 'حرّ', 'برد', 'جلد', 'يد', 'أصابع', 'شعور', 'لمسية', 'ملموس', 'ملامسة', 'تلامس', 'أشعر', 'حاسة اللمس', 'لمسيات', 'لمسياً', 'ملموساً'])}
        words = re.findall('\\b[\\wء-ي]+\\b', value)
        senses_found = {sense: False for sense in sense_keywords}
        for word in words:
            for sense, keywords_set in sense_keywords.items():
                if word in keywords_set:
                    senses_found[sense] = True
        return all(senses_found.values())



class DataIdx87InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_87')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 87.
        Instructions:
        - Explain the importance of waste recycling for teenagers in at least three sentences.
        - Use the word 'البيئة' (the environment) exactly twice.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        keyword_count = value.count('البيئة')
        if keyword_count != 2:
            return False
        sentence_enders = ['.', '!', '؟']
        sentence_count = 0
        for char in value:
            if char in sentence_enders:
                sentence_count += 1
        if sentence_count < 3:
            return False
        return True



class DataIdx88InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_88')

    def check_following(self, value):
        """Checks if the response follows the instruction for IDX 88.

        Constraints:
        1. Short joke about a lazy student (content - not strictly checked programmatically).
        2. Includes a question and an answer (checked structurally by looking for text before first QM and after last QM).
        3. Uses no punctuation except for the question mark ('?' or '؟').

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        allowed_qm = '?؟'
        has_qm = any((q in value for q in allowed_qm))
        if not has_qm:
            return False
        first_qm_idx = -1
        last_qm_idx = -1
        for i, char in enumerate(value):
            if char in allowed_qm:
                if first_qm_idx == -1:
                    first_qm_idx = i
                last_qm_idx = i
        if not value[:first_qm_idx].strip():
            return False
        if not value[last_qm_idx + 1:].strip():
            return False
        forbidden_punctuation = '!"#$%&\'()*+,-./:;<=>@[\\]^_`{|}~' + '،' + '؛' + '«' + '»'
        for char in value:
            if char in forbidden_punctuation:
                return False
        return True



class DataIdx89InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_89')

    def check_following(self, value):
        """Checks if the poem consists of exactly four verses, with each verse having exactly seven words.

        Args:
            value: A string representing the poem.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        verses = value.strip().split('\n')
        non_empty_verses = [v.strip() for v in verses if v.strip()]
        if len(non_empty_verses) != 4:
            return False
        for verse in non_empty_verses:
            words = verse.split()
            if len(words) != 7:
                return False
        return True



class DataIdx90InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('90')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 90.

        Instructions:
        1. Repeat the exact request word-for-word first.
        2. The request to repeat is: "اكتب قائمة مختصرة بثلاثة أنشطة يمكنك القيام بها في عطلة نهاية الأسبوع. يجب أن تبدأ كل نقطة في القائمة بفعل أمر. استخدم الأرقام الهندية في الترقيم. يجب أن تكون القائمة موجزة قدر الإمكان."
        3. Provide a list of three activities after the repeated request.
        4. Each list item must start with an imperative verb (hard to check programmatically without NLP/dictionary, skipping this specific check for simplicity and focusing on verifiable structure).
        5. Use Indian numerals (١, ٢, ٣) for numbering, likely followed by a period (e.g., ١.).
        6. No text or characters should appear before the repeated request.
        7. The list should contain exactly three items.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the verifiable instructions or False otherwise.
        """
        if not isinstance(value, str):
            return False
        expected_request_to_repeat = 'اكتب قائمة مختصرة بثلاثة أنشطة يمكنك القيام بها في عطلة نهاية الأسبوع. يجب أن تبدأ كل نقطة في القائمة بفعل أمر. استخدم الأرقام الهندية في الترقيم. يجب أن تكون القائمة موجزة قدر الإمكان.'
        if not value.strip().startswith(expected_request_to_repeat):
            return False
        after_request = value.strip()[len(expected_request_to_repeat):].strip()
        lines = [line.strip() for line in after_request.splitlines() if line.strip()]
        if len(lines) != 3:
            return False
        if not lines[0].startswith('١.'):
            return False
        if not lines[1].startswith('٢.'):
            return False
        if not lines[2].startswith('٣.'):
            return False
        return True



class DataIdx91InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_91')

    def check_following(self, value):
        """Checks if the response is a numbered list of 5 inventions,
        includes keywords 'الطب', 'الاتصالات', 'النقل' within the list items,
        and attempts to verify mention of inventor/team for each item
        (approximated by minimum content length per item line).
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        numbered_lines_content = []
        found_numbers = []
        list_item_pattern = re.compile('^\\s*([\\d١٢٣٤٥]+)[\\.\\)]\\s*(.+)')
        arabic_digits = '٠١٢٣٤٥٦٧٨٩'
        latin_digits = '0123456789'
        arabic_to_latin = str.maketrans(arabic_digits, latin_digits)
        for line in lines:
            line = line.strip()
            if not line:
                continue
            match = list_item_pattern.match(line)
            if match:
                number_str = match.group(1)
                content = match.group(2).strip()
                try:
                    number = int(number_str.translate(arabic_to_latin))
                    found_numbers.append(number)
                    numbered_lines_content.append(content)
                except ValueError:
                    return False
        if len(found_numbers) != 5:
            return False
        if sorted(found_numbers) != list(range(1, 6)) or found_numbers != list(range(1, 6)):
            return False
        list_content_string = ' '.join(numbered_lines_content)
        keywords = ['الطب', 'الاتصالات', 'النقل']
        if not all((keyword in list_content_string for keyword in keywords)):
            return False
        for content in numbered_lines_content:
            if len(content.split()) < 3:
                return False
        return True



class DataIdx92InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_92')

    def check_following(self, value):
        """Checks if the response has exactly 7 words.
        Args:
            value: A string representing the response.

        Returns:
            True if the response has exactly 7 words, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        return len(words) == 7



class DataIdx93InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_93')

    def check_following(self, value):
        """Checks if the response is an Arabic sentence containing the word 'شمس'.
        Grammatical correctness is not programmatically checked here due to complexity.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains the word 'شمس', False otherwise.
        """
        if not isinstance(value, str):
            return False
        return 'شمس' in value



class DataIdx94InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_94')

    def check_following(self, value):
        """Checks if the summarized text does not exceed half the length of the original text.
        Args:
            value: A string representing the summarized text (the response).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        original_text = 'تعتبر الحضارة الإسلامية من أغنى الحضارات التي عرفها التاريخ الإنساني، حيث قدمت إسهامات جليلة في مختلف مجالات العلم والمعرفة، من الطب والفلك والرياضيات إلى الفلسفة والأدب والفنون. وقد امتد تأثير هذه الحضارة عبر قرون طويلة ليشمل مناطق واسعة من العالم، ويترك بصمات واضحة على الثقافات المختلفة.'
        original_length = len(original_text)
        summarized_length = len(value)
        return summarized_length <= original_length / 2



class DataIdx95InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_95')

    def check_following(self, value):
        """
        Checks if the response explains AI in three bullet points, with each point
        not exceeding 15 words.

        Args:
            value: A string representing the response, expected to contain the points
                   separated by newlines or bullet markers.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        points = [line.strip() for line in value.strip().split('\n') if line.strip()]
        if len(points) != 3:
            return False
        for point in points:
            words = point.split()
            if len(words) > 15:
                return False
        return True



class DataIdx96InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_96')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 96.

        Args:
            value: A string representing the response (Arabic text).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.strip().split('\n')
        pros_heading_idx = -1
        cons_heading_idx = -1
        for i, line in enumerate(lines):
            cleaned_line = line.strip()
            if 'إيجابيات' in cleaned_line:
                pros_heading_idx = i
            elif 'سلبيات' in cleaned_line:
                cons_heading_idx = i
        if pros_heading_idx == -1 or cons_heading_idx == -1 or pros_heading_idx >= cons_heading_idx:
            return False

        def is_list_item(line):
            cleaned = line.strip()
            if not cleaned:
                return False
            if cleaned.startswith('-') or cleaned.startswith('*') or cleaned.startswith('+'):
                return True
            j = 0
            while j < len(cleaned) and cleaned[j].isdigit():
                j += 1
            if j > 0 and j < len(cleaned) and (cleaned[j] == '.' or cleaned[j] == ')'):
                if cleaned[j + 1:].strip():
                    return True
            return False

        def check_item_plural(line):
            cleaned = line.strip()
            markers = ['-', '*', '+']
            removed_marker = False
            for marker in markers:
                if cleaned.startswith(marker):
                    cleaned = cleaned[len(marker):].lstrip()
                    removed_marker = True
                    break
            if not removed_marker:
                j = 0
                while j < len(cleaned) and cleaned[j].isdigit():
                    j += 1
                if j > 0 and j < len(cleaned) and (cleaned[j] in ['.', ')']):
                    cleaned = cleaned[j + 1:].lstrip()
            while cleaned and cleaned[-1] in '.,!?;:':
                cleaned = cleaned[:-1]
            cleaned = cleaned.strip()
            if cleaned.endswith('ون') or cleaned.endswith('ين') or cleaned.endswith('ات'):
                return True
            words = cleaned.split()
            if words:
                last_word = words[-1]
                if last_word.endswith('ون') or last_word.endswith('ين') or last_word.endswith('ات'):
                    return True
            return False
        pros_count = 0
        cons_count = 0
        all_plural = True
        found_list_items_count = 0
        for i in range(pros_heading_idx + 1, cons_heading_idx):
            if is_list_item(lines[i]):
                pros_count += 1
                found_list_items_count += 1
                if not check_item_plural(lines[i]):
                    all_plural = False
        for i in range(cons_heading_idx + 1, len(lines)):
            if is_list_item(lines[i]):
                cons_count += 1
                found_list_items_count += 1
                if not check_item_plural(lines[i]):
                    all_plural = False
        if found_list_items_count == 0:
            return False
        return pros_count >= 3 and cons_count >= 3 and all_plural



class DataIdx97InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_97')

    def check_following(self, value):
        """Checks if the response is a paragraph of at least 50 words
           and contains the word 'التعليم' at least 3 times.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count < 50:
            return False
        education_count = sum((1 for word in words if word == 'التعليم'))
        if education_count < 3:
            return False
        return True



class DataIdx98InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_98')

    def check_following(self, value):
        """Checks if the response is a single sentence containing the Arabic vowels أ, و, and ي.

        Args:
            value: A string representing the response (the sentence).

        Returns:
            True if the response contains all the required vowels, False otherwise.
        """
        has_alif = 'أ' in value
        has_waw = 'و' in value
        has_ya = 'ي' in value
        return has_alif and has_waw and has_ya



class DataIdx99InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_99')

    def check_following(self, value):
        """Checks if the response is a bulleted list in Arabic with exactly three examples,
        each having a brief explanation.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        arabic_chars_present = any(('\u0600' <= char <= 'ۿ' for char in value))
        if not arabic_chars_present:
            return False
        lines = value.strip().split('\n')
        non_empty_lines = [line.strip() for line in lines if line.strip()]
        bullet_chars = ['-', '*', '+', '•']
        potential_bullet_lines = []
        for line in non_empty_lines:
            is_bulleted = False
            for bullet in bullet_chars:
                if line.startswith(bullet):
                    content_after_bullet = line[len(bullet):].strip()
                    if len(content_after_bullet) > 0:
                        potential_bullet_lines.append(line)
                        is_bulleted = True
                        break
        if len(potential_bullet_lines) != 3:
            return False
        return True



class DataIdx100InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_100')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 100.
        Instructions:
        1. Must mention the word 'هدية' at least three times.
        2. Word count must be between 85 and 115 words (inclusive).

        Args:
            value: A string representing the response (Arabic advertisement text).

        Returns:
            True if the response follows all instructions, False otherwise.
        """
        keyword = 'هدية'
        keyword_count = value.count(keyword)
        keyword_constraint_met = keyword_count >= 3
        words = value.split()
        word_count = len(words)
        word_count_constraint_met = 85 <= word_count <= 115
        return keyword_constraint_met and word_count_constraint_met



class DataIdx101InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_101')

    def check_following(self, value):
        """Checks if the response is a short dialogue about reading importance,
        uses exclamation marks at least twice, and includes a question starting
        with 'هل تعتقد...؟'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instructions, False otherwise.
        """
        if not isinstance(value, str):
            return False
        exclamation_count = value.count('!')
        if exclamation_count < 2:
            return False
        required_phrase = 'هل تعتقد...؟'
        if required_phrase not in value:
            return False
        return True



class DataIdx102InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_102')

    def check_following(self, value):
        """Checks if the response consists of exactly two sentences.
        Args:
            value: A string representing the response.

        Returns:
            True if the response has exactly two sentences (based on punctuation), False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentences = re.split('[.!?]+', value)
        sentences = [s.strip() for s in sentences if s.strip()]
        return len(sentences) == 2



class DataIdx103InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_103')

    def check_following(self, value):
        """Checks if the response follows the instructions for question IDX 103.
        Constraints:
        - Mentions a famous scholar from the Islamic Golden Age.
        - Uses quotation marks for a famous saying.

        Args:
            value: A string representing the response (the song lyrics).

        Returns:
            True if the response follows the constraints, False otherwise.
        """
        if not isinstance(value, str) or not value:
            return False
        famous_scholars = ['ابن سينا', 'الخوارزمي', 'الرازي', 'ابن خلدون', 'الغزالي', 'ابن رشد', 'الفارابي', 'ابن الهيثم', 'جابر بن حيان', 'البتاني', 'الزهراوي', 'ابن النفيس']
        value_lower = value.lower()
        name_found = False
        for name in famous_scholars:
            if name.lower() in value_lower:
                name_found = True
                break
        quotes_found = '"' in value or "'" in value
        return name_found and quotes_found



class DataIdx104InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_104')

    def check_following(self, value):
        """Checks if the response contains the word 'سكر' at least five times.

        Args:
            value: A string representing the response.

        Returns:
            True if the word 'سكر' appears 5 or more times, False otherwise.
        """
        count = value.count('سكر')
        return count >= 5



class DataIdx105InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_105')

    def check_following(self, value):
        """Checks if the response contains exactly two unique names enclosed in parentheses.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction, False otherwise.
        """
        names_in_parentheses = re.findall('\\((.*?)\\)', value)
        unique_names = set(names_in_parentheses)
        return len(unique_names) == 2



class DataIdx106InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_106')

    def check_following(self, value):
        """Checks if the response summarizes the plot of 'The Lord of the Rings'
        in less than 150 words and emphasizes at least 5 character names by
        making them uppercase.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count >= 150:
            return False
        uppercase_count = 0
        for word in words:
            cleaned_word = word.strip('.,!?;:()"\'-')
            if cleaned_word.isupper() and len(cleaned_word) > 1:
                uppercase_count += 1
        if uppercase_count < 5:
            return False
        return True



class DataIdx107InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_107')

    def check_following(self, value):
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        found_list_items_count = 0
        expected_num = 1
        for line in lines:
            stripped_line = line.strip()
            if not stripped_line:
                continue
            if expected_num <= 3 and stripped_line.startswith(f'{expected_num}.'):
                found_list_items_count += 1
                expected_num += 1
            elif re.match('^\\s*\\d+\\.', stripped_line):
                return False
        return found_list_items_count == 3



class DataIdx108InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_108')

    def check_following(self, value):
        """Checks if the response is a single sentence about the importance of reading
           containing exactly seven words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.strip().split()
        if len(words) == 7:
            return True
        else:
            return False



class DataIdx109InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_109')

    def check_following(self, value):
        """Checks if the response is an Arabic interrogative sentence starting with 'هل'
           about the Sun/Earth orbit, phrased such that the answer is 'لا'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value.endswith('?'):
            return False
        if not cleaned_value.startswith('هل'):
            return False
        if 'الشمس' not in cleaned_value:
            return False
        if 'الأرض' not in cleaned_value:
            return False
        if 'تدور' not in cleaned_value and 'يدور' not in cleaned_value:
            return False
        if 'حول' not in cleaned_value:
            return False
        if 'الشمس حول الأرض' not in cleaned_value:
            return False
        return True



class DataIdx110InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_110')

    def check_following(self, value):
        """Checks if the response includes the word 'كبير' and the word 'صغير' in the same sentence.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        word1 = 'كبير'
        word2 = 'صغير'
        sentences = re.split('[.!?]', value)
        for sentence in sentences:
            sentence = sentence.strip()
            if not sentence:
                continue
            if word1 in sentence and word2 in sentence:
                return True
        return False



class DataIdx111InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_111')

    def check_following(self, value):
        """Checks if the response is a list of 5 items, each starting with a potential present tense verb prefix."""
        lines = value.strip().split('\n')
        non_empty_lines = [line.strip() for line in lines if line.strip()]
        if len(non_empty_lines) != 5:
            return False
        present_prefixes = ['أ', 'ن', 'ي', 'ت']
        for line in non_empty_lines:
            words = line.split()
            if not words:
                return False
            first_word = words[0]
            if not first_word or first_word[0] not in present_prefixes:
                return False
        return True



class DataIdx112InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_112')

    def check_following(self, value):
        """Checks if the response completes the proverb correctly.
        Args:
            value: A string representing the response.

        Returns:
            True if the response is the correct completion, False otherwise.
        """
        correct_completion = 'قوة'
        cleaned_value = value.strip()
        return cleaned_value == correct_completion



class DataIdx113InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_113')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 113.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        uses_sorry = 'آسف' in value
        uses_separator = '_' in value
        justification_phrases = ['لأن', 'لكن', 'إلا أن', 'السبب هو', 'كان علي ان', 'كان علي أن', 'لم أقصد']
        has_justification = any((phrase in value for phrase in justification_phrases))
        ends_correctly = value.strip().endswith('صديقك المخلص.')
        return uses_sorry and uses_separator and (not has_justification) and ends_correctly



class DataIdx114InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_114')

    def check_following(self, value):
        """
        Checks if the response is an Arabic sentence about the environmental impact
        of public transportation that includes the word "بيئة".
        Due to limitations, we primarily check for non-emptiness, presence of
        Arabic characters, and inclusion of the word "بيئة".

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        if 'بيئة' not in value:
            return False
        has_arabic_chars = False
        for char in value:
            if '\u0600' <= char <= 'ۿ':
                has_arabic_chars = True
                break
        if not has_arabic_chars:
            return False
        return True



class DataIdx115InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_115')

    def check_following(self, value):
        """Checks if the response is a short paragraph (<= 3 lines) and uses the word 'الماء' at least 3 times.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        non_empty_lines = [line for line in lines if line.strip()]
        line_count_ok = len(non_empty_lines) <= 3
        word_to_count = 'الماء'
        word_count = value.count(word_to_count)
        word_count_ok = word_count >= 3
        return line_count_ok and word_count_ok



class DataIdx116InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_116')

    def check_following(self, value):
        """Checks if the response is a five-verse poem where each verse starts with 'في'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        verses = value.strip().splitlines()
        non_empty_verses = [verse.strip() for verse in verses if verse.strip()]
        if len(non_empty_verses) != 5:
            return False
        for verse in non_empty_verses:
            if not verse.startswith('في'):
                return False
        return True



class DataIdx117InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_117')

    def check_following(self, value):
        """Checks if the response contains only question marks.

        Args:
            value: A string representing the response.

        Returns:
            True if the response consists solely of question mark characters,
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        return all((c == '?' for c in value))



class DataIdx118InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_118')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 118.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count < 40:
            return False
        forbidden_word = 'شعور'
        normalized_words = []
        punctuation_to_strip = '.,!?;:()«»'
        for word in words:
            normalized_word = word.strip(punctuation_to_strip)
            normalized_words.append(normalized_word)
        if forbidden_word in normalized_words:
            return False
        return True



class DataIdx119InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_119')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 119.
        Instructions:
        - Answer must be in three paragraphs.
        - Paragraphs must be separated by '---'.
        - Must use the keywords: 'نشاط', 'صحة', 'سعادة'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        paragraphs = value.split('---')
        if len(paragraphs) != 3:
            return False
        required_keywords = ['نشاط', 'صحة', 'سعادة']
        for keyword in required_keywords:
            if keyword not in value:
                return False
        return True



class DataIdx120InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_120')

    def check_following(self, value):
        """Checks if the response follows the constraints for IDX 120.
        Constraints:
        1. Mention five types of water activities in points.
        2. Do NOT use the word 'رياضة'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        forbidden_word = 'رياضة'
        if forbidden_word in value:
            return False
        lines = value.split('\n')
        non_empty_lines_count = 0
        for line in lines:
            if line.strip():
                non_empty_lines_count += 1
        if non_empty_lines_count != 5:
            return False
        return True



class DataIdx121InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_121')

    def check_following(self, value):
        """Checks if the response is a question about the future of renewable energy, starting with "ماذا لو...".

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        starts_with_what_if = value.strip().startswith('ماذا لو...')
        ends_with_question_mark = value.strip().endswith('؟')
        return starts_with_what_if and ends_with_question_mark



class DataIdx122InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_122')

    def check_following(self, value):
        """Checks if the response mentions a university major/studying and includes a four-digit year.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        value = value.strip()
        if not value:
            return False
        found_year = False
        for i in range(len(value) - 3):
            substring = value[i:i + 4]
            if substring.isdigit():
                is_isolated = (i == 0 or not value[i - 1].isdigit()) and (i + 4 == len(value) or not value[i + 4].isdigit())
                if is_isolated:
                    found_year = True
                    break
                found_year = True
                break
        if not found_year:
            return False
        found_major_mention = False
        if 'تخصص' in value or 'أدرس' in value:
            found_major_mention = True
        if not found_major_mention:
            return False
        return True



class DataIdx123InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_123')

    def check_following(self, value: str) -> bool:
        """
        Checks if the response is a single Arabic sentence about education's importance,
        contains 'المعرفة' at least once, and contains no exclamation marks.
        """
        if not isinstance(value, str):
            return False
        if '!' in value:
            return False
        if 'المعرفة' not in value:
            return False
        cleaned_value = value.strip()
        if not cleaned_value.endswith('.'):
            return False
        last_period_index = cleaned_value.rfind('.')
        if '.' in cleaned_value[:last_period_index]:
            return False
        return True



class DataIdx124InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_124')

    def check_following(self, value):
        """Checks if the response describes a famous teacher in exactly four sentences, including the teacher's name.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentences = re.split('[.!?]', value)
        sentences = [s.strip() for s in sentences if s.strip()]
        if len(sentences) != 4:
            return False
        name_pattern = re.compile('\\b(?:اسمه|اسمها|يدعى|المعلم|الأستاذ)\\s+\\S+')
        if not name_pattern.search(value):
            return False
        return True



class DataIdx125InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_125')

    def check_following(self, value):
        """Checks if the response represents a simple organizational chart
        using punctuation for a medium-sized company from CEO to employees.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.strip().split('\n')
        if len(lines) < 3:
            return False
        text = value
        ceo_patterns = ['\\bالرئيس التنفيذي\\b', '\\bالمدير العام\\b', '\\bالرئيس\\b']
        employee_pattern = '\\bالموظفين\\b'
        intermediate_pattern = '\\b(قسم|إدارة|مدير|رئيس|رؤساء|مدراء)\\b'
        has_ceo = any((re.search(pattern, text) for pattern in ceo_patterns))
        if not has_ceo:
            return False
        if not re.search(employee_pattern, text):
            return False
        if not re.search(intermediate_pattern, text):
            return False
        has_visual_structure = False
        structural_chars_pattern = '[-+*|>#:\\u2022]'
        for line in lines:
            stripped_line = line.lstrip()
            if len(line) > len(stripped_line):
                has_visual_structure = True
                break
            if re.search(structural_chars_pattern, stripped_line):
                has_visual_structure = True
                break
        if not has_visual_structure:
            return False
        ceo_line_indices = [i for i, line in enumerate(lines) if any((re.search(pattern, line) for pattern in ceo_patterns))]
        employee_line_indices = [i for i, line in enumerate(lines) if re.search(employee_pattern, line)]
        if not ceo_line_indices or not employee_line_indices:
            return False
        first_ceo_line_index = min(ceo_line_indices)
        last_employee_line_index = max(employee_line_indices)
        if first_ceo_line_index > last_employee_line_index:
            return False
        return True



class DataIdx126InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_126')

    def check_following(self, value):
        """Checks if the response is a news report about an archaeological discovery including a quote from an archaeologist.
        This check looks for the presence of common quotation marks and the phrase 'عالم آثار'.

        Args:
            value: A string representing the response (expected in Arabic).

        Returns:
            True if the text contains both quotation marks/guillemets and the phrase 'عالم آثار', False otherwise.
        """
        if not isinstance(value, str):
            return False
        has_quote_chars = any((q in value for q in ['«', '»', '"', "'", '،', ',']))
        mentions_archaeologist = 'عالم آثار' in value
        return has_quote_chars and mentions_archaeologist



class DataIdx127InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_127')

    def check_following(self, value):
        """Checks if the response is a single Arabic sentence encouraging tolerance and rejecting fanaticism.
           Note: Semantic checks (tolerance/fanaticism) are not feasible with basic string analysis.
           This checker focuses on feasible structural and basic language constraints:
           1. The value is a string.
           2. Contains at least one character within the Arabic Unicode range U+0600-06FF.
           3. Contains exactly one sentence-ending punctuation mark (., !, ?).
        Args:
            value: A string representing the response.

        Returns:
            True if the response meets the feasible structural constraints, False otherwise.
        """
        if not isinstance(value, str):
            return False
        value = value.strip()
        if not value:
            return False
        has_arabic_char = False
        for char in value:
            if '\u0600' <= char <= 'ۿ':
                has_arabic_char = True
                break
        if not has_arabic_char:
            return False
        sentence_enders = ['.', '!', '?']
        punctuation_count = sum((value.count(end) for end in sentence_enders))
        is_single_sentence = punctuation_count == 1
        return is_single_sentence



class DataIdx128InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_128')

    def check_following(self, value):
        """Checks if the value is a string containing exactly two words.

        Args:
            value: A string representing the response.

        Returns:
            True if the string contains exactly two words, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = [word for word in value.split() if word]
        return len(words) == 2



class DataIdx129InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_129')

    def check_following(self, value):
        """Checks if the response mentions three reasons for reading being beneficial
           for youth, uses the word 'المعرفة' at least once, and is in a bulleted list format.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instructions, False otherwise.
        """
        uses_knowledge_word = 'المعرفة' in value
        lines = value.strip().split('\n')
        list_items_count = 0
        for line in lines:
            stripped_line = line.strip()
            is_list_item = False
            if stripped_line.startswith('-') or stripped_line.startswith('*') or stripped_line.startswith('•'):
                if len(stripped_line) > 1 and stripped_line[1:].strip():
                    is_list_item = True
            dot_index = stripped_line.find('.')
            if dot_index > 0:
                prefix = stripped_line[:dot_index]
                if prefix.isdigit():
                    if stripped_line[dot_index + 1:].strip():
                        is_list_item = True
            if is_list_item:
                list_items_count += 1
        return uses_knowledge_word and list_items_count >= 3



class DataIdx130InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_130')

    def check_following(self, value):
        """Checks if the response contains the required word 'صحة'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response contains 'صحة', or False otherwise.
        """
        if not isinstance(value, str):
            return False
        required_word = 'صحة'
        return required_word in value



class DataIdx131InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_131')

    def check_following(self, value):
        """Checks if the response lists exactly three sports in alphabetical order."""
        if not isinstance(value, str):
            return False
        items = re.split('[,\\n؛.]', value)
        cleaned_sports = []
        for item in items:
            cleaned_item = item.strip()
            cleaned_item = re.sub('^\\s*[\\d\\*\\-]+\\s*\\.?\\s*', '', cleaned_item)
            cleaned_item = cleaned_item.strip()
            if cleaned_item:
                cleaned_sports.append(cleaned_item)
        if len(cleaned_sports) != 3:
            return False
        if cleaned_sports != sorted(cleaned_sports):
            return False
        return True



class DataIdx132InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_132')

    def check_following(self, value):
        """Checks if the response is a single paragraph containing three different Arabic numbers written out.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if '\n\n' in cleaned_value:
            return False
        arabic_numbers = {'واحد', 'اثنان', 'ثلاثة', 'أربعة', 'خمسة', 'ستة', 'سبعة', 'ثمانية', 'تسعة', 'عشرة', 'مئة', 'ألف', 'مليون', 'مليار', 'اثنتان', 'مئتان', 'ألفان', 'مليونان', 'ملياران', 'عشرون', 'ثلاثون', 'أربعون', 'خمسون', 'ستون', 'سبعون', 'ثمانون', 'تسعون'}
        pattern = '\\b(?:' + '|'.join((re.escape(num) for num in arabic_numbers)) + ')\\b'
        matches = re.findall(pattern, cleaned_value, re.IGNORECASE)
        found_numbers = set((match.lower() for match in matches))
        if len(found_numbers) < 3:
            return False
        return True



class DataIdx133InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_133')

    def check_following(self, value):
        """Checks if the response is brief, in JSON format, and within length constraints.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        min_len = 20
        max_len = 1000
        if not min_len <= len(value) <= max_len:
            return False
        try:
            json.loads(value)
            return True
        except json.JSONDecodeError:
            return False
        except TypeError:
            return False



class DataIdx134InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_134')

    def check_following(self, value):
        """Checks if the response is a single sentence starting with 'ما رأيك' and ending with '?'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        starts_with_phrase = value.strip().startswith('ما رأيك')
        ends_with_question_mark = value.strip().endswith('?')
        return starts_with_phrase and ends_with_question_mark



class DataIdx135InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_135')

    def check_following(self, value):
        """Checks if the response uses two different past tense verbs, based on a heuristic.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        common_past_tense_forms_no_diacritics = {'كتبت', 'كتب', 'كتبت', 'كتبنا', 'كتبوا', 'ذهبت', 'ذهب', 'ذهبت', 'ذهبنا', 'ذهبوا', 'أكلت', 'أكل', 'أكلت', 'أكلنا', 'أكلوا', 'نمت', 'نام', 'نامت', 'نمنا', 'ناموا', 'قمت', 'قام', 'قامت', 'قمنا', 'قاموا', 'رأيت', 'رأى', 'رأت', 'رأينا', 'رأوا', 'سمعت', 'سمع', 'سمعت', 'سمعنا', 'سمعوا', 'شعرت', 'شعر', 'شعرت', 'شعرنا', 'شعروا', 'عملت', 'عمل', 'عملت', 'عملنا', 'عملوا', 'درست', 'درس', 'درست', 'درسنا', 'درسوا', 'استيقظت', 'استيقظ', 'استيقظت', 'استيقظنا', 'استيقظوا', 'شاهدت', 'شاهد', 'شاهدت', 'شاهدنا', 'شاهدوا', 'قابلت', 'قابل', 'قابلت', 'قابلنا', 'قابلوا', 'كتبت', 'كتبت', 'كتبتما', 'كتبتم', 'كتبتن', 'ذهبت', 'ذهبت', 'ذهبتما', 'ذهبتم', 'ذهبتن', 'أكلت', 'أكلت', 'أكلتما', 'أكلتم', 'أكلتن', 'نمت', 'نمت', 'نمتما', 'نمتم', 'نمتن', 'قمت', 'قمت', 'قمتما', 'قمتم', 'قمتن', 'رأيت', 'رأيت', 'رأيتما', 'رأيتم', 'رأيتن', 'سمعت', 'سمعت', 'سمعتما', 'سمعتم', 'سمعتن', 'شعرت', 'شعرت', 'شعرتما', 'شعرتم', 'شعرتن', 'عملت', 'عملت', 'عملتما', 'عملتم', 'عملتن', 'درست', 'درست', 'درستما', 'درستم', 'درستن', 'استيقظت', 'استيقظت', 'استيقظتما', 'استيقظتم', 'استيقظتن', 'شاهدت', 'شاهدت', 'شاهدتما', 'شاهدتم', 'شاهدتن', 'قابلت', 'قابلت', 'قابلتما', 'قابلتم', 'قابلتن', 'كتبا', 'كتبتا', 'ذهبا', 'ذهبتا', 'أكلا', 'أكلتا', 'ناما', 'نامتا', 'قاما', 'قامتا', 'رأيا', 'رأتا', 'سمعا', 'سمعتا', 'شعرا', 'شعرتا', 'عملا', 'عملتا', 'درسا', 'درستا', 'استيقظا', 'استيقظتا', 'شاهدا', 'شاهدتا', 'قابلا', 'قابلتا'}
        common_past_tense_forms_set = set(common_past_tense_forms_no_diacritics)
        punctuation_chars = set('!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~«»‘’“”')
        punctuation_chars.add('‐')
        punctuation_chars.add('‑')
        punctuation_chars.add('‒')
        punctuation_chars.add('–')
        punctuation_chars.add('—')
        punctuation_chars.add('―')
        diacritic_chars = set('ًٌٍَُِّْٕٓٔ')
        diacritic_chars.update('ۣ۪ۭۖۗۘۙۚۛۜ۟۠ۡۢۤۧۨ۫۬')
        tatweel = 'ـ'
        chars_to_remove = punctuation_chars.union(diacritic_chars)
        chars_to_remove.add(tatweel)
        chars_to_remove.add('\u200c')
        chars_to_remove.add('\u200d')
        cleaned_value = ''
        for char in value:
            if char in chars_to_remove:
                continue
            cleaned_value += char
        words = cleaned_value.split()
        identified_past_verbs = set()
        for word in words:
            if word in common_past_tense_forms_set:
                identified_past_verbs.add(word)
        return len(identified_past_verbs) >= 2



class DataIdx136InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_136')

    def check_following(self, value):
        """Checks if the Arabic paragraph follows the instruction: every sentence starts with 'أنا'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        sentences = re.split('[\\.\\!\\?]', value)
        valid_sentence_found = False
        for sentence in sentences:
            stripped_sentence = sentence.strip()
            if not stripped_sentence:
                continue
            if not stripped_sentence.startswith('أنا'):
                return False
            valid_sentence_found = True
        return valid_sentence_found



class DataIdx137InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_137')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 137.
        Instructions: Describe a famous historical landmark, underline its name (using underscores),
                      and mention 'تاريخ' at least three times.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        underlined_present = False
        underscore_indices = [i for i, char in enumerate(value) if char == '_']
        if len(underscore_indices) >= 2:
            for i in range(len(underscore_indices) - 1):
                if underscore_indices[i + 1] > underscore_indices[i] + 1:
                    underlined_present = True
                    break
        history_count = value.count('تاريخ')
        return underlined_present and history_count >= 3



class DataIdx138InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_138')

    def check_following(self, value):
        """Checks if the response is an Arabic recipe including ingredients and steps.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        arabic_word_count = len(re.findall('\\b[\\u0600-\\u06FF]+\\b', value))
        if arabic_word_count < 20:
            return False
        ingredients_present = re.search('المكونات|المقادير', value) is not None
        steps_present = re.search('خطوات\\s*التحضير|طريقة\\s*التحضير|طريقة\\s*العمل', value) is not None
        return ingredients_present and steps_present



class DataIdx139InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_139')

    def check_following(self, value):
        """Checks if the response is an Arabic sentence using exactly three different relative pronouns.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains exactly three different relative pronouns (based on distinct word forms from a defined set),
            False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        relative_pronoun_forms = {'الذي', 'التي', 'اللذان', 'اللذين', 'اللتان', 'اللتين', 'الذين', 'اللاتي', 'اللائي', 'اللواتي', 'من', 'ما'}
        words = value.split()
        found_forms = set()
        for word in words:
            cleaned_word = word.strip('.,!?;:()"\'[]{}«»')
            if cleaned_word.startswith('و'):
                cleaned_word_without_wa = cleaned_word[1:]
                if cleaned_word_without_wa in relative_pronoun_forms:
                    found_forms.add(cleaned_word_without_wa)
            elif cleaned_word in relative_pronoun_forms:
                found_forms.add(cleaned_word)
        return len(found_forms) == 3



class DataIdx140InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_140')

    def check_following(self, value):
        """Checks if the response lists five benefits and includes the word 'المعرفة'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        has_knowledge_word = 'المعرفة' in value
        if not has_knowledge_word:
            return False
        lines = [line.strip() for line in value.split('\n') if line.strip()]
        line_count = len(lines)
        if line_count >= 5:
            return True
        segments_by_sentence_end = [s.strip() for s in re.split('[.!?]\\s*', value) if s.strip()]
        sentence_segment_count = len(segments_by_sentence_end)
        if sentence_segment_count >= 5:
            return True
        return False



class DataIdx141InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_141')

    def check_following(self, value):
        """Checks if the response lists the four seasons in Arabic using a non-numbered bullet list (markdown)
           and if all words are in 'lowercase' (standard Arabic script).
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        bullet_lines = []
        for line in lines:
            trimmed_line = line.strip()
            if trimmed_line.startswith(('- ', '* ', '+ ')):
                bullet_lines.append(trimmed_line)
        if len(bullet_lines) != 4:
            return False
        expected_seasons = {'الربيع', 'الصيف', 'الخريف', 'الشتاء'}
        actual_seasons = set()
        for bullet_line in bullet_lines:
            content = bullet_line[2:].strip()
            actual_seasons.add(content)
        if actual_seasons != expected_seasons:
            return False
        return True



class DataIdx142InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_142')

    def check_following(self, value):
        """
        Checks if the response lists five essential elements of effective communication
        in a numbered list, with each point starting with the word 'الاستماع'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.strip().split('\n')
        non_empty_lines = [line for line in lines if line.strip()]
        numbered_items = []
        expected_number = 1
        for line in non_empty_lines:
            stripped_line = line.strip()
            prefix = f'{expected_number}.'
            if stripped_line.startswith(prefix):
                content_start_index = len(prefix)
                while content_start_index < len(stripped_line) and stripped_line[content_start_index].isspace():
                    content_start_index += 1
                content = stripped_line[content_start_index:]
                if content.startswith('الاستماع'):
                    numbered_items.append(content)
                    expected_number += 1
                else:
                    return False
            elif stripped_line and (not stripped_line.startswith(f'{expected_number}.')):
                return False
        return len(numbered_items) == 5



class DataIdx143InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_143')

    def check_following(self, value):
        """Checks if the response is enclosed in <<>> and contains a single sentence.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if not (value.strip().startswith('<<') and value.strip().endswith('>>')):
            return False
        start_idx = value.find('<<')
        end_idx = value.rfind('>>')
        if start_idx == -1 or end_idx == -1 or end_idx < start_idx + 2:
            return False
        content = value[start_idx + 2:end_idx].strip()
        if not content:
            return False
        sentence_enders = ['.', '?', '!']
        punc_count = sum((content.count(punc) for punc in sentence_enders))
        if punc_count == 1:
            last_char_is_punc = False
            for punc in sentence_enders:
                if content.endswith(punc):
                    last_char_is_punc = True
                    break
            return last_char_is_punc
        else:
            return False



class DataIdx144InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_144')

    def check_following(self, value):
        """Checks if the response follows the instruction.
        The response must be a paragraph explaining 'Transformational Leadership'
        and must not exceed 70 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        if len(words) <= 70:
            return True
        else:
            return False



class DataIdx145InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_145')

    def check_following(self, value):
        """Checks if the response does not contain a semicolon.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain a semicolon, False otherwise.
        """
        if ';' in value:
            return False
        return True



class DataIdx146InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_146')

    def check_following(self, value):
        """Checks if the response is a list of four lines mentioning the four seasons in order, starting with Spring.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        expected_seasons = ['الربيع', 'الصيف', 'الخريف', 'الشتاء']
        lines = value.strip().splitlines()
        if len(lines) != 4:
            return False
        for i in range(4):
            if lines[i].strip() != expected_seasons[i]:
                return False
        return True



class DataIdx147InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_147')

    def check_following(self, value):
        """Checks if the response is Arabic instructions for tea using primarily only imperative verbs (heuristic check).
        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if no detectable non-imperative forms are found, False otherwise.
        """
        definite_non_imperative_particles = {'سوف', 'قد', 'لم', 'لن'}
        potential_present_prefixes_for_heuristic = ('ي', 'ت', 'ن')
        common_non_verbs_starting_with_ytn = {'تحت', 'ثم', 'تمام', 'تحضير', 'تجهيز', 'يوم', 'يد', 'يا', 'يمين', 'يسار', 'نعم', 'نحن', 'نحو', 'نوع'}
        words = re.findall('\\b[\\u0600-\\u06FF]+\\b', value)
        for word in words:
            if word in definite_non_imperative_particles:
                return False
            if word.startswith('س') and len(word) > 1:
                return False
            if word.startswith(potential_present_prefixes_for_heuristic):
                if word not in common_non_verbs_starting_with_ytn and len(word) > 2:
                    return False
        return True



class DataIdx148InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_148')
        self.forbidden_tokens = {'في', 'على', 'إلى', 'من', 'عن', 'حتى', 'مذ', 'منذ', 'خلا', 'عدا', 'حاشا', 'كأن', 'لعل', 'لكن', 'ليت', 'أن', 'إن', 'إلا', 'بل', 'لا', 'لم', 'لن', 'ما', 'هل', 'أ', 'يا', 'و', 'ف', 'ثم', 'أو', 'أم'}

    def check_following(self, value):
        """Checks if the response string appears to contain only Arabic nouns and verbs
           by checking for the absence of common non-noun/verb tokens.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction (i.e., contains no common
            non-noun/verb tokens), False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        words = value.split()
        for word in words:
            cleaned_word = word.strip('.,!?;:')
            if cleaned_word in self.forbidden_tokens:
                return False
        return True



class DataIdx149InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_149')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 149.

        Instructions:
        - Brief description of a historical medieval city.
        - Must be a bulleted list.
        - Exactly five points.
        - Use the word 'قلعة' (castle) at least twice.
        - Each point does not exceed ten words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        points = [line.strip() for line in value.splitlines() if line.strip()]
        if len(points) != 5:
            return False
        for point in points:
            words = re.findall('[\\w-]+', point)
            words = [word for word in words if word]
            if len(words) > 10:
                return False
        cleaned_value = re.sub('[^\\w\\s]+', ' ', value)
        all_words = cleaned_value.split()
        all_words = [word for word in all_words if word]
        castle_count = all_words.count('قلعة')
        if castle_count < 2:
            return False
        return True



class DataIdx150InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_150')

    def check_following(self, value):
        """Checks if the response is a list of 5 items (numbered or bulleted)
           and at least 3 of these items contain the substring 'علم'."""
        if not isinstance(value, str):
            return False
        numbered_pattern = '(?:^|\\n)\\s*\\d+\\.\\s*(.*?)(?=\\n*\\s*\\d+\\.\\s*|$|\\Z)'
        bulleted_pattern = '(?:^|\\n)\\s*[-*+]\\s*(.*?)(?=\\n*\\s*[-*+]\\s*|$|\\Z)'
        items = []
        items = re.findall(numbered_pattern, value.strip(), re.DOTALL | re.MULTILINE)
        if len(items) != 5:
            items = re.findall(bulleted_pattern, value.strip(), re.DOTALL | re.MULTILINE)
        items = [item.strip() for item in items]
        items = [item for item in items if item]
        if len(items) != 5:
            return False
        count_with_elm = 0
        for item in items:
            if item.find('علم') != -1:
                count_with_elm += 1
        return count_with_elm >= 3



class DataIdx151InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_151')

    def check_following(self, value):
        """Checks if the response is a single paragraph about the solar system,
        includes the names of the eight planets, and uses correct paragraph separation (implies no double newlines within a single paragraph).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        trimmed_value = value.strip()
        if '\n\n' in trimmed_value:
            return False
        planet_names = ['عطارد', 'الزهرة', 'الأرض', 'المريخ', 'المشتري', 'زحل', 'أورانوس', 'نبتون']
        all_planets_present = True
        for planet in planet_names:
            if planet not in trimmed_value:
                all_planets_present = False
                break
        return all_planets_present



class DataIdx152InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_152')

    def check_following(self, value):
        """Checks if the response (dialogue) contains 'وادي رم' at least twice.

        Args:
            value: A string representing the response (the dialogue).

        Returns:
            True if 'وادي رم' appears two or more times, False otherwise.
        """
        target_phrase = 'وادي رم'
        count = value.count(target_phrase)
        return count >= 2



class DataIdx153InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('153')

    def check_following(self, value):
        """Checks if the response is written as a single paragraph.

        A response is considered a single paragraph if it does not contain two
        or more consecutive newline characters (handling both \\n and \\r\\n).

        Args:
            value: A string representing the response text.

        Returns:
            True if the response contains no standard paragraph breaks, False otherwise.
        """
        if not isinstance(value, str):
            return False
        if re.search('(\\r?\\n){2,}', value):
            return False
        return True



class DataIdx154InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_154')

    def check_following(self, value):
        """Checks if the response is a formal graduation invitation that includes date, time, location, and starts with 'تتشرف'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        response = value.strip()
        starts_with_tattasharraf = response.startswith('تتشرف')
        date_keywords = ['التاريخ', 'بتاريخ', 'يوم']
        includes_date = any((keyword in response for keyword in date_keywords))
        time_keywords = ['الوقت', 'الساعة']
        includes_time = any((keyword in response for keyword in time_keywords))
        location_keywords = ['المكان', 'قاعة', 'فندق', 'في']
        includes_location = any((keyword in response for keyword in location_keywords))
        return starts_with_tattasharraf and includes_date and includes_time and includes_location



class DataIdx155InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_155')

    def check_following(self, value):
        """
        Checks if the recipe contains at least five ingredients.
        Assumes ingredients are listed after a line containing "المكونات"
        and potentially before a line containing "طريقة التحضير".
        Counts non-empty lines in the ingredient section as ingredients.
        """
        lines = value.strip().split('\n')
        ingredients_start_idx = -1
        instructions_start_idx = -1
        for i, line in enumerate(lines):
            line_stripped = line.strip()
            if ingredients_start_idx == -1 and 'المكونات' in line_stripped:
                ingredients_start_idx = i
            if 'طريقة التحضير' in line_stripped:
                if instructions_start_idx == -1:
                    instructions_start_idx = i
        if ingredients_start_idx == -1:
            return False
        if instructions_start_idx != -1 and instructions_start_idx < ingredients_start_idx:
            return False
        ingredients_end_idx = len(lines)
        if instructions_start_idx != -1:
            ingredients_end_idx = instructions_start_idx
        ingredient_list_lines = lines[ingredients_start_idx + 1:ingredients_end_idx]
        non_empty_ingredient_lines_count = sum((1 for line in ingredient_list_lines if line.strip()))
        return non_empty_ingredient_lines_count >= 5



class DataIdx156InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_156')

    def check_following(self, value):
        """Checks if the response is a list of three items about reading benefits,
           separated only by semicolons, and contains no other punctuation.
           Constraints:
           1. Must be a list of three items.
           2. Items separated only by semicolons.
           3. No other punctuation marks allowed.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        forbidden_punctuation_chars = {'.', ',', '!', '?', '(', ')', '[', ']', '{', '}', '<', '>', '"', "'", '`', '،', '؟'}
        for char in value:
            char_code = ord(char)
            if char == ' ' or char == ';':
                continue
            if char in forbidden_punctuation_chars:
                return False
            if not 1536 <= char_code <= 1791:
                return False
        parts = value.split(';')
        non_empty_parts = [part.strip() for part in parts if part.strip()]
        return len(non_empty_parts) == 3



class DataIdx157InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_157')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 157.
        Instructions: Write a review for 'The Message', mention positive and negative aspects, use at least two metaphors.
        Args:
            value: A string representing the response (the movie review).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        review_text = value.replace('.', '').replace(',', '').replace('!', '').replace('?', '').lower()
        if 'الرسالة' not in review_text:
            return False
        positive_keywords = ['رائع', 'ممتاز', 'جيد', 'جميل', 'مؤثر', 'قوي', 'إيجابي', 'أعجبني', 'متقن', 'أداء', 'إخراج', 'قصة رائعة', 'ملحمي', 'تاريخي دقيق', 'تصوير جميل', 'أداء الممثلين', 'إخراج الفيلم', 'عظيم']
        has_positive = any((keyword in review_text for keyword in positive_keywords))
        if not has_positive:
            return False
        negative_keywords = ['ممل', 'ضعيف', 'بطيء', 'سلبي', 'لم يعجبني', 'عيوب', 'مشاكل', 'مخيب', 'أقل', 'بعض المشاهد', 'نهاية']
        has_negative = any((keyword in review_text for keyword in negative_keywords))
        if not has_negative:
            return False
        metaphor_indicators = ['رحلة', 'مرآة', 'نور', 'ظلام', 'بحر', 'جبل', 'قلب', 'روح', 'صوت', 'نافذة', 'جسد', 'كأنه', 'مثل', 'بمثابة', 'كنت أشعر', 'صورة', 'رمز']
        metaphor_count = 0
        for indicator in metaphor_indicators:
            metaphor_count += review_text.count(indicator)
        if metaphor_count < 2:
            return False
        return True



class DataIdx158InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_158')

    def check_following(self, value: str) -> bool:
        """
        Checks if the response string represents a list of 3 items,
        each item containing a name and a non-negative integer year
        separated by exactly one '+', and items are separated by newlines.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.strip().split('\n')
        non_empty_lines = [line.strip() for line in lines if line.strip()]
        if len(non_empty_lines) != 3:
            return False
        for line in non_empty_lines:
            if line.count('+') != 1:
                return False
            parts = line.split('+')
            if len(parts) != 2:
                return False
            name_part = parts[0].strip()
            year_part = parts[1].strip()
            if not name_part:
                return False
            if not year_part or not year_part.isdigit():
                return False
        return True



class DataIdx159InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_159')

    def check_following(self, value):
        """Checks if the response is a non-empty string, as required for writing a definition.

        The question asks for a brief definition of "Hadith Science" for specialists.
        The only universally checkable constraint based *solely* on the question
        without requiring external knowledge, NLP, or arbitrary thresholds for "brief"
        or "specialist" content is that a definition must be provided, meaning the
        response cannot be empty or just whitespace.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is a non-empty string with content, False otherwise.
        """
        if not isinstance(value, str):
            return False
        return bool(value and value.strip())



class DataIdx160InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('160')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 160.

        Constraints:
        - Between 60 and 80 words.
        - Must contain the word 'مستدام'.
        - Must contain the word 'بيئة'.
        - Must contain exactly one question mark '?'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if not 60 <= word_count <= 80:
            return False
        if 'مستدام' not in value:
            return False
        if 'بيئة' not in value:
            return False
        question_mark_count = value.count('?')
        if question_mark_count != 1:
            return False
        return True



class DataIdx161InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_161')

    def check_following(self, value):
        """Checks if the response is a dialogue between at least two speakers,
        each with at least 5 sentences.
        Note: The constraint about not using imperative verbs (أفعال أمر) is
        not checked due to the complexity of reliable Arabic verb form identification
        with basic string processing.
        Assumes dialogue turns start with a speaker name followed by ':' or '：'.
        Continuation lines for the same speaker do not need the prefix.
        """
        lines = value.strip().split('\n')
        speakers_text = {}
        current_speaker = None
        speaker_prefix_regex = re.compile('^\\s*([\\u0600-\\u06FF\\s]+?)\\s*[:：]\\s*(.*)$')
        for line in lines:
            line = line.strip()
            if not line:
                continue
            match = speaker_prefix_regex.match(line)
            if match:
                speaker_name = match.group(1).strip()
                rest_of_line = match.group(2).strip()
                current_speaker = speaker_name
                if current_speaker not in speakers_text:
                    speakers_text[current_speaker] = []
                if rest_of_line:
                    speakers_text[current_speaker].append(rest_of_line)
            elif current_speaker is not None:
                speakers_text[current_speaker].append(line)
            else:
                return False
        if len(speakers_text) < 2:
            return False
        sentence_delimiter_regex = re.compile('[.?!؟]')
        min_sentences_per_speaker = 5
        for speaker, lines_list in speakers_text.items():
            text = ' '.join(lines_list)
            sentence_parts = re.split(sentence_delimiter_regex, text)
            sentence_count = len([part for part in sentence_parts if part.strip()])
            if sentence_count < min_sentences_per_speaker:
                return False
        return True



class DataIdx162InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_162')

    def check_following(self, value):
        """Checks if the response contains any punctuation marks.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (contains no punctuation),
            or False otherwise.
        """
        punctuation_chars = string.punctuation
        for char in value:
            if char in punctuation_chars:
                return False
        return True



class DataIdx163InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_163')

    def check_following(self, value):
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        sentence_terminators = '.!?'
        ends_with_terminator = cleaned_value and cleaned_value[-1] in sentence_terminators
        terminator_count = sum((cleaned_value.count(term) for term in sentence_terminators))
        is_single_sentence_structure = ends_with_terminator and terminator_count == 1
        if not is_single_sentence_structure:
            return False
        nasikh_verbs = ['كان', 'أصبح', 'أضحى', 'ظل', 'أمسى', 'بات', 'صار', 'ليس', 'ما زال', 'ما برح', 'ما فتئ', 'ما انفك', 'ما دام']
        contains_nasikh = any((verb in cleaned_value for verb in nasikh_verbs))
        if not contains_nasikh:
            return False
        return True



class DataIdx164InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_164')

    def check_following(self, value):
        """Checks if the response is the correct pluralization of 'هذا الكتاب مفيد.'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is the correct pluralized sentence, False otherwise.
        """
        expected_plural = 'هذه الكتب مفيدة.'
        return value.strip() == expected_plural



class DataIdx165InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_165')

    def check_following(self, value):
        """Checks if the response uses a simile to describe the speed of the wind in Arabic."""
        if not isinstance(value, str):
            return False
        words = value.split()
        if len(words) < 4:
            return False
        wind_terms = ['الرياح', 'الريح']
        has_wind_term = any((term in value for term in wind_terms))
        if not has_wind_term:
            return False
        explicit_markers = ['مثل', 'كأن']
        has_explicit_marker = any((marker in value for marker in explicit_markers))
        has_kaf_simile = False
        for i in range(len(value) - 1):
            if value[i] == 'ك' and (not value[i + 1].isspace()):
                has_kaf_simile = True
                break
        has_any_simile = has_explicit_marker or has_kaf_simile
        if not has_any_simile:
            return False
        return True



class DataIdx166InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_166')

    def check_following(self, value):
        """Checks if the response follows the constraints for question IDX 166.

        Constraints:
        1. Exactly two paragraphs.
        2. Paragraphs separated by exactly three empty lines.
        3. The second paragraph starts with "بالإضافة".

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        separator = '\n\n\n\n'
        parts = value.split(separator)
        if len(parts) != 2:
            return False
        part1 = parts[0]
        part2 = parts[1]
        if not part1.strip() or not part2.strip():
            return False
        part2_lines = part2.splitlines()
        first_non_empty_line_part2 = None
        for line in part2_lines:
            if line.strip():
                first_non_empty_line_part2 = line
                break
        if first_non_empty_line_part2 is None:
            return False
        if not first_non_empty_line_part2.startswith('بالإضافة'):
            return False
        return True



class DataIdx167InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_167')

    def check_following(self, value):
        """
        Checks if the response attempts to use only the passive voice in Arabic.
        This is a heuristic check looking for the absence of some common active verb suffixes
        attached to subject pronouns (نا, تم, تن, تما). This is NOT a perfect check
        and will not detect all active voice uses, especially those with explicit
        noun subjects, implicit subjects, different verb forms/tenses, or active
        verbs ending in other patterns (like 'ت' or 'وا').
        It might also incorrectly flag non-verb words ending in these patterns,
        though a minimum length check is included to reduce this risk slightly.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            False if a word ending in a common active suffix ('نا', 'تم', 'تن', 'تما') is found
            and the word is long enough, True otherwise (indicating that no such active marker
            was detected by this specific heuristic).
        """
        if not isinstance(value, str) or not value.strip():
            return False
        active_suffixes_and_min_len = {'نا': 3, 'تم': 3, 'تن': 3, 'تما': 4}
        translator = str.maketrans('', '', string.punctuation)
        words = [word for word in value.translate(translator).split() if word]
        for word in words:
            for suffix, min_len in active_suffixes_and_min_len.items():
                if word.endswith(suffix) and len(word) >= min_len:
                    return False
        return True



class DataIdx168InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_168')

    def check_following(self, value):
        """Checks if the response ends exactly with 'مع خالص شكري وتقديري،'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response ends exactly with 'مع خالص شكري وتقديري،', False otherwise.
        """
        required_ending = 'مع خالص شكري وتقديري،'
        return value.strip().endswith(required_ending)



class DataIdx169InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_169')

    def check_following(self, value):
        """Checks if the response follows the instruction for IDX 169.

        Instructions:
        - Provide two different examples of questions starting with "لماذا" (Why).
        - The topic of the questions must be "التلوث" (Pollution). (Semantic check, not strictly enforced here).
        - Separate the two examples with exactly five consecutive exclamation marks (!!!!!).
        - Each example must be on a separate line.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the structural/syntactic instruction or False otherwise.
        """
        lines = value.strip().splitlines()
        if len(lines) != 3:
            return False
        if lines[1] != '!!!!!':
            return False
        q1 = lines[0].strip()
        q2 = lines[2].strip()
        if not q1 or not q2:
            return False
        if not q1.startswith('لماذا') or not q2.startswith('لماذا'):
            return False
        if q1 == q2:
            return False
        return True



class DataIdx170InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_170')

    def check_following(self, value):
        """Checks if the response is a list of 5 tips, each starting with an imperative verb.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.splitlines()
        tips = [line.strip() for line in lines if line.strip()]
        if len(tips) != 5:
            return False
        first_arabic_word_pattern = re.compile('^\\s*[^\\u0600-\\u06FF]*([\\u0600-\\u06FF]+)')
        for tip in tips:
            match = first_arabic_word_pattern.match(tip)
            if not match:
                return False
            first_word = match.group(1)
            starts_with_alif_forms = first_word.startswith(('ا', 'أ', 'إ', 'آ'))
            starts_with_ta = first_word.startswith('ت')
            is_long_enough = len(first_word) >= 3
            if not ((starts_with_alif_forms or starts_with_ta) and is_long_enough):
                return False
        return True



class DataIdx171InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_171')

    def check_following(self, value):
        """Checks if the response is a single sentence in Arabic containing 'تنمية' and 'خيال'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        contains_tanmia = 'تنمية' in value
        contains_khayal = 'خيال' in value
        stripped_value = value.strip()
        has_newline = '\n' in stripped_value
        if has_newline:
            return False
        internal_check_value = stripped_value
        if stripped_value and stripped_value[-1] in ['.', '!', '?']:
            internal_check_value = stripped_value[:-1]
        internal_punctuation = any((char in internal_check_value for char in ['.', '!', '?']))
        is_single_sentence_heuristic = not internal_punctuation
        return contains_tanmia and contains_khayal and is_single_sentence_heuristic



class DataIdx172InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_172')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        return 'تقدير' in value



class DataIdx173InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_173')

    def check_following(self, value):
        """Checks if the response lists three social media types with one feature each,
        separated by '&', and presents exactly three such pairs.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        normalized_value = value.replace(';', ',').replace('\n', ',')
        potential_items = [item.strip() for item in normalized_value.split(',') if item.strip()]
        valid_pairs_count = 0
        for item in potential_items:
            parts = item.split('&')
            if len(parts) == 2:
                social_media = parts[0].strip()
                feature = parts[1].strip()
                if social_media and feature:
                    valid_pairs_count += 1
        return valid_pairs_count == 3



class DataIdx174InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_174')

    def check_following(self, value):
        """Checks if the response is enclosed in <<>> and contains the word 'آلية'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not value.startswith('<<') or not value.endswith('>>'):
            return False
        content = value[2:-2]
        if 'آلية' not in content:
            return False
        return True



class DataIdx175InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_175')

    def check_following(self, value):
        """Checks if the response follows the instruction for IDX 175.

        Constraints:
        1. Must have a title enclosed in curly braces {} at the beginning, e.g., {عنوان القصيدة}.
        2. Must consist of exactly 10 verses (lines).
        3. Must use a question mark '?' exactly once.

        Args:
            value: A string representing the response (the poem).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if not value.startswith('{'):
            return False
        end_title_idx = value.find('}')
        if end_title_idx == -1 or end_title_idx == 1:
            return False
        if end_title_idx + 1 < len(value) and value[end_title_idx + 1].strip() not in ['', '\n']:
            poem_start_idx = end_title_idx + 1
            while poem_start_idx < len(value) and value[poem_start_idx].isspace() and (value[poem_start_idx] != '\n'):
                poem_start_idx += 1
            if poem_start_idx < len(value) and value[poem_start_idx] != '\n':
                next_char_after_brace = value[end_title_idx + 1:].lstrip()
                if next_char_after_brace and next_char_after_brace[0] != '\n':
                    pass
        poem_body = value[end_title_idx + 1:]
        lines = poem_body.splitlines()
        verses = [line for line in lines if line.strip()]
        if len(verses) != 10:
            return False
        q_count = value.count('?')
        if q_count != 1:
            return False
        return True



class DataIdx176InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_176')

    def check_following(self, value):
        """Checks if the response contains any punctuation marks based on the instruction.
        The instruction requires that the answer does not use any punctuation marks.
        Args:
            value: A string representing the response.

        Returns:
            True if the response contains no punctuation, False otherwise.
        """
        punctuation_chars = string.punctuation + '،؛؟'
        for char in value:
            if char in punctuation_chars:
                return False
        return True



class DataIdx177InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_177')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 177.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instructions, False otherwise.
        """
        if 'سيناريو' in value or 'فيلم' in value:
            return False
        if 'حركة' not in value:
            return False
        if '/' in value:
            return False
        return True



class DataIdx178InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_178')

    def check_following(self, value):
        """Checks if the response is a film review that includes opinions on acting, direction, and story, and uses the word 'مؤثر'.
        Args:
            value: A string representing the response (the film review).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        required_word = 'مؤثر'
        has_required_word = required_word in value
        acting_keywords = ['التمثيل', 'الممثلين', 'أداء', 'الأداء']
        direction_keywords = ['الإخراج', 'المخرج', 'إخراج']
        story_keywords = ['القصة', 'السيناريو', 'الحبكة']
        has_acting = any((kw in value for kw in acting_keywords))
        has_direction = any((kw in value for kw in direction_keywords))
        has_story = any((kw in value for kw in story_keywords))
        return has_required_word and has_acting and has_direction and has_story



class DataIdx179InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_179')

    def check_following(self, value):
        """Checks if the response contains a headline <= 10 words and a report around 50 words (40-60).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.strip().split('\n')
        if not lines:
            return False
        headline = lines[0].strip()
        report_lines = lines[1:]
        report = '\n'.join(report_lines).strip()
        if not report:
            return False
        headline_word_count = len(headline.split())
        report_word_count = len(report.split())
        headline_constraint_met = headline_word_count <= 10
        report_min_words = 40
        report_max_words = 60
        report_constraint_met = report_min_words <= report_word_count <= report_max_words
        return headline_constraint_met and report_constraint_met



class DataIdx180InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_180')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 180.

        Instructions:
        1. Give opinion in one sentence. (Difficult to check programmatically, rely on other checks)
        2. Must contain the word 'تراث'.
        3. Must not exceed 20 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        contains_turath = 'تراث' in value
        words = value.split()
        word_count = len(words)
        word_count_ok = word_count <= 20
        return contains_turath and word_count_ok



class DataIdx181InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_181')

    def check_following(self, value):
        """Checks if the response is a brief definition of 'العولمة' (less than 35 words)
           and does not use the word 'العالم'.

        Args:
            value: A string representing the response (the definition).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        words = [word for word in words if word]
        word_count = len(words)
        if word_count >= 35:
            return False
        forbidden_word = 'العالم'
        punctuation_chars = '.,!?;:()[]{}"\'«»'
        cleaned_words = [word.strip(punctuation_chars) for word in words]
        if forbidden_word in cleaned_words:
            return False
        return True



class DataIdx182InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_182')

    def check_following(self, value):
        """Checks if the response includes the word "سلام" at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response includes "سلام" at least once, False otherwise.
        """
        if not isinstance(value, str):
            return False
        return 'سلام' in value



class DataIdx183InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('183')

    def check_following(self, value):
        """Checks if the response (email) avoids using any exclamation marks.

        Args:
            value: A string representing the response (the email content).

        Returns:
            True if the response does not contain any exclamation marks, False otherwise.
        """
        if isinstance(value, str):
            return '!' not in value
        return False



class DataIdx184InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_184')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 184.

        Instructions:
        - Paragraph about the benefits of exercise.
        - Minimum 3 lines, maximum 5 lines.
        - Includes the word 'صحة' at least 3 times.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instructions or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        lines = [line for line in lines if line.strip()]
        num_lines = len(lines)
        if num_lines < 3 or num_lines > 5:
            return False
        keyword = 'صحة'
        text_to_search = value.replace('\n', ' ')
        words = re.findall('\\b\\w+\\b', value)
        keyword_count = words.count(keyword)
        if keyword_count < 3:
            return False
        return True



class DataIdx185InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_185')

    def check_following(self, value):
        """Checks if the response follows the instruction not to use the word 'التكنولوجيا'.

        Args:
            value: A string representing the response.

        Returns:
            True if the word 'التكنولوجيا' is NOT present in the response, False otherwise.
        """
        prohibited_word = 'التكنولوجيا'
        return prohibited_word not in value



class DataIdx186InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_186')

    def check_following(self, value):
        """Checks if the response follows the instruction constraints.
        The instruction requires listing three tourist attractions without using any numbers.
        This checker specifically verifies that no digits are present in the response string.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains no digits, False otherwise.
        """
        if not isinstance(value, str):
            return False
        for char in value:
            if char.isdigit():
                return False
        return True



class DataIdx187InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_187')

    def check_following(self, value):
        """Checks if the response is a single sentence containing at least one preposition and one conjunction.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        preposition_pattern = '\\b(?:من|إلى|عن|على|في)\\b|\\b[بلك]\\w+|\\b[بلك]\\b'
        conjunction_pattern = '\\b(?:ثم|أو|أم|لا|بل|لكن)\\b|\\b[وف]\\w+|\\b[وف]\\b'
        has_preposition = re.search(preposition_pattern, value) is not None
        has_conjunction = re.search(conjunction_pattern, value) is not None
        return has_preposition and has_conjunction



class DataIdx188InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_188')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 188.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if 'شعر' in value:
            return False
        sentence_terminators = ['.', '!', '?']
        terminator_count = sum((value.count(term) for term in sentence_terminators))
        if terminator_count > 1:
            return False
        return True



class DataIdx189InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_189')

    def check_following(self, value):
        """Checks if the response starts with 'إلى معلمي العزيز'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response starts with the required phrase, False otherwise.
        """
        if not isinstance(value, str):
            return False
        required_start = 'إلى معلمي العزيز'
        return value.strip().startswith(required_start)



class DataIdx190InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_190')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 190.

        Constraints:
        - Not exceeding 80 words.
        - Use the word 'أستمتع' (I enjoy) at least once.
        (Constraint about hobby name at the beginning is hard to verify programmatically without knowing the hobby).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the verifiable instructions, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count > 80:
            return False
        if 'أستمتع' not in value:
            return False
        return True



class DataIdx191InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_191')

    def check_following(self, value):
        """Checks if the response is a prose poem of exactly five lines
           and contains no punctuation marks.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.split('\n')
        if len(lines) != 5:
            return False
        punctuation = '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~'
        for char in value:
            if char in punctuation:
                return False
        return True



class DataIdx192InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_192')

    def check_following(self, value):
        """Checks if the response includes 'ماء' at least 3 times and 'سكر' at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        count_ماء = value.count('ماء')
        count_سكر = value.count('سكر')
        condition_ماء = count_ماء >= 3
        condition_سكر = count_سكر >= 1
        return condition_ماء and condition_سكر



class DataIdx193InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_193')

    def check_following(self, value):
        """Checks if the response is a single paragraph as required by the instruction.

        Args:
            value: A string representing the response.

        Returns:
            True if the response appears to be a single paragraph, False otherwise.
        """
        cleaned_value = value.strip()
        lines = cleaned_value.splitlines()
        non_empty_lines_count = 0
        for i, line in enumerate(lines):
            if line.strip():
                non_empty_lines_count += 1
                if non_empty_lines_count > 1 and i > 0 and (not lines[i - 1].strip()):
                    return False
        if '\n\n' in cleaned_value:
            return False
        if '\r\n\r\n' in cleaned_value:
            return False
        return True



class DataIdx194InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_194')

    def check_following(self, value):
        """Checks if the response is a single Arabic sentence about the beauty of nature
           containing the words 'جمال', 'الطبيعة', and 'خلاب', ending with appropriate punctuation.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        sentence_punctuations = ['.', '!', '?']
        ends_with_sentence_punct = any((cleaned_value.endswith(p) for p in sentence_punctuations))
        if not ends_with_sentence_punct:
            return False
        punctuations_before_end = [p for p in sentence_punctuations if p in cleaned_value[:-1]]
        if punctuations_before_end:
            found_multiple_sentence_puncts = False
            last_punct_index = -1
            for i in range(len(cleaned_value) - 1, -1, -1):
                if cleaned_value[i] in sentence_punctuations:
                    last_punct_index = i
                    break
            if last_punct_index != -1:
                for p in sentence_punctuations:
                    if p in cleaned_value[:last_punct_index]:
                        found_multiple_sentence_puncts = True
                        break
            if found_multiple_sentence_puncts:
                return False
        required_words = ['جمال', 'الطبيعة', 'خلاب']
        arabic_punctuation = string.punctuation + '،؛؟«»'
        translator = str.maketrans('', '', arabic_punctuation)
        cleaned_for_words = cleaned_value.translate(translator)
        words = cleaned_for_words.split()
        for word in required_words:
            if word not in words:
                return False
        return True



class DataIdx195InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_195')

    def check_following(self, value):
        """Checks if the response lists the eight planets in order using bullet points.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        correct_planets = ['عطارد', 'الزهرة', 'الأرض', 'المريخ', 'المشتري', 'زحل', 'أورانوس', 'نبتون']
        lines = value.strip().split('\n')
        extracted_planets = []
        found_bullet_point = False
        for line in lines:
            stripped_line = line.strip()
            if not stripped_line:
                continue
            if stripped_line.startswith('- '):
                planet_name = stripped_line[2:].strip()
                extracted_planets.append(planet_name)
                found_bullet_point = True
            elif stripped_line.startswith('* '):
                planet_name = stripped_line[2:].strip()
                extracted_planets.append(planet_name)
                found_bullet_point = True
            elif stripped_line.startswith('• '):
                planet_name = stripped_line[2:].strip()
                extracted_planets.append(planet_name)
                found_bullet_point = True
            else:
                return False
        if not found_bullet_point:
            return False
        if len(extracted_planets) != 8:
            return False
        if extracted_planets != correct_planets:
            return False
        return True



class DataIdx196InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_196')

    def check_following(self, value):
        """Checks if the response is in four paragraphs separated by '###' and contains specific keywords.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        paragraphs = value.split('###')
        if len(paragraphs) != 4:
            return False
        if any((p.strip() == '' for p in paragraphs)):
            return False
        required_keywords = ['تواصل', 'معلومات', 'تطور', 'تحديات']
        for keyword in required_keywords:
            if keyword not in value:
                return False
        return True



class DataIdx197InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_197')

    def check_following(self, value):
        """
        Checks if the response follows the constraints for recipe IDX 197:
        - Simple salad recipe with 5 ingredients.
        - Must include ingredient list and numbered preparation steps.
        - Use only numerical digits (1, 2, 3), not spelled-out numbers.

        Args:
            value: A string representing the response (the recipe).

        Returns:
            True if the response follows the instructions or False otherwise.
        """
        arabic_number_words = ['واحد', 'اثنان', 'ثلاثة', 'أربعة', 'خمسة', 'ستة', 'سبعة', 'ثمانية', 'تسعة', 'عشرة', 'إحدى', 'اثنتا', 'ثلاث', 'أربع', 'خمس', 'ست', 'سبع', 'ثمان', 'تسع', 'عشر', 'عشرون', 'ثلاثون', 'أربعون', 'خمسون', 'ستون', 'سبعون', 'ثمانون', 'تسعون', 'مئة', 'مائة', 'ألف', 'ألوف', 'آلاف', 'مليون', 'مليارات', 'بليون', 'بلايين', 'الأولى', 'الثانية', 'الثالثة', 'الرابعة', 'الخامسة', 'السادسة', 'السابعة', 'الثامنة', 'التاسعة', 'العاشرة']
        number_words_pattern = '\\b(' + '|'.join(arabic_number_words) + ')\\b'
        if re.search(number_words_pattern, value, re.IGNORECASE):
            return False
        lines = value.strip().split('\n')
        found_digit_numbered_line = False
        for line in lines:
            cleaned_line = line.strip()
            if re.match('^\\d+[\\.\\)]', cleaned_line):
                found_digit_numbered_line = True
                break
        if not found_digit_numbered_line:
            return False
        list_item_pattern = re.compile('^\\s*(\\*|\\-|\\d+[\\.\\)])\\s*.+', re.MULTILINE)
        ingredient_list_found_with_5 = False
        current_potential_list = []
        for line in lines:
            cleaned_line = line.strip()
            if list_item_pattern.match(cleaned_line):
                current_potential_list.append(cleaned_line)
            elif current_potential_list:
                if len(current_potential_list) == 5:
                    ingredient_list_found_with_5 = True
                    break
                current_potential_list = []
        if current_potential_list and len(current_potential_list) == 5:
            ingredient_list_found_with_5 = True
        if not ingredient_list_found_with_5:
            return False
        return True



class DataIdx198InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_198')

    def check_following(self, value):
        """Checks if the response is a summary in Arabic and is less than 100 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return word_count < 100



class DataIdx199InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_199')

    def check_following(self, value):
        """Checks if the response is an Arabic city name starting with 'م' and ending with 'ة'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        value = value.strip()
        if not value:
            return False
        starts_with_meem = value.startswith('م')
        ends_with_ta_marbuta = value.endswith('ة')
        return starts_with_meem and ends_with_ta_marbuta



class DataIdx200InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_200')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 200.

        Instructions:
        - Text should not exceed 10 lines.
        - No words should start with the letter 'س' (Sin).
        - The word 'الأفق' (horizon) must be used exactly twice.

        Args:
            value: A string representing the response text.

        Returns:
            True if the response follows all instructions, False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        lines = cleaned_value.splitlines()
        if len(lines) > 10:
            return False
        words_raw = cleaned_value.split()
        punctuation_chars = '.,!?:;«»()[]{}"\'—'
        cleaned_words = []
        for word_raw in words_raw:
            word = word_raw.strip(punctuation_chars)
            if word:
                cleaned_words.append(word)
        afaq_count = 0
        forbidden_sin_found = False
        for word in cleaned_words:
            if word.startswith('س'):
                forbidden_sin_found = True
            if word == 'الأفق':
                afaq_count += 1
        if forbidden_sin_found:
            return False
        if afaq_count != 2:
            return False
        return True



class DataIdx201InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_201')

    def check_following(self, value):
        """Checks if the response contains the sequence 'حرف' at least three times.
        Args:
            value: A string representing the response.

        Returns:
            True if 'حرف' appears 3 or more times, False otherwise.
        """
        if not isinstance(value, str):
            return False
        count_harf = value.count('حرف')
        return count_harf >= 3



class DataIdx202InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_202')

    def check_following(self, value):
        """Checks if the response is a single paragraph about Riyadh, starts with "تعتبر", and is not more than 50 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        if not stripped_value.startswith('تعتبر'):
            return False
        words = stripped_value.split()
        if len(words) > 50:
            return False
        return True



class DataIdx203InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_203')

    def check_following(self, value):
        """Checks if the response is a single sentence, uses 'مدينة' once, and has underlined text.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        if '\n' in value:
            return False
        temp_value = value.strip()
        sentence_enders = ['.', '!', '?']
        if not temp_value.endswith(tuple(sentence_enders)):
            return False
        ender_count = sum((temp_value.count(e) for e in sentence_enders))
        if ender_count != 1:
            return False
        city_word = 'مدينة'
        city_matches = re.findall('\\b' + re.escape(city_word) + '\\b', value)
        if len(city_matches) != 1:
            return False
        underlined_matches = re.findall('_.+?_', value)
        if not underlined_matches:
            return False
        return True



class DataIdx204InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_204')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 204.
        The instructions require a short, exciting, and engaging news headline
        about a recent major sporting event.
        Due to the nature of the request (exciting, engaging, recent major event),
        only the 'short' aspect is programmatically checked here via word count.

        Args:
            value: A string representing the response (the proposed headline).

        Returns:
            True if the response meets the programmatic constraints (e.g., length),
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        MAX_WORDS = 12
        words = value.strip().split()
        word_count = len(words)
        return word_count <= MAX_WORDS



class DataIdx205InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_205')

    def check_following(self, value):
        """Checks if the response avoids using the word "الكتاب".

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain the word "الكتاب", False otherwise.
        """
        forbidden_word = 'الكتاب'
        return forbidden_word not in value



class DataIdx206InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_206')

    def check_following(self, value):
        """Checks if the value uses at least three different punctuation marks.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        found_punctuation = set()
        for char in value:
            try:
                if unicodedata.category(char).startswith('P'):
                    found_punctuation.add(char)
            except TypeError:
                continue
            except AttributeError:
                continue
        return len(found_punctuation) >= 3



class DataIdx207InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_207')

    def check_following(self, value):
        """Checks if the response is a short wisdom about time consisting of exactly four words.
        Args:
            value: A string representing the response (the wisdom).

        Returns:
            True if the response follows the instruction (exactly 4 words), False otherwise.
        """
        words = value.split()
        return len(words) == 4



class DataIdx208InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_208')

    def check_following(self, value):
        """Checks if the response is a single sentence.
        Args:
            value: A string representing the response.

        Returns:
            True if the response is a single sentence ending with '.', '!', or '?', False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        terminal_punctuation = ['.', '!', '?']
        ends_correctly = cleaned_value.endswith(tuple(terminal_punctuation))
        if not ends_correctly:
            return False
        punctuation_count = sum((cleaned_value.count(p) for p in terminal_punctuation))
        return punctuation_count == 1



class DataIdx209InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_209')

    def check_following(self, value):
        """
        Checks if the response is a summary no longer than 100 words
        and includes the word "مهم" at least twice.

        Args:
            value: A string representing the response (summary).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count > 100:
            return False
        keyword_count = 0
        punctuation = '.,!?;:،؛؟'
        for word in words:
            cleaned_word = word.strip(punctuation)
            if cleaned_word == 'مهم':
                keyword_count += 1
        if keyword_count < 2:
            return False
        return True



class DataIdx210InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_210')

    def check_following(self, value):
        """Checks if the response value (Arabic text) is a short story that does not exceed 150 words.

        Args:
            value: A string representing the response (the Arabic story).

        Returns:
            True if the word count is 150 or less, False otherwise.
        """
        words = value.split()
        word_count = len(words)
        return word_count <= 150



class DataIdx211InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_211')

    def check_following(self, value):
        """Checks if the response is in the form of a numbered list.

        Args:
            value: A string representing the response.

        Returns:
            True if the response appears to be a numbered list, False otherwise.
        """
        lines = value.strip().split('\n')
        non_empty_lines = [line.strip() for line in lines if line.strip()]
        if len(non_empty_lines) < 2:
            return False
        pattern = re.compile('^\\d+[\\.\\):]\\s*')
        num_lines_to_check = min(len(non_empty_lines), 3)
        matched_count = 0
        for i in range(num_lines_to_check):
            if pattern.match(non_empty_lines[i]):
                matched_count += 1
        if matched_count >= 2:
            return True
        else:
            return False



class DataIdx212InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_212')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        required_word = 'بيئة'
        min_occurrences = 3
        count = value.count(required_word)
        return count >= min_occurrences



class DataIdx213InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_213')

    def check_following(self, value):
        """Checks if the response is a short message inviting a friend to a museum,
           is less than 35 words, and ends with a question mark.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        word_count = len(value.split())
        less_than_35_words = word_count < 35
        ends_with_question_mark = value.strip().endswith('?')
        return less_than_35_words and ends_with_question_mark



class DataIdx214InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_214')

    def check_following(self, value):
        """
        Checks if the response contains common Arabic adjectives from a predefined list,
        after normalizing the text (removing punctuation and common diacritics/tanwin).

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain forbidden adjectives, False otherwise.
        """
        FORBIDDEN_ADJECTIVES_BASE = {'لذيذ', 'سيء', 'جيد', 'كبير', 'صغير', 'جميل', 'نظيف', 'متسخ', 'غالي', 'رخيص', 'سريع', 'بطيء', 'ممتاز', 'عادي', 'حار', 'بارد', 'ودود', 'مريح', 'ضيق', 'واسع', 'جديد', 'قديم', 'مشغول', 'هادئ', 'متنوع', 'مختلف', 'مشترك', 'خاص', 'عام', 'لذيذة', 'سيئة', 'جيدة', 'كبيرة', 'صغيرة', 'جميلة', 'نظيفة', 'متسخة', 'غالية', 'رخيصة', 'سريعة', 'بطيئة', 'ممتازة', 'عادية', 'حارة', 'باردة', 'ودودة', 'مريحة', 'ضيقة', 'واسعة', 'جديدة', 'قديمة', 'مشغولة', 'هادئة', 'متنوعة', 'مختلفة', 'مشتركة', 'خاصة', 'عامة', 'أكبر', 'أصغر', 'أجمل', 'أنظف', 'أسوأ', 'أفضل', 'أغلى', 'أرخص', 'أسرع', 'أبطأ', 'أحدث', 'أقدم', 'أكثر', 'أقل', 'كثير', 'قليل', 'كثيرة', 'قليلة', 'كبار', 'صغار', 'جدد', 'جداد', 'قدامى'}
        forbidden_adjectives = FORBIDDEN_ADJECTIVES_BASE.union({'ال' + adj for adj in FORBIDDEN_ADJECTIVES_BASE})

        def normalize_text(text):
            text = text.translate(str.maketrans('', '', string.punctuation + '،؛؟'))
            patt = re.compile('[\\u064b-\\u0652]')
            text = patt.sub('', text)
            text = text.replace('ـ', '')
            text = text.replace('إ', 'ا')
            text = text.replace('أ', 'ا')
            text = text.replace('آ', 'ا')
            return text.strip()
        normalized_value = normalize_text(value)
        words = normalized_value.split()
        for word in words:
            if word in forbidden_adjectives:
                return False
        return True



class DataIdx215InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('215')

    def check_following(self, value):
        """Checks if the response is a list of no more than five items, assumed to be basic food items.

        Args:
            value: A string representing the response, expected to be a list (e.g., newline-separated).

        Returns:
            True if the response follows the constraint of having 5 or fewer items, False otherwise.
        """
        items = [item.strip() for item in value.splitlines() if item.strip()]
        if len(items) > 5:
            return False
        return True



class DataIdx216InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_216')

    def check_following(self, value):
        """Checks if the response meets the criteria for IDX 216.

        The criteria are:
        1. Is a single sentence in Arabic.
        2. Expresses the importance of respecting others' opinions.
        3. Must contain the word 'تسامح'.

        Programmatically checks:
        - Contains Arabic characters.
        - Contains the specific word 'تسامح'.
        - Contains at least one sentence-ending punctuation (simplified check for "is a sentence").
        - Cannot reliably check "single sentence" or the specific meaning about respecting opinions.
        """
        if not isinstance(value, str):
            return False
        value = value.strip()
        has_arabic_char = any(('\u0600' <= char <= 'ۿ' or 'ݐ' <= char <= 'ݿ' for char in value))
        if not has_arabic_char:
            return False
        if 'تسامح' not in value:
            return False
        sentence_enders = ['.', '!', '؟']
        has_sentence_ender = any((ender in value for ender in sentence_enders))
        if not has_sentence_ender:
            if not value or (not value[-1] in sentence_enders and value[-1].isalnum()):
                return False
        return True



class DataIdx217InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_217')

    def check_following(self, value):
        """
        Checks if the response follows the instruction for question idx_217.
        Constraints:
        - At least 3 sentences.
        - At most 4 sentences.
        - Must not contain the word 'جداً'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if re.search('\\bجداً\\b', value):
            return False
        sentences = [sent.strip() for sent in re.split('[.?!]', value) if sent.strip()]
        sentence_count = len(sentences)
        if 3 <= sentence_count <= 4:
            return True
        else:
            return False



class DataIdx218InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_218')

    def check_following(self, value):
        """Checks if the response lists three landmarks in a bulleted list and avoids the word 'الشهيرة'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if 'الشهيرة' in value:
            return False
        lines = value.strip().split('\n')
        bullet_count = 0
        valid_bullets = ['-', '*', '+']
        for line in lines:
            stripped_line = line.strip()
            if any((stripped_line.startswith(bullet) for bullet in valid_bullets)):
                bullet_count += 1
        return bullet_count == 3



class DataIdx219InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_219')

    def check_following(self, value):
        """Checks if the response is a JSON dictionary with key 'فواكه',
        whose value is a list containing exactly three dictionaries,
        each representing a fruit and having at least two keys (e.g., name and color).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        try:
            data = json.loads(value)
        except json.JSONDecodeError:
            return False
        if not isinstance(data, dict):
            return False
        if 'فواكه' not in data:
            return False
        fruits_list = data['فواكه']
        if not isinstance(fruits_list, list):
            return False
        if len(fruits_list) != 3:
            return False
        for item in fruits_list:
            if not isinstance(item, dict):
                return False
            if len(item) < 2:
                return False
        return True



class DataIdx220InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_220')

    def check_following(self, value):
        """Checks if the response is a single sentence in Arabic congratulating on a birthday with a celebration emoji.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentence_terminators = ['.', '؟', '!']
        terminator_count = sum((value.count(term) for term in sentence_terminators))
        is_single_sentence = terminator_count == 1
        celebration_emojis = {'🎉', '🎂', '🥳', '🎈', '🎁', '🎊', '✨', '🥂', '🍾', '🍰', '🥳', '😊', '👍', '❤️', '🌹'}
        has_celebration_emoji = False
        for emoji in celebration_emojis:
            if emoji in value:
                has_celebration_emoji = True
                break
        return is_single_sentence and has_celebration_emoji



class DataIdx221InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_221')

    def check_following(self, value):
        """Checks if the response is a recipe mentioning ingredients and instructions, and ends with 'شهية طيبة!'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value:
            return False
        if not value.rstrip().endswith('شهية طيبة!'):
            return False
        if 'المكونات' not in value:
            return False
        if 'التعليمات' not in value:
            return False
        return True



class DataIdx222InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_222')

    def check_following(self, value):
        """
        Checks if the response follows the instruction:
        - Is a numbered list containing items 1 through 5.
        - Only items numbered 1-5 formatted as list items are present.
        - Each item from 1 to 5 starts with a word (content is not empty).
        - The first word of each item from 1 to 5 does not start with 'ال'
          (simplified check for starting with a verb).
        """
        lines = value.strip().split('\n')
        found_items = {}
        line_pattern_any_num = re.compile('^\\s*(\\d+|[٠-٩]+)[\\.\\)\\s]*(.*)$')
        all_found_numbers_formatted = set()
        arabic_to_western = {'٠': 0, '١': 1, '٢': 2, '٣': 3, '٤': 4, '٥': 5, '٦': 6, '٧': 7, '٨': 8, '٩': 9}
        for line in lines:
            line = line.strip()
            if not line:
                continue
            match = line_pattern_any_num.match(line)
            if match:
                number_str = match.group(1)
                number = 0
                try:
                    western_num_str = ''.join((str(arabic_to_western.get(char, char)) for char in number_str))
                    number = int(western_num_str)
                except ValueError:
                    continue
                if number in all_found_numbers_formatted:
                    return False
                all_found_numbers_formatted.add(number)
                if 1 <= number <= 5:
                    content = match.group(2).strip()
                    first_word = ''
                    first_word_match = re.match('^\\s*(\\S+)', content)
                    if first_word_match:
                        first_word = first_word_match.group(1)
                    found_items[number] = first_word
        if all_found_numbers_formatted != {1, 2, 3, 4, 5}:
            return False
        for number in range(1, 6):
            first_word = found_items[number]
            if not first_word or first_word.startswith('ال'):
                return False
        return True



class DataIdx223InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_223')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 223.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        stripped_value = value.strip()
        if not stripped_value:
            return False
        first_line = stripped_value.split('\n', 1)[0].strip()
        starts_correctly = first_line.startswith('عزيزي ') and first_line.endswith(',')
        ends_correctly = stripped_value.endswith('مع أطيب التمنيات.')
        return starts_correctly and ends_correctly



class DataIdx224InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_224')

    def check_following(self, value):
        """
        Checks if the response follows the instruction to write a short email
        and does not exceed 15 words in total.

        Args:
            value: A string representing the response.

        Returns:
            True if the total word count is 15 words or less, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return word_count <= 15



class DataIdx225InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('225')

    def check_following(self, value):
        """Checks if the response (Arabic description) does not exceed 75 words.

        Args:
            value: A string representing the response (Arabic description).

        Returns:
            True if the description has 75 words or less, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return word_count <= 75



class DataIdx226InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_226')

    def check_following(self, value):
        """Checks if the response is a list of five Arabic words starting with 'ب'.
        Args:
            value: A string representing the response.
        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        arabic_word_pattern = re.compile('[\\u0600-\\u06FF]+')
        words = arabic_word_pattern.findall(value)
        if len(words) != 5:
            return False
        for word in words:
            if not word or word[0] != 'ب':
                return False
        return True



class DataIdx227InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_227')

    def check_following(self, value):
        """Checks if the response is an Arabic paragraph that mentions 'المعرفة' and 'الخيال'.
        Note: Persuasiveness and the presence of a metaphor are not checked automatically due to complexity.
        A basic check for presence of Arabic characters is performed.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains the required keywords and appears to be in Arabic, False otherwise.
        """
        if not isinstance(value, str):
            return False
        keyword1 = 'المعرفة'
        has_keyword1 = keyword1 in value
        keyword2 = 'الخيال'
        has_keyword2 = keyword2 in value
        is_plausibly_arabic = False
        for char in value:
            char_code = ord(char)
            if 1536 <= char_code <= 1791:
                is_plausibly_arabic = True
                break
        return has_keyword1 and has_keyword2 and is_plausibly_arabic



class DataIdx228InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_228')

    def check_following(self, value):
        """Checks if the response is formatted in bold and italic using common markdown syntax.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        valid_wrappers = [('***', '***'), ('**_', '_**'), ('_*', '*_'), ('*__', '__*'), ('__*', '*__'), ('___', '___')]
        for start, end in valid_wrappers:
            if value.startswith(start) and value.endswith(end):
                if len(value) > len(start) + len(end):
                    return True
        return False



class DataIdx229InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_229')

    def check_following(self, value):
        """Checks if the response uses the word "أرفض" exactly once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        count = value.count('أرفض')
        return count == 1



class DataIdx230InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_230')

    def check_following(self, value):
        """Checks if the response is a short story (around 100 words) starting with 'كان يا ما كان...'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        required_start = 'كان يا ما كان...'
        if not value.strip().startswith(required_start):
            if not value.lstrip().startswith(required_start):
                return False
        words = value.split()
        word_count = len(words)
        min_words = 80
        max_words = 120
        if not min_words <= word_count <= max_words:
            return False
        return True



class DataIdx231InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_231')

    def check_following(self, value):
        """Checks if the response is a numbered list with at least 3 items.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        numbered_item_count = 0
        numbered_pattern = re.compile('^\\s*\\d+\\s*[\\.\\):]')
        for line in lines:
            if numbered_pattern.match(line):
                numbered_item_count += 1
        return numbered_item_count >= 3



class DataIdx232InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_232')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 232.

        Instructions:
        - One sentence expressing gratitude for a service.
        - Use the word 'امتنان'.
        - Enclosed in double quotes.
        - Divided into two parts: 'الشكر' and 'السبب'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if not (value.startswith('"') and value.endswith('"')):
            return False
        inner_content = value[1:-1]
        if not inner_content:
            return False
        if 'امتنان' not in inner_content:
            return False
        shukr_label = 'الشكر:'
        sabab_label = 'السبب:'
        shukr_idx = inner_content.find(shukr_label)
        sabab_idx = inner_content.find(sabab_label)
        if shukr_idx == -1 or sabab_idx == -1 or shukr_idx >= sabab_idx:
            return False
        part1_start = shukr_idx + len(shukr_label)
        part2_start = sabab_idx + len(sabab_label)
        if inner_content[part1_start:sabab_idx].strip() == '':
            return False
        if inner_content[part2_start:].strip() == '':
            return False
        enders = ['.', '!', '?']
        stripped_inner = inner_content.rstrip()
        if not stripped_inner:
            return False
        if stripped_inner[-1] not in enders:
            return False
        content_before_last_char = stripped_inner[:-1]
        if any((char in enders for char in content_before_last_char)):
            return False
        return True



class DataIdx233InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_233')

    def check_following(self, value):
        """Checks if the value is a sentence in the future tense and not a question.
        Uses heuristics for future tense detection in Arabic.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not value or value.strip() == '':
            return False
        if value.strip().endswith('؟'):
            return False
        has_sawfa = 'سوف' in value
        has_sa_prefix = False
        arabic_letter_range_start = ord('ء')
        arabic_letter_range_end = ord('ي')
        punctuation_to_strip = '.,!?;:()«»"\' '
        words = value.split()
        for word in words:
            cleaned_word = word.strip(punctuation_to_strip)
            if cleaned_word.startswith('س') and len(cleaned_word) > 1:
                next_char = cleaned_word[1]
                next_char_code = ord(next_char)
                if arabic_letter_range_start <= next_char_code <= arabic_letter_range_end:
                    has_sa_prefix = True
                    break
        if not (has_sawfa or has_sa_prefix):
            return False
        return True



class DataIdx234InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_234')

    def check_following(self, value):
        """Checks if the response is a single Arabic question starting with 'هل'
        and containing 'التاريخ', ending with a question mark.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if cleaned_value.count('?') != 1:
            return False
        if not cleaned_value.startswith('هل'):
            return False
        if 'التاريخ' not in cleaned_value:
            return False
        if not cleaned_value.endswith('?'):
            return False
        return True



class DataIdx235InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_235')

    def check_following(self, value: str) -> bool:
        """Checks if the response follows the constraints for IDX 235.
        Constraints:
        1. Instructions are in numbered steps.
        2. Includes at least 7 steps.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.strip().split('\n')
        step_count = 0
        for line in lines:
            stripped_line = line.strip()
            if not stripped_line:
                continue
            i = 0
            while i < len(stripped_line) and stripped_line[i].isdigit():
                i += 1
            if i > 0:
                j = i
                while j < len(stripped_line) and stripped_line[j].isspace():
                    j += 1
                if j < len(stripped_line) and stripped_line[j] in ('.', ')'):
                    step_count += 1
        return step_count >= 7



class DataIdx236InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_236')

    def check_following(self, value):
        """
        Checks if the response is a short play scene in Arabic for two characters,
        formatted in Markdown using headings for character names.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        word_like_tokens = value.split()
        arabic_char_pattern = re.compile('[\\u0600-\\u06FF]')
        arabic_token_count = 0
        for token in word_like_tokens:
            if arabic_char_pattern.search(token):
                arabic_token_count += 1
        if arabic_token_count < 10:
            return False
        lines = value.strip().split('\n')
        character_names = set()
        potential_character_line_pattern = re.compile('^#{1,6}\\s*(.+)\\s*$')
        line_idx = 0
        found_any_character_heading = False
        while line_idx < len(lines):
            line = lines[line_idx].strip()
            match = potential_character_line_pattern.match(line)
            if match:
                found_any_character_heading = True
                char_name = match.group(1).strip()
                if not char_name:
                    return False
                character_names.add(char_name)
                dialogue_found_immediately_after = False
                temp_idx = line_idx + 1
                while temp_idx < len(lines):
                    next_line = lines[temp_idx].strip()
                    if not next_line:
                        temp_idx += 1
                        continue
                    if potential_character_line_pattern.match(next_line):
                        return False
                    else:
                        dialogue_found_immediately_after = True
                        break
                if not dialogue_found_immediately_after:
                    return False
                line_idx += 1
            else:
                line_idx += 1
        if not found_any_character_heading:
            return False
        if len(character_names) == 2:
            return True
        else:
            return False



class DataIdx237InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_237')

    def check_following(self, value):
        """Checks if the response describes a pet, uses question marks, and avoids the word 'cute'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        has_question_mark = '?' in value or '؟' in value
        avoids_cute = 'لطيف' not in value
        return has_question_mark and avoids_cute



class DataIdx238InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_238')

    def check_following(self, value):
        """Checks if the response contains exactly two sentences.
        Args:
            value: A string representing the response.

        Returns:
            True if the response contains exactly two sentences, False otherwise.
        """
        if not isinstance(value, str):
            return False
        parts = re.split('[.!?]+', value)
        sentences = [part.strip() for part in parts if part.strip()]
        return len(sentences) == 2



class DataIdx239InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_239')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 239.

        Args:
            value: A string representing the response (the student's question).

        Returns:
            True if the response follows all instructions, False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value.endswith('?'):
            return False
        words = cleaned_value.split()
        if len(words) > 20:
            return False
        if not cleaned_value.startswith('ما'):
            return False
        for char in value:
            if 'a' <= char <= 'z' or 'A' <= char <= 'Z':
                return False
        return True



class DataIdx240InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_240')

    def check_following(self, value):
        """Checks if the response lists three items separated by semicolons (؛).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        parts = value.split('؛')
        if len(parts) != 3:
            return False
        for part in parts:
            if not part.strip():
                return False
        return True



class DataIdx241InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_241')

    def check_following(self, value):
        """Checks if the response explains the concept in exactly one sentence ending with '.', '!', or '?'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (exactly one sentence ending in punctuation) or False otherwise.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        if not stripped_value:
            return False
        if not (stripped_value.endswith('.') or stripped_value.endswith('!') or stripped_value.endswith('?')):
            return False
        punctuation_count = value.count('.') + value.count('!') + value.count('?')
        return punctuation_count == 1



class DataIdx242InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_242')

    def check_following(self, value):
        """Checks if the response is a list of four items separated by 'و',
        where each item starts with 'ي'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        parts = value.split('و')
        if len(parts) != 4:
            return False
        for part in parts:
            cleaned_part = part.strip()
            if not cleaned_part:
                return False
            if not cleaned_part.startswith('ي'):
                return False
        return True



class DataIdx243InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_243')

    def check_following(self, value):
        """Checks if the response starts with 'هل مللت من...؟' as required by the question.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        required_start = 'هل مللت من...؟'
        if not isinstance(value, str):
            return False
        return value.startswith(required_start)



class DataIdx244InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_244')

    def check_following(self, value):
        """Checks if the response is a single word planet name other than Earth, starting with the letter Alif (أ).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        return value == 'أورانوس'



class DataIdx245InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_245')

    def check_following(self, value):
        """Checks if the response starts with the required phrase.

        Args:
            value: A string representing the response.

        Returns:
            True if the response starts with 'الخليفة الراشدي الأول هو', False otherwise.
        """
        required_prefix = 'الخليفة الراشدي الأول هو'
        return value.strip().startswith(required_prefix)



class DataIdx246InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_246')

    def check_following(self, value):
        """Checks if the response is a yes/no question about traveling by plane using 'مريح'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        cleaned_value = value.strip()
        if not cleaned_value.endswith('؟'):
            return False
        text_without_qm = cleaned_value[:-1].strip()
        if 'مريح' not in text_without_qm:
            if 'مريحة' not in text_without_qm:
                return False
        if 'السفر' not in text_without_qm or 'الطائرة' not in text_without_qm:
            return False
        starts_with_hal = text_without_qm.startswith('هل ')
        starts_with_a = text_without_qm.startswith('أ')
        if not (starts_with_hal or starts_with_a):
            return False
        return True



class DataIdx247InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_247')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 247.
        Constraints:
        1. Single paragraph.
        2. The word 'تعليمات' (instructions) is mentioned at least 4 times.
        3. The paragraph consists of at least 3 sentences.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if '\n\n' in value.strip():
            return False
        cleaned_value = value.replace('\n', ' ').strip()
        if not cleaned_value:
            return False
        word_count = len(re.findall('\\bتعليمات\\b', cleaned_value))
        if word_count < 4:
            return False
        sentence_endings = re.findall('[.!?؟]+', cleaned_value)
        sentences = re.split('[.!?؟]+', cleaned_value)
        valid_sentences = [s.strip() for s in sentences if s.strip()]
        sentence_count = len(valid_sentences)
        if sentence_count < 3:
            return False
        return True



class DataIdx248InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_248')

    def check_following(self, value):
        """Checks if the response is structured as three numbered steps (1, 2, 3 or ١, ٢, ٣).

        The check verifies if the response contains exactly three distinct lines
        that start with a step number (1, 2, or 3, including Arabic numerals ١, ٢, ٣),
        optionally preceded by prefixes like 'الخطوة' or 'step', and optionally
        followed by common separators like ., :, ), ], or -.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the structural numbering and count constraints
            (exactly 3 distinct steps numbered 1, 2, and 3 found at the start of lines)
            or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        identified_steps = {}
        step_line_pattern = re.compile('^[ \\t]*(?:(?:الخطوة|step|الخطوة الأولى|الخطوة الثانية|الخطوة الثالثة)[ \\t]*)?([1-3]|[١-٣])[.:)\\]-]*[ \\t]+.*', re.IGNORECASE)
        for line in lines:
            line = line.strip()
            if not line:
                continue
            match = step_line_pattern.match(line)
            if match:
                number_str = match.group(1)
                if number_str == '١':
                    number = 1
                elif number_str == '٢':
                    number = 2
                elif number_str == '٣':
                    number = 3
                else:
                    try:
                        number = int(number_str)
                    except ValueError:
                        continue
                if 1 <= number <= 3:
                    if number not in identified_steps:
                        identified_steps[number] = line
        return len(identified_steps) == 3 and set(identified_steps.keys()) == {1, 2, 3}



class DataIdx249InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_249')

    def check_following(self, value):
        """Checks if the response lists exactly three distinct goals, assuming each goal is on a separate line.
        It does not check if the goals are personal, measurable, or time-bound due to the complexity of natural language processing
        required for those checks within this framework.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains approximately three non-empty lines, False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().splitlines()
        non_empty_lines = [line.strip() for line in lines if line.strip()]
        return len(non_empty_lines) == 3



class DataIdx250InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_250')

    def check_following(self, value):
        """
        Checks if the response contains any Arabic characters (Unicode range U+0600 to U+06FF).
        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain any Arabic characters, False otherwise.
        """
        if not isinstance(value, str):
            return False
        arabic_start = 1536
        arabic_end = 1791
        for char in value:
            char_ord = ord(char)
            if arabic_start <= char_ord <= arabic_end:
                return False
        return True



class DataIdx251InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_251')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 251.
        Instructions: Write a short dialogue between two people talking about the importance of exercising. The dialogue must include at least one question and one answer from each character.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        text = value.strip()
        if not text:
            return False
        lines = [line.strip() for line in text.split('\n') if line.strip()]
        if len(lines) < 4:
            return False
        keywords = ['رياضة', 'رياضي', 'صحة', 'صحي', 'مهم', 'أهمية', 'ممارسة', 'فوائد', 'جسم', 'قوي', 'نشاط', 'لياقة', 'تمرن', 'تمارين']
        topic_relevant = any((k in text for k in keywords))
        if not topic_relevant:
            return False
        question_count = text.count('?')
        if question_count < 2:
            return False
        answer_lines_count = sum((1 for line in lines if not line.endswith('?')))
        if answer_lines_count < 2:
            return False
        return True



class DataIdx252InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_252')

    def check_following(self, value):
        """Checks if the response is a numbered list of exactly four items,
        sequentially numbered from 1 to 4, with content for each item.
        Handles variations like 1., 1), or just 1 followed by content.
        Requires content after the number/separator. Allows empty lines between items.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        lines = value.strip().split('\n')
        expected_number = 1
        found_items_count = 0
        item_pattern = re.compile('^\\s*(\\d+)\\s*[\\.\\)]?\\s*(.+)$')
        for line in lines:
            stripped_line = line.strip()
            if not stripped_line:
                continue
            match = item_pattern.match(stripped_line)
            if match:
                item_number_str = match.group(1)
                try:
                    item_number = int(item_number_str)
                except ValueError:
                    return False
                if item_number == expected_number:
                    found_items_count += 1
                    expected_number += 1
                    if found_items_count > 4:
                        return False
                else:
                    return False
            else:
                return False
        return found_items_count == 4



class DataIdx253InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_253')

    def check_following(self, value):
        """Checks if the response contains three sentences with specified lengths."""
        if not isinstance(value, str):
            return False
        sentences = re.split('[.!?؟]', value)
        cleaned_sentences = [s.strip() for s in sentences if s.strip()]
        if len(cleaned_sentences) != 3:
            return False
        sentence1 = cleaned_sentences[0]
        sentence2 = cleaned_sentences[1]
        sentence3 = cleaned_sentences[2]

        def count_words(sentence):
            words = sentence.split()
            return len(words)
        word_count1 = count_words(sentence1)
        word_count2 = count_words(sentence2)
        word_count3 = count_words(sentence3)
        SHORT_MAX_WORDS = 7
        MEDIUM_MIN_WORDS = 8
        MEDIUM_MAX_WORDS = 15
        LONG_MIN_WORDS = 16
        is_sentence1_short = word_count1 <= SHORT_MAX_WORDS
        is_sentence2_medium = word_count2 >= MEDIUM_MIN_WORDS and word_count2 <= MEDIUM_MAX_WORDS
        is_sentence3_long = word_count3 >= LONG_MIN_WORDS
        return is_sentence1_short and is_sentence2_medium and is_sentence3_long



class DataIdx254InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_254')

    def check_following(self, value):
        """Checks if the response is a paragraph describing an experience and is at least 50 words long.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        return len(words) >= 50



class DataIdx255InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_255')

    def check_following(self, value):
        """Checks if the response summarizes key points about climate change while using the word 'مناخ' no more than twice.

        Args:
            value: A string representing the response.

        Returns:
            True if the word 'مناخ' appears 2 times or less, False otherwise.
        """
        count = value.count('مناخ')
        return count <= 2



class DataIdx256InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_256')

    def check_following(self, value):
        """Checks if the response includes the words 'طاقة' and 'رفاهية'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response includes both 'طاقة' and 'رفاهية', False otherwise.
        """
        if not isinstance(value, str):
            return False
        contains_طاقة = 'طاقة' in value
        contains_رفاهية = 'رفاهية' in value
        return contains_طاقة and contains_رفاهية



class DataIdx257InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_257')

    def check_following(self, value):
        """Checks if the response is a single direct Yes/No question in Arabic
        about preferring to work in a team or individually.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value.endswith('؟'):
            return False
        if not cleaned_value.startswith('هل'):
            return False
        has_team = any((kw in cleaned_value for kw in ['فريق']))
        has_individual = any((kw in cleaned_value for kw in ['فردي', 'بشكل فردي']))
        has_preference_or_work = any((kw in cleaned_value for kw in ['تفضل', 'تحب', 'العمل', 'تعمل']))
        if not (has_team and has_individual and has_preference_or_work):
            return False
        if cleaned_value.count('؟') > 1:
            return False
        return True



class DataIdx258InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_258')

    def check_following(self, value):
        """Checks if the response contains two paragraphs marked 'الجزء أ' and 'الجزء ب',
        with each paragraph being at least 80 words long.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        part_a_marker = 'الجزء أ'
        part_b_marker = 'الجزء ب'
        start_a_idx = value.find(part_a_marker)
        start_b_idx = value.find(part_b_marker)
        if start_a_idx == -1 or start_b_idx == -1 or start_a_idx >= start_b_idx:
            return False
        paragraph_a_text = value[start_a_idx + len(part_a_marker):start_b_idx].strip()
        paragraph_b_text = value[start_b_idx + len(part_b_marker):].strip()
        if not paragraph_a_text or not paragraph_b_text:
            return False
        words_a = paragraph_a_text.split()
        words_b = paragraph_b_text.split()
        if len(words_a) < 80 or len(words_b) < 80:
            return False
        return True



class DataIdx259InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_259')

    def check_following(self, value):
        """Checks if the response follows the instruction not to use exclamation marks.

        Args:
            value: A string representing the response (motivational speech).

        Returns:
            True if the response does not contain any exclamation marks, False otherwise.
        """
        if isinstance(value, str):
            return '!' not in value
        return False



class DataIdx260InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_260')

    def check_following(self, value):
        """
        Checks if the response follows the constraints:
        1. Exactly four sentences (sentences are assumed to end with . or ?).
        2. No exclamation marks (!).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if '!' in value:
            return False
        sentences = [s for s in re.split('[.?]+', value) if s]
        return len(sentences) == 4



class DataIdx261InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_261')

    def check_following(self, value):
        """Checks if the response is the correct alphabetical ordering of the words: قلم، كتاب، دفتر، ممحاة.

        The correct order is based on the first letter of each word in the Arabic alphabet:
        دفتر (د)
        قلم (ق)
        كتاب (ك)
        ممحاة (م)
        Correct sequence: دفتر, قلم, كتاب, ممحاة.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (correct order) or False otherwise.
        """
        if not isinstance(value, str):
            return False
        correct_sequence = ['دفتر', 'قلم', 'كتاب', 'ممحاة']
        target_string = ' '.join(correct_sequence)
        cleaned_value = value.replace(',', ' ').replace('.', ' ').replace(';', ' ').replace(':', ' ')
        cleaned_value = cleaned_value.strip()
        while '  ' in cleaned_value:
            cleaned_value = cleaned_value.replace('  ', ' ')
        return cleaned_value == target_string



class DataIdx262InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_262')

    def check_following(self, value):
        """Checks if the response starts with 'تحذير:'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response starts with 'تحذير:', False otherwise.
        """
        if not isinstance(value, str):
            return False
        return value.strip().startswith('تحذير:')



class DataIdx263InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_263')
        self.forbidden_words = ['مهم', 'ضروري', 'أساسي', 'حيوي', 'جوهري', 'لازم', 'واجب']

    def check_following(self, value):
        """Checks if the response avoids forbidden words (مهم and common synonyms).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        for word in self.forbidden_words:
            if word in value:
                return False
        return True



class DataIdx264InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_264')

    def check_following(self, value):
        """Checks if the response contains a superlative adjective in Arabic (أفعل pattern).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        afal_pattern = '(ال)?أ[\\u0600-\\u06FF]([\\u064B-\\u0652]*[\\u0600-\\u06FF]){2,}'
        if re.search(afal_pattern, value):
            return True
        else:
            return False



class DataIdx265InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_265')

    def check_following(self, value):
        """Checks if the response is a simple fruit salad recipe in Arabic without imperative verbs.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        response = value.strip()
        if not response:
            return False
        arabic_chars_count = sum((1 for char in response if '\u0600' <= char <= 'ۿ'))
        total_chars = len(response)
        if arabic_chars_count == 0:
            return False
        if total_chars > 25:
            if arabic_chars_count / total_chars < 0.5:
                return False
        if 'سلطة' not in response or 'فواكه' not in response:
            return False
        common_cooking_imperatives = ['اقطع', 'اخلط', 'أضف', 'ضع', 'اسكب', 'زين', 'قشر', 'قلب', 'قدم', 'صب', 'سخن', 'برد', 'قطع', 'افصل', 'ذوب', 'اغسل', 'انقع', 'صف', 'عصر', 'تأكد', 'استخدم', 'تجنب', 'احتفظ', 'صفي', 'اغلي', 'اترك', 'اسلق', 'اغمر', 'غط', 'اتبع']
        cleaned_response = response
        punctuation_to_replace = ',.!?:;،؛؟()[]{}<>«»"\'“”‘’'
        for p in punctuation_to_replace:
            cleaned_response = cleaned_response.replace(p, ' ')
        words = cleaned_response.split()
        for word in words:
            if word in common_cooking_imperatives:
                return False
        return True



class DataIdx266InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_266')

    def check_following(self, value):
        """Checks if the response is the imperative form of the sentence 'يمكنك فتح الباب.'
           put in bold.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is '<b>افتح الباب.</b>', False otherwise.
        """
        expected_response = '<b>افتح الباب.</b>'
        return value == expected_response



class DataIdx267InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_267')

    def check_following(self, value):
        """Checks if the response is a critique of at least 70 words, mentioning positive/negative aspects.
        Focuses primarily on the word count as the most programmatically verifiable constraint.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (at least 70 words), False otherwise.
        """
        words = value.split()
        word_count = len(words)
        return word_count >= 70



class DataIdx268InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_268')
        self.numbered_list_item_pattern = re.compile('^\\s*(\\d+|[٠١٢٣٤٥٦٧٨٩]+)[.\\-)]\\s*(.*)$')
        self.arabic_baa = 'ب'

    def check_following(self, value):
        """Checks if the response is a numbered list of exactly three items,
        where each item starts with the Arabic letter 'ب'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.strip().split('\n')
        found_items_starting_with_baa = 0
        total_valid_list_items = 0
        for line in lines:
            match = self.numbered_list_item_pattern.match(line)
            if match:
                total_valid_list_items += 1
                item_text = match.group(2).strip()
                if item_text and item_text.startswith(self.arabic_baa):
                    found_items_starting_with_baa += 1
        return total_valid_list_items == 3 and found_items_starting_with_baa == 3



class DataIdx269InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_269')

    def check_following(self, value):
        """Checks if the response is a numbered list of 4 items, each ending with the word 'فنية'."""
        lines = value.split('\n')
        stripped_lines = [line.strip() for line in lines if line.strip()]
        if len(stripped_lines) != 4:
            return False
        numbered_list_start_pattern = re.compile('^\\s*\\d+[\\.\\)]\\s+')
        ends_with_word_faniya_pattern = re.compile('\\bفنية$')
        for line in stripped_lines:
            start_match = numbered_list_start_pattern.match(line)
            if not start_match:
                return False
            content_part = line[start_match.end():].rstrip()
            if not ends_with_word_faniya_pattern.search(content_part):
                return False
            faniya_index_in_content = content_part.rfind('فنية')
            part_before_faniya = content_part[:faniya_index_in_content].strip()
            if not part_before_faniya:
                return False
        return True



class DataIdx270InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_270')

    def check_following(self, value):
        """Checks if the response uses 'ولكن' to link two ideas, structurally."""
        if not isinstance(value, str):
            return False
        keyword = 'ولكن'
        if keyword not in value:
            return False
        parts = value.split(keyword)
        if len(parts) < 2:
            return False
        stripped_parts = [part.strip() for part in parts]
        if not stripped_parts[0]:
            return False
        if not stripped_parts[-1]:
            return False
        return True



class DataIdx271InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_271')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 271.
        Instructions:
        1. Write a short story of no less than 120 words about a trip to space.
        2. The story must start with the sentence: "في يوم مشمس، قررت أن أقوم برحلة لا تُنسى."

        Args:
            value: A string representing the response (the story).

        Returns:
            True if the response follows the instructions, False otherwise.
        """
        if not isinstance(value, str):
            return False
        required_start = 'في يوم مشمس، قررت أن أقوم برحلة لا تُنسى.'
        if not value.strip().startswith(required_start):
            return False
        words = value.split()
        word_count = len(words)
        if word_count < 120:
            return False
        return True



class DataIdx272InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_272')

    def check_following(self, value):
        """Checks if the response is one sentence about winter, contains 'بارد', and has no commas.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        if 'بارد' not in value:
            return False
        if ',' in value:
            return False
        terminators = ['.', '!', '?']
        for i in range(len(value) - 1):
            if value[i] in terminators:
                return False
        return True



class DataIdx273InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_273')

    def check_following(self, value):
        """Checks if the response is a single, short, direct interrogative sentence ending with an Arabic question mark.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        if not stripped_value:
            return False
        if not stripped_value.endswith('؟'):
            return False
        MAX_LENGTH = 50
        if len(stripped_value) > MAX_LENGTH:
            return False
        terminators = ['.', '!', '؟']
        final_q_index = stripped_value.rfind('؟')
        if final_q_index > 0:
            for terminator in terminators:
                if terminator in stripped_value[:final_q_index]:
                    return False
        return True



class DataIdx274InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_274')

    def check_following(self, value: str) -> bool:
        """
        Checks if the response contains 5 tips, each starting with a word
        that heuristically appears to be an imperative verb in Arabic.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        tips = [line.strip() for line in value.strip().split('\n') if line.strip()]
        if len(tips) != 5:
            return False
        imperative_starts_patterns = ('ا', 'أ', 'إ', 'ت', 'اس')
        non_verb_starts_patterns = ('ال', 'بال', 'لل', 'كال', 'وبال', 'ولل', 'وكال', 'فبال', 'فلل', 'فكال')
        short_non_verbs = ['و', 'ف', 'ثم', 'في', 'على', 'إلى', 'من', 'عن', 'عند', 'مع', 'بعد', 'قبل', 'يا', 'أي']
        for tip in tips:
            words = tip.split(maxsplit=1)
            if not words:
                return False
            first_word = words[0]
            if first_word in short_non_verbs:
                return False
            starts_with_non_verb_prefix = False
            for prefix in non_verb_starts_patterns:
                if first_word.startswith(prefix):
                    starts_with_non_verb_prefix = True
                    break
            if starts_with_non_verb_prefix:
                return False
            starts_with_imperative_pattern = False
            for pattern in imperative_starts_patterns:
                if first_word.startswith(pattern):
                    starts_with_imperative_pattern = True
                    break
            if not starts_with_imperative_pattern:
                return False
        return True



class DataIdx275InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_275')

    def check_following(self, value):
        """Checks if the response follows the instructions for question IDX 275.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        starts_with_iza = value.strip().startswith('إذا')
        contains_rusoob = 'الرسوب' in value
        words = value.split()
        word_count = len(words)
        is_length_valid = 10 <= word_count <= 15
        return starts_with_iza and contains_rusoob and is_length_valid



class DataIdx276InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_276')

    def check_following(self, value):
        """Checks if the response is a single word and starts with a potential present tense prefix.
        Constraints:
        1. Must be a single word.
        2. Must be a present tense verb in the nominative case.

        Args:
            value: A string representing the response (the word provided by the student).

        Returns:
            True if the response meets the checkable constraints (single word, starts with present tense prefix), False otherwise.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        if not stripped_value or ' ' in stripped_value:
            return False
        present_prefixes = ('ي', 'ت', 'أ', 'ن')
        if not stripped_value.startswith(present_prefixes):
            return False
        return True



class DataIdx277InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_277')

    def check_following(self, value):
        """Checks if the response is a short advertisement text in exactly 22 sentences,
           and each sentence starts with the letter 'س'.
        """
        if not isinstance(value, str):
            return False
        potential_sentences = re.split('[.!?]\\s*', value)
        sentences = [s.strip() for s in potential_sentences if s.strip()]
        if len(sentences) != 22:
            return False
        for sentence in sentences:
            if not sentence:
                return False
            if not sentence.startswith('س'):
                return False
        return True



class DataIdx278InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_278')

    def check_following(self, value):
        """Checks if the response compares paper and electronic books
        by mentioning concepts related to both types and uses the word 'بينما'.
        A semantic check for 'two advantages each' is not performed
        due to limitations of simple string processing.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response likely addresses both book types and uses 'بينما',
            False otherwise.
        """
        paper_keywords = ['الورقي', 'المطبوع', 'الكتاب التقليدي']
        mentions_paper = any((keyword in value for keyword in paper_keywords))
        electronic_keywords = ['الإلكتروني', 'الرقمي', 'الكتاب الرقمي', 'القاريء الإلكتروني']
        mentions_electronic = any((keyword in value for keyword in electronic_keywords))
        uses_whereas = 'بينما' in value
        return mentions_paper and mentions_electronic and uses_whereas



class DataIdx279InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_279')

    def check_following(self, value):
        """Checks if the response is exactly two sentences, where the first is a question
        ending in '؟' and the second is an answer ending in '.', with no exclamation marks used,
        and with content in both sentences.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if '!' in cleaned_value:
            return False
        if cleaned_value.count('؟') != 1:
            return False
        if cleaned_value.count('.') != 1:
            return False
        q_idx = cleaned_value.find('؟')
        p_idx = cleaned_value.find('.')
        if q_idx >= p_idx:
            return False
        if cleaned_value[:q_idx].strip() == '':
            return False
        part_between = cleaned_value[q_idx + 1:p_idx].strip()
        if part_between == '':
            return False
        if cleaned_value[p_idx + 1:].strip() != '':
            return False
        return True



class DataIdx280InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_280')

    def check_following(self, value):
        """Checks if the response correctly spells the given word.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is the correct spelling ('مكتبة'), False otherwise.
        """
        correct_spelling = 'مكتبة'
        return value.strip() == correct_spelling



class DataIdx281InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_281')

    def check_following(self, value):
        """Checks if the response is a list of exactly three items, separated by commas or newlines.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is a list of exactly three items, False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        cleaned_value = value.replace('،', ',')
        items_from_comma = [item.strip() for item in cleaned_value.split(',') if item.strip()]
        if len(items_from_comma) == 3:
            return True
        items_from_newline = [item.strip() for item in value.split('\n') if item.strip()]
        if len(items_from_newline) == 3:
            return True
        return False



class DataIdx282InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_282')

    def check_following(self, value):
        """Checks if the response is an Arabic question about time ending with '?' and containing exactly 5 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        ends_with_question_mark = value.strip().endswith('?')
        words = value.split()
        word_count = len(words)
        has_five_words = word_count == 5
        return ends_with_question_mark and has_five_words



class DataIdx283InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_283')

    def check_following(self, value):
        """Checks if the response is a paragraph about the importance of reading
        with more than twenty words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        words = value.split()
        return len(words) > 20



class DataIdx284InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_284')

    def check_following(self, value):
        """Checks if the response contains only '?', ' ', and '
' and includes at least one '?'."""
        if not isinstance(value, str):
            return False
        if not value:
            return False
        allowed_chars = {'?', ' ', '\n'}
        for char in value:
            if char not in allowed_chars:
                return False
        if '?' not in value:
            return False
        return True



class DataIdx285InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_285')

    def check_following(self, value):
        """Checks if the response is less than 80 words.
        Args:
            value: A string representing the response.

        Returns:
            True if the response has less than 80 words, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.strip().split()
        word_count = len(words)
        return word_count < 80



class DataIdx286InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_286')

    def check_following(self, value):
        """Checks if the response is the Arabic word 'كبير'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is exactly 'كبير' (case-sensitive, after stripping whitespace),
            False otherwise.
        """
        expected_word = 'كبير'
        cleaned_value = value.strip()
        return cleaned_value == expected_word



class DataIdx287InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_287')

    def check_following(self, value):
        """Checks if the response is a descriptive text about a historical city,
        not exceeding 100 words and containing at least three nominal sentences.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count > 100:
            return False
        nominal_sentence_count = 0
        pronouns = {'انا', 'نحن', 'انت', 'انتي', 'انتما', 'انتم', 'انتن', 'هو', 'هي', 'هما', 'هم', 'هن'}
        sentences = re.split('(?<=[.?!؟])\\s*', value.strip())
        sentences = [s.strip() for s in sentences if s.strip()]
        attached_particles = 'وفبكل'
        verb_prefixes = 'يتنس'
        for sentence in sentences:
            sentence_words = sentence.split()
            if not sentence_words:
                continue
            first_word = sentence_words[0]
            cleaned_word = first_word
            while cleaned_word and cleaned_word[0] in attached_particles:
                cleaned_word = cleaned_word[1:]
            is_likely_nominal = False
            if cleaned_word:
                first_char = cleaned_word[0]
                if first_char in 'اأإآ':
                    is_likely_nominal = True
                elif cleaned_word in pronouns:
                    is_likely_nominal = True
                elif first_char not in verb_prefixes:
                    is_likely_nominal = True
            if is_likely_nominal:
                nominal_sentence_count += 1
        if nominal_sentence_count < 3:
            return False
        return True



class DataIdx288InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_288')

    def check_following(self, value):
        """Checks if the response avoids punctuation except for periods at the end of sentences.
        This implementation checks for the presence of any character that is not a letter, digit, space, newline, or period.
        """
        allowed_chars = ' .\n'
        for char in value:
            if char in allowed_chars:
                continue
            if char.isalnum():
                continue
            return False
        return True



class DataIdx289InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_289')

    def check_following(self, value):
        """Checks if the response is between 125 and 145 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return 125 <= word_count <= 145



class DataIdx290InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_290')

    def check_following(self, value):
        """Checks if the response is a short message inviting a friend, ends with a question mark, and is within 50 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        ends_with_question = cleaned_value.endswith('؟')
        words = [word for word in cleaned_value.split() if word]
        word_count = len(words)
        within_word_limit = word_count <= 50
        return ends_with_question and within_word_limit



class DataIdx291InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_291')

    def check_following(self, value):
        """Checks if the response contains bullet points and each point has at least 5 words (Arabic).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.strip().split('\n')
        found_bullet_points = False
        bullet_symbols = ('-', '*', '•', '●', '◦', '+')
        for line in lines:
            stripped_line = line.strip()
            is_bullet = False
            bullet_text = ''
            for symbol in bullet_symbols:
                if stripped_line.startswith(symbol):
                    bullet_text = stripped_line[len(symbol):].lstrip()
                    is_bullet = True
                    break
            if is_bullet:
                found_bullet_points = True
                words = [word for word in bullet_text.split() if word]
                word_count = len(words)
                if word_count < 5:
                    return False
        if not found_bullet_points:
            return False
        return True



class DataIdx292InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('292')

    def check_following(self, value):
        """Checks if the response is a single line question.
        Args:
            value: A string representing the response.

        Returns:
            True if the response is in a single line (contains no newline characters), False otherwise.
        """
        return '\n' not in value



class DataIdx293InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_293')

    def check_following(self, value):
        """Checks if the response contains no punctuation marks.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        punctuation_chars = '،.!:;?"\'()[]{}<>\\/|@#$%^&*_~`+'
        for char in value:
            if char in punctuation_chars:
                return False
        return True



class DataIdx294InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_294')

    def check_following(self, value):
        """Checks if the response adds a question at the end of the specified text.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        required_prefix = 'سيتم إطلاق الإصدار الجديد من التطبيق قريبًا في متجر التطبيقات. سيحتوي على عدد من الميزات الجديدة، بما في ذلك واجهة مستخدم جديدة ودعم للأجهزة الجديدة.'
        if not value.startswith(required_prefix):
            return False
        suffix = value[len(required_prefix):]
        cleaned_suffix = suffix.strip()
        if not cleaned_suffix:
            return False
        if not cleaned_suffix.endswith('؟'):
            return False
        return True



class DataIdx295InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_295')

    def check_following(self, value):
        """Checks if the response is a short dialogue of exactly two sentences,
           identified by splitting after standard sentence-ending punctuation.
        Args:
            value: A string representing the response.

        Returns:
            True if the response contains exactly two identified sentences, False otherwise.
        """
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        parts = re.split('(?<=[.؟!])\\s*', cleaned_value)
        sentences = [p for p in parts if p.strip()]
        return len(sentences) == 2



class DataIdx296InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_296')

    def check_following(self, value):
        """Checks if the response follows the constraints:
        - Minimum 70 words, maximum 90 words.
        - Does not use the word 'طقس'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count < 70 or word_count > 90:
            return False
        forbidden_word = 'طقس'
        normalized_value = value.replace('.', '').replace(',', '').replace('!', '').replace('?', '').replace(':', '').replace(';', '').replace('(', '').replace(')', '')
        normalized_words = normalized_value.split()
        if forbidden_word in normalized_words:
            return False
        if f' {forbidden_word}' in f' {value}' or value.startswith(forbidden_word):
            return False
        return True



class DataIdx297InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('297')

    def check_following(self, value):
        """Checks if the response is a single sentence ending with a punctuation mark.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is a single sentence ending with ., !, or ?, False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        sentence_enders = {'.', '!', '?'}
        if not cleaned_value.endswith(tuple(sentence_enders)):
            return False
        last_char = cleaned_value[-1]
        if last_char in sentence_enders:
            if any((char in sentence_enders for char in cleaned_value[:-1])):
                return False
        return True



class DataIdx298InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_298')

    def check_following(self, value):
        """Checks if the response describes a hobby in more than 100 words and uses the word 'شغف' at least twice.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        min_word_count = 101
        word_count_ok = word_count >= min_word_count
        shaghaf_count = 0
        shaghaf_keyword = 'شغف'
        punctuation = '.,!?;:()«»<>-'
        for word in words:
            cleaned_word = word.strip(punctuation)
            if cleaned_word == shaghaf_keyword:
                shaghaf_count += 1
        min_shaghaf_count = 2
        shaghaf_count_ok = shaghaf_count >= min_shaghaf_count
        return word_count_ok and shaghaf_count_ok



class DataIdx299InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_299')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 299."""
        expected_request = "صف يومًا مثاليًا لك في خمس جمل قصيرة. يجب أن تبدأ كل جملة بكلمة مختلفة. كرر الطلب كلمة بكلمة دون تغيير، ثم قدم إجابتك. يجب ألا تتجاوز إجابتك 25 كلمة. لا تستخدم حرف العطف 'و' في إجابتك."
        if not value.startswith(expected_request):
            return False
        answer = value[len(expected_request):].lstrip()
        if not answer:
            return False
        if 'و' in answer:
            return False
        answer_words = re.findall('\\S+', answer)
        if len(answer_words) > 25:
            return False
        sentences = [s.strip() for s in re.split('[.!?]', answer) if s.strip()]
        if len(sentences) != 5:
            return False
        start_words = []
        for sentence in sentences:
            words = sentence.split()
            if words:
                start_words.append(words[0])
            else:
                return False
        if len(set(start_words)) != 5:
            return False
        return True



class DataIdx300InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_300')

    def check_following(self, value):
        """Checks if the response consists of two paragraphs separated by '---',
        where both paragraphs are non-empty.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction, False otherwise.
        """
        if '---' not in value:
            return False
        parts = value.split('---')
        if len(parts) != 2:
            return False
        paragraph1 = parts[0].strip()
        paragraph2 = parts[1].strip()
        if not paragraph1 or not paragraph2:
            return False
        return True



class DataIdx301InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_301')

    def check_following(self, value):
        """Checks if the response follows the constraints: less than 80 words and no numbers.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count >= 80:
            return False
        for char in value:
            if char.isdigit():
                return False
        return True



class DataIdx302InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_302')

    def check_following(self, value):
        """Checks if the response is a poem about Riyadh with exactly four verses and the word 'ليل' at least twice.

        Args:
            value: A string representing the response (the poem).

        Returns:
            True if the response follows the instruction, False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        non_empty_lines = [line for line in lines if line.strip()]
        if len(non_empty_lines) != 4:
            return False
        if value.count('ليل') < 2:
            return False
        return True



class DataIdx303InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_303')

    def check_following(self, value):
        """Checks if the response (Arabic slogan) follows the constraints:
        1. Does not exceed five words.
        2. Includes the word "قهوة".

        Args:
            value: A string representing the response (the slogan).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        num_words = len(words)
        word_count_ok = num_words <= 5
        includes_coffee = 'قهوة' in value
        return word_count_ok and includes_coffee



class DataIdx304InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_304')

    def check_following(self, value):
        """Checks if the response is an interrogative sentence expressing doubt about news heard,
        containing the word 'حقيقة'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        is_interrogative = value.strip().endswith('?')
        contains_haqiqa = 'حقيقة' in value
        return is_interrogative and contains_haqiqa



class DataIdx305InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_305')

    def check_following(self, value):
        """Checks if the tweet follows the constraints:
        - Contains at least one hashtag
        - Does not exceed 280 characters
        - Does not use exclamation marks

        Args:
            value: A string representing the tweet.

        Returns:
            True if the tweet follows all instructions, False otherwise.
        """
        length_check = len(value) <= 280
        exclamation_check = '!' not in value
        hashtag_found = False
        for word in value.split():
            if word.startswith('#') and len(word) > 1:
                hashtag_found = True
                break
        hashtag_check = hashtag_found
        return length_check and exclamation_check and hashtag_check



class DataIdx306InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_306')

    def check_following(self, value):
        """Checks if the response is a three-line advertisement containing at least one exclamation mark.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.splitlines()
        num_lines = len(lines)
        has_exclamation = '!' in value
        return num_lines == 3 and has_exclamation



class DataIdx307InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_307')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 307.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not (value.startswith('<<') and value.endswith('>>')):
            return False
        inner_text = value[2:-2]
        if not inner_text.strip():
            return False
        words = inner_text.split()
        if len(words) >= 15:
            return False
        return True



class DataIdx308InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_308')

    def check_following(self, value):
        """Checks if the response is a short advertisement for a new product
        not exceeding 60 words and starting with "نقدم لكم...".

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        start_phrase = 'نقدم لكم...'
        if not value.strip().startswith(start_phrase):
            return False
        words = value.split()
        if len(words) > 60:
            return False
        return True



class DataIdx309InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_309')

    def check_following(self, value):
        """Checks if the response follows the instructions for question IDX 309.

        Instructions:
        1. Predict the future of transportation in 50 years.
        2. Use strikethrough text for something you think will not happen.
        3. Write in more than 30 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instructions or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        length_ok = word_count > 30
        strikethrough_used = '~~' in value
        return length_ok and strikethrough_used



class DataIdx310InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_310')
        self.common_imperative_starts = {'اكتب', 'اقرا', 'اذهب', 'اشرب', 'اطبخ', 'انظر', 'اسمع', 'امش', 'ادرس', 'اجلس', 'قف', 'كل', 'قل', 'بع', 'نم', 'سر', 'عد', 'خذ', 'ضع', 'تعلم', 'تذكر', 'تكلم', 'تشارك', 'تسابق', 'استخدم', 'استمع', 'استريح'}
        self.list_marker_regex = re.compile('^\\s*(\\d+[\\.\\)]\\s*|\\*\\s*|-\\s*|\\+\\s*)')

    def check_following(self, value: str) -> bool:
        """
        Checks if the response is a list of five complete sentences in Arabic,
        without using imperative verbs.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().splitlines()
        items = []
        for line in lines:
            cleaned_line = self.list_marker_regex.sub('', line).strip()
            if cleaned_line:
                items.append(cleaned_line)
        if len(items) != 5:
            return False
        for item in items:
            if not item.endswith('.'):
                return False
            words = item.split()
            if not words:
                return False
            first_word = words[0].strip('.,!?;:')
            if first_word in self.common_imperative_starts:
                return False
        return True



class DataIdx311InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_311')

    def check_following(self, value):
        """Checks if the response is a list of 5 points, each starting with 'تزيد'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.strip().split('\n')
        points = [line.strip() for line in lines if line.strip()]
        if len(points) != 5:
            return False
        for point in points:
            if not point.startswith('تزيد'):
                return False
        return True



class DataIdx312InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_312')

    def check_following(self, value):
        """Checks if the response is a formal letter to the school principal about improving facilities.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        recipient_keywords = ['مدير المدرسة', 'السيد المدير', 'إلى مدير المدرسة']
        topic_keywords = ['المرافق المدرسية', 'تحسين المرافق', 'مرافق المدرسة']
        formal_opening_keywords = ['تحية طيبة وبعد', 'السيد المدير المحترم', 'حضرة مدير المدرسة']
        formal_closing_keywords = ['مع خالص الشكر', 'وتفضلوا بقبول فائق الاحترام', 'الاحترام والتقدير', 'المقدم']
        has_recipient = any((kw in value for kw in recipient_keywords))
        has_topic = any((kw in value for kw in topic_keywords))
        has_formal_opening = any((kw in value for kw in formal_opening_keywords))
        has_formal_closing = any((kw in value for kw in formal_closing_keywords))
        return has_recipient and has_topic and has_formal_opening and has_formal_closing



class DataIdx313InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('313')

    def check_following(self, value):
        """Checks if the response is a sentence about education importance,
        less than 8 words, and contains 'مهم' exactly once.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        raw_words = value.split()
        punctuation = '،.!؟؛:'
        cleaned_words = []
        for word in raw_words:
            cleaned_word = word.strip(punctuation)
            if cleaned_word:
                cleaned_words.append(cleaned_word)
        word_count_ok = len(cleaned_words) < 8
        mohem_count = cleaned_words.count('مهم')
        mohem_count_ok = mohem_count == 1
        return word_count_ok and mohem_count_ok



class DataIdx314InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_314')

    def check_following(self, value):
        """Checks if the response uses the word 'الصحة' at least twice.
        Args:
            value: A string representing the response.

        Returns:
            True if the response uses 'الصحة' at least twice, False otherwise.
        """
        word_to_check = 'الصحة'
        count = value.count(word_to_check)
        return count >= 2



class DataIdx315InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_315')

    def check_following(self, value):
        """Checks if the response is a rewritten sentence without the original underlined words.
        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain the original underlined words, False otherwise.
        """
        original_words = ['ازدادت', 'التعليم', 'المجتمعات']
        normalized_value = ' '.join(value.split())
        for word in original_words:
            if word in normalized_value:
                return False
        return True



class DataIdx316InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_316')

    def check_following(self, value):
        """
        Checks if the response is a single paragraph consisting of exactly two sentences.
        Specifically checks if the input string contains exactly two sentences
         based on common sentence-ending punctuation (. ! ?).

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains exactly two sentences based on splitting,
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentences_parts = re.split('[.!?]', value)
        significant_parts = [part for part in sentences_parts if part.strip()]
        return len(significant_parts) == 2



class DataIdx317InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_317')

    def check_following(self, value):
        """Checks if the response (a poem) starts with the required phrase.

        Args:
            value: A string representing the response (the poem).

        Returns:
            True if the response starts with 'في ليلة ظلماء', False otherwise.
        """
        required_start = 'في ليلة ظلماء'
        return value.startswith(required_start)



class DataIdx318InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_318')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 318.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        word_count = len(words)
        if word_count >= 40:
            return False
        if ',' in value:
            return False
        return True



class DataIdx319InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_319')

    def check_following(self, value):
        """Checks if the response includes the word 'اعتذاري' at least once.
        Args:
            value: A string representing the response.

        Returns:
            True if the response includes 'اعتذاري', False otherwise.
        """
        return 'اعتذاري' in value



class DataIdx320InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_320')

    def check_following(self, value):
        """Checks if the response (an Arabic sentence) contains the character 'ع' at least three times.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains 'ع' at least three times, False otherwise.
        """
        ayn_count = value.count('ع')
        return ayn_count >= 3



class DataIdx321InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_321')

    def check_following(self, value):
        """Checks if the response is a single sentence with exactly six words.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        return len(words) == 6



class DataIdx322InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_322')

    def check_following(self, value):
        """Checks if the response contains two paragraphs, each exactly 65 words long.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        paragraphs = re.split('\\s*\\n\\s*\\n\\s*', value)
        paragraphs = [p.strip() for p in paragraphs if p.strip()]
        if len(paragraphs) != 2:
            return False
        para1 = paragraphs[0]
        words1 = para1.split()
        if len(words1) != 65:
            return False
        para2 = paragraphs[1]
        words2 = para2.split()
        if len(words2) != 65:
            return False
        return True



class DataIdx323InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_323')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 323.

        Constraints:
        - Less than 100 words.
        - No punctuation except a single period at the end.
        - Contains the word "إيقاع" at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if 'إيقاع' not in value:
            return False
        allowed_punctuation = '.'
        forbidden_punctuation = ',!?;:"\'()[]{}<>،؛؟«»'
        if not value.endswith(allowed_punctuation):
            return False
        if value.count(allowed_punctuation) != 1:
            return False
        for char in value:
            if char in forbidden_punctuation:
                return False
        words = value.split()
        if len(words) >= 100:
            return False
        return True



class DataIdx324InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_324')
        self.exercise_substrings = ['ممارسة الرياضة', 'الرياضة', 'رياضة', 'تمرين', 'تتمرن', 'لياقتك', 'التمارين', 'يتمرن', 'الجسدية']
        self.benefit_substrings = ['فوائد', 'صحة', 'تحسين', 'تقوية', 'طاقة', 'مفيد', 'مفيدة', 'ينفع', 'لياقة', 'الصحة', 'الذهنية', 'الجسدية']

    def check_following(self, value):
        """Checks if the response is a single question in Classical Arabic about the benefits of exercise,
           starts with 'هل', and ends with '?'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        if not stripped_value:
            return False
        if not stripped_value.startswith('هل'):
            return False
        if not stripped_value.endswith('?'):
            return False
        if stripped_value.count('?') != 1:
            return False
        has_exercise_topic = any((sub in stripped_value for sub in self.exercise_substrings))
        has_benefit_topic = any((sub in stripped_value for sub in self.benefit_substrings))
        if not (has_exercise_topic and has_benefit_topic):
            return False
        return True



class DataIdx325InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('325')

    def check_following(self, value):
        """Checks if the response contains the word 'احتفال' at least twice.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        target_word = 'احتفال'
        count = value.count(target_word)
        return count >= 2



class DataIdx326InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_326')

    def check_following(self, value):
        """Checks if the response is a JSON string containing a single Arabic word (river name) based on the instructions.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        try:
            data = json.loads(value)
        except json.JSONDecodeError:
            return False
        if not isinstance(data, dict):
            return False
        if len(data) != 1:
            return False
        river_name = list(data.values())[0]
        if not isinstance(river_name, str):
            return False
        if not river_name:
            return False
        arabic_characters_regex = re.compile('^[\\u0600-\\u06FF]+$')
        if not arabic_characters_regex.fullmatch(river_name):
            return False
        return True



class DataIdx327InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_327')

    def check_following(self, value):
        """Checks if the response is an Arabic question starting with 'هل' asking about the weather today in Standard Arabic.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value.endswith('?'):
            return False
        if not cleaned_value.startswith('هل'):
            return False
        has_weather_keyword = 'الطقس' in cleaned_value or 'الجو' in cleaned_value
        has_today_keyword = 'اليوم' in cleaned_value
        if not (has_weather_keyword and has_today_keyword):
            return False
        return True



class DataIdx328InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_328')

    def check_following(self, value):
        """Checks if the response lists exactly three points, each starting with 'ازدحام'."""
        if not isinstance(value, str):
            return False
        lines = value.splitlines()
        points = [line.strip() for line in lines if line.strip()]
        if len(points) != 3:
            return False
        required_start = 'ازدحام'
        for point in points:
            if not point.startswith(required_start):
                return False
        return True



class DataIdx329InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_329')

    def check_following(self, value):
        """Checks if the response follows the instructions:
        - Short text message in Lebanese colloquial Arabic inviting a friend for dinner.
        - Does not exceed 30 words.
        - Includes the word 'يلا'.
        - Includes the word 'مطعم'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the objective constraints (word count, keywords), False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count > 30:
            return False
        has_yalla = 'يلا' in value
        has_matam = 'مطعم' in value
        return has_yalla and has_matam



class DataIdx330InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_330')

    def check_following(self, value):
        """Checks if the response is a weekly shopping list with 10 plural/collective items and includes 'طعام'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if 'طعام' not in value:
            return False
        lines = value.splitlines()
        items = [line.strip() for line in lines]
        items = [item for item in items if item]
        if len(items) != 10:
            return False
        forbidden_singular_words = {'تفاحة', 'موزة', 'جزرة', 'طماطم', 'بصلة', 'دجاجة', 'سمكة', 'بيضة', 'خبزة', 'زيتونة', 'التفاحة', 'الموزة', 'الجزرة', 'الطماطم', 'البصلة', 'الدجاجة', 'السمكة', 'البيضة', 'الخبزة', 'الزيتونة'}
        punctuation_to_strip = '.,;!?'
        for item in items:
            words = item.split()
            processed_words = {word.strip(punctuation_to_strip) for word in words if word.strip(punctuation_to_strip)}
            if processed_words.intersection(forbidden_singular_words):
                return False
        return True



class DataIdx331InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_331')

    def check_following(self, value):
        """
        Checks if the response provides exactly five suggestions in a numbered list.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (five items in a numbered list),
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        numbered_item_pattern = re.compile('^\\s*\\d+[\\.\\)\\-]?\\s*\\S+')
        numbered_items_count = 0
        for line in lines:
            if numbered_item_pattern.match(line.strip()):
                numbered_items_count += 1
        return numbered_items_count == 5



class DataIdx332InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_332')

    def check_following(self, value):
        """Check if the response uses 'إذا' in a conditional sentence with two clauses in Arabic."""
        if not isinstance(value, str):
            return False
        value = value.strip()
        itha_pos = value.find('إذا')
        if itha_pos == -1:
            return False
        after_itha = value[itha_pos + len('إذا'):].strip()
        comma_pos_in_after_itha = after_itha.find(',')
        if comma_pos_in_after_itha != -1:
            content_before_comma = after_itha[:comma_pos_in_after_itha].strip()
            content_after_comma = after_itha[comma_pos_in_after_itha + 1:].strip()
            min_content_length = 2
            if len(content_before_comma) > min_content_length and len(content_after_comma) > min_content_length:
                return True
        min_length_after_itha = 15
        if len(after_itha) >= min_length_after_itha:
            return True
        else:
            return False



class DataIdx333InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_333')

    def check_following(self, value):
        """Checks if the response provides three numbered list items in Markdown format,
        each being at least 10 words long.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().splitlines()
        items_content = []
        item_pattern = re.compile('^\\s*\\d+\\.\\s*(.*)')
        for line in lines:
            match = item_pattern.match(line)
            if match:
                content = match.group(1).strip()
                if content:
                    items_content.append(content)
        if len(items_content) != 3:
            return False
        for item_text in items_content:
            words = list(filter(None, item_text.split()))
            if len(words) < 10:
                return False
        return True



class DataIdx334InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_334')

    def check_following(self, value):
        """Checks if the response includes the word "الأهرامات".
        Args:
            value: A string representing the response.

        Returns:
            True if the response includes "الأهرامات", False otherwise.
        """
        required_word = 'الأهرامات'
        return required_word in value



class DataIdx335InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_335')

    def check_following(self, value):
        """Checks if the response uses only short sentences (max 5 words).

        Args:
            value: A string representing the response.

        Returns:
            True if all sentences have 5 words or less, False otherwise.
        """
        sentence_terminators = ['.', '!', '؟']
        sentences = []
        current_sentence = []
        for char in value:
            if char in sentence_terminators:
                sentence = ''.join(current_sentence).strip()
                if sentence:
                    sentences.append(sentence)
                current_sentence = []
            else:
                current_sentence.append(char)
        last_sentence = ''.join(current_sentence).strip()
        if last_sentence:
            sentences.append(last_sentence)
        for sentence in sentences:
            words = sentence.split()
            word_count = len(words)
            if word_count > 5:
                return False
        return True



class DataIdx336InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_336')

    def check_following(self, value):
        """
        Checks if the response is a single sentence of exactly 10 words in Arabic.
        This implementation primarily checks the constraint of having exactly 10 words,
        as word count is the most objectively measurable constraint here.
        It assumes words are separated by whitespace.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        return len(words) == 10



class DataIdx337InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('337')

    def check_following(self, value):
        """Checks if the response contains HTML head tag and at least one link tag.

        Args:
            value: A string representing the response (HTML snippet).

        Returns:
            True if the response contains <head> and at least one <link> or <a> tag,
            False otherwise.
        """
        value_lower = value.lower()
        has_head = '<head>' in value_lower
        has_link = '<link' in value_lower or '<a' in value_lower
        return has_head and has_link



class DataIdx338InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_338')

    def check_following(self, value):
        """Checks if the response is a single question starting with 'كيف' and ending with '؟' about improving writing skills.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        starts_correctly = cleaned_value.startswith('كيف')
        ends_correctly = cleaned_value.endswith('؟')
        question_mark_count = cleaned_value.count('؟')
        is_single_question_mark = question_mark_count == 1
        return starts_correctly and ends_correctly and is_single_question_mark



class DataIdx339InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_339')

    def check_following(self, value):
        """Checks if the response is a single Arabic exclamatory sentence,
        starting with 'ما أجمل', ending with '!', and describing a natural landscape.
        Focuses on verifiable syntactic constraints.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the structural instructions, False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        starts_correctly = cleaned_value.startswith('ما أجمل')
        ends_correctly = cleaned_value.endswith('!')
        sentence_enders = ['.', '؟', '!']
        is_single_sentence = True
        if starts_correctly and ends_correctly:
            content_part = cleaned_value[:-1]
            for ender in sentence_enders:
                if ender in content_part:
                    is_single_sentence = False
                    break
        else:
            return False
        return starts_correctly and ends_correctly and is_single_sentence



class DataIdx340InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_340')

    def check_following(self, value):
        """Checks if the response is a short, direct text message apologizing for being late for an appointment.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        response = value.strip()
        MAX_LENGTH = 100
        if len(response) > MAX_LENGTH:
            return False
        apology_keywords = ['آسف', 'اعتذر', 'بعتذر']
        lateness_keywords = ['تأخير', 'تأخرت', 'متأخر', 'التأخر', 'تأخر']
        found_apology = any((keyword in response for keyword in apology_keywords))
        found_lateness = any((keyword in response for keyword in lateness_keywords))
        if not (found_apology and found_lateness):
            return False
        return True



class DataIdx341InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_341')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 341.
        The response must be a single sentence describing a wildlife documentary,
        contain the words 'طبيعة' and 'مدهش', and end with a period.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if not value.strip().endswith('.'):
            return False
        cleaned_value = value.strip()
        if 'طبيعة' not in cleaned_value:
            return False
        if 'مدهش' not in cleaned_value:
            return False
        value_without_period = cleaned_value[:-1]
        sentence_enders = ['.', '!', '?']
        for char in value_without_period:
            if char in sentence_enders:
                return False
        return True



class DataIdx342InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_342')

    def check_following(self, value):
        """Checks if the response follows the instruction of not using the word "الإنترنت".
        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain the word "الإنترنت", False otherwise.
        """
        forbidden_word = 'الإنترنت'
        return forbidden_word not in value



class DataIdx343InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_343')

    def check_following(self, value):
        """Checks if the response is a review in Arabic with a 5-star emoji rating.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        has_arabic = False
        arabic_chars_count = 0
        for char in value:
            if '\u0600' <= char <= 'ۿ' or 'ݐ' <= char <= 'ݿ':
                has_arabic = True
                arabic_chars_count += 1
        is_arabic_review = has_arabic and len(value) > 20 and (arabic_chars_count > 5)
        star_emoji_count = 0
        star_emojis = {'⭐', '🌟'}
        for char in value:
            if char in star_emojis:
                star_emoji_count += 1
        has_5_stars = star_emoji_count == 5
        is_arabic_enough = arabic_chars_count >= 5
        return is_arabic_enough and has_5_stars and (len(value) > 10)



class DataIdx344InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_344')

    def check_following(self, value):
        """Checks if the response describes the weekend without using any adverbs (ظرف).

        This check uses a heuristic by maintaining a list of common Arabic adverbs
        (ظروف زمان ومكان وبعض الأخرى) and checking if any words in the response
        match these adverbs. This is not a perfect linguistic check as adverbs
        can take various forms or be context-dependent, but it serves as a basic
        constraint check.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response likely contains no common adverbs from the list,
            False otherwise.
        """
        forbidden_adverbs = set(['اليوم', 'غداً', 'أمس', 'الآن', 'أبداً', 'دائماً', 'صباحاً', 'مساءً', 'ليلاً', 'نهاراً', 'فجراً', 'ظهراً', 'عصراً', 'مغرباً', 'عشاءً', 'قبل', 'بعد', 'حين', 'بينما', 'عندما', 'فوق', 'تحت', 'أمام', 'خلف', 'يمين', 'يسار', 'هنا', 'هناك', 'حيث', 'أين', 'حول', 'بين', 'حقاً', 'جداً', 'فقط', 'ربما'])
        translator = str.maketrans('', '', string.punctuation)
        cleaned_text = value.translate(translator)
        words = cleaned_text.split()
        for word in words:
            if word in forbidden_adverbs:
                return False
        return True



class DataIdx345InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_345')

    def check_following(self, value):
        """Checks if the response is in the form of exactly three bullet points.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (exactly 3 bullet points) or False otherwise.
        """
        if not value:
            return False
        lines = value.strip().split('\n')
        bullet_count = 0
        bullet_markers = ['- ', '* ', '+ ']
        for line in lines:
            cleaned_line = line.strip()
            if any((cleaned_line.startswith(marker) for marker in bullet_markers)):
                bullet_count += 1
        return bullet_count == 3



class DataIdx346InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_346')

    def check_following(self, value):
        """Checks if the response is an apology letter in Arabic to a friend,
        containing apology, friend, and reason indicator terms.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        text = value.strip()
        if not text:
            return False
        arabic_script_chars = sum((1 for char in text if '\u0600' <= char <= 'ۿ'))
        total_char_count = len(text)
        min_arabic_chars = 30
        if arabic_script_chars < min_arabic_chars or (total_char_count > 0 and arabic_script_chars / total_char_count < 0.5):
            return False
        apology_keywords = ['أعتذر', 'اعتذار', 'آسف', 'سامحني', 'مسامحة', 'أتأسف', 'أرجو أن تسامحني']
        friend_keywords = ['صديقي', 'يا صديقي', 'عزيزي', 'زميلي']
        reason_keywords = ['أخطأت', 'بسبب', 'لأنني', 'الخطأ', 'الذنب', 'سوء تفاهم', 'تصرفي']
        translator = str.maketrans('', '', string.punctuation)
        cleaned_text = text.translate(translator)
        has_apology_term = any((keyword in cleaned_text for keyword in apology_keywords))
        has_friend_term = any((keyword in cleaned_text for keyword in friend_keywords))
        has_reason_indicator = any((keyword in cleaned_text for keyword in reason_keywords))
        if not (has_apology_term and has_friend_term and has_reason_indicator):
            return False
        return True



class DataIdx347InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_347')

    def check_following(self, value):
        """Checks if the response follows the instructions for question idx_347.

        Constraints:
        1. Must contain the word 'فخر'.
        2. Must contain the word 'إنجاز'.
        3. Must be exactly two sentences.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        has_fakhyr = 'فخر' in value
        has_injaz = 'إنجاز' in value
        sentence_endings = ['.', '!', '?']
        sentence_count = 0
        for char in value:
            if char in sentence_endings:
                sentence_count += 1
        is_two_sentences = sentence_count == 2
        return has_fakhyr and has_injaz and is_two_sentences



class DataIdx348InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_348')

    def check_following(self, value):
        """Checks if the response lists exactly five benefits in a numbered list format.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (five items, numbered list),
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        list_item_pattern = re.compile('^\\s*[\\d٠-٩]+\\s*[\\.\\)\\-\\u066B]\\s*.+')
        lines = value.strip().split('\n')
        item_count = 0
        for line in lines:
            if line.strip() == '':
                continue
            if list_item_pattern.match(line):
                item_count += 1
        return item_count == 5



class DataIdx349InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_349')

    def check_following(self, value):
        """Checks if the response is a valid JSON containing 2 to 4 examples of Arabic dialects.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        try:
            data = json.loads(value)
        except json.JSONDecodeError:
            return False
        if not isinstance(data, list):
            return False
        return 2 <= len(data) <= 4



class DataIdx350InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_350')

    def check_following(self, value):
        """Checks if the response classifies animals into mammals and reptiles, gives at least two examples for each,
           and is more than 30 words long.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count <= 30:
            return False
        requires_mammals = 'ثدييات' in value
        requires_reptiles = 'زواحف' in value
        if not requires_mammals or not requires_reptiles:
            return False
        return True



class DataIdx351InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_351')

    def check_following(self, value):
        """Checks if the response includes mentions of book name, author, and personal opinion.

        Args:
            value: A string representing the response.

        Returns:
            True if the response appears to follow the instructions (includes mentions
            of book, author, and opinion, and has sufficient length), False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        cleaned_value = value.strip()
        if len(cleaned_value) < 50:
            return False
        book_kws = {'كتاب', 'رواية', 'الكتاب', 'الرواية', 'بعنوان', 'قصة'}
        author_kws = {'مؤلف', 'كاتب', 'للمؤلف', 'للكاتب', 'تأليف', 'بقلم'}
        opinion_kws = {'رأيي', 'أعجبني', 'لم يعجبني', 'ممتع', 'مفيد', 'شيّق', 'مثير', 'كان', 'شعرت', 'أرى', 'وجهة نظري', 'تقييمي'}
        has_book_kw = any((kw in cleaned_value for kw in book_kws))
        has_author_kw = any((kw in cleaned_value for kw in author_kws))
        has_opinion_kw = any((kw in cleaned_value for kw in opinion_kws))
        return has_book_kw and has_author_kw and has_opinion_kw



class DataIdx352InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_352')

    def check_following(self, value):
        """Checks if the response contains at least five lines, and each of the first five lines starts with 'سوف'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.strip().split('\n')
        processed_lines = [line.strip() for line in value.split('\n') if line.strip()]
        if len(processed_lines) < 5:
            return False
        for i in range(5):
            if not processed_lines[i].startswith('سوف'):
                return False
        return True



class DataIdx353InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_353')

    def check_following(self, value):
        """Checks if the response (an Arabic story) does not exceed 180 words.

        Args:
            value: A string representing the response (the story).

        Returns:
            True if the response has 180 words or fewer, False otherwise.
        """
        words = value.split()
        word_count = len(words)
        return word_count <= 180



class DataIdx354InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_354')

    def check_following(self, value):
        """Checks if the response represents a list of exactly three items.
        It assumes items are separated by commas or newlines.
        Leading/trailing whitespace and empty items resulting from splits (e.g., trailing comma) are ignored.
        This checker does not verify if the items are actually types of fruits due to lack of external data.

        Args:
            value: A string representing the response.

        Returns:
            True if the response represents a list of exactly three items, False otherwise.
        """
        if not isinstance(value, str):
            return False
        items_raw = re.split('[,\\n]+', value)
        items = [item.strip() for item in items_raw if item.strip()]
        return len(items) == 3



class DataIdx355InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_355')

    def check_following(self, value):
        """Checks if the response is a plural question about the benefits of regular exercise in Arabic.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value.endswith('؟'):
            return False
        if 'فوائد' not in value:
            return False
        if 'الرياضة' not in value and 'رياضة' not in value:
            return False
        return True



class DataIdx356InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_356')

    def check_following(self, value):
        """Checks if the response adds a suitable adverb (ظرف/حال) to the sentence 'يتحدث المحاضر بوضوح'.
        This check verifies if the original core sentence elements are present and if at least one word has been added.

        Args:
            value: A string representing the response.

        Returns:
            True if the response appears to follow the instruction, False otherwise.
        """
        if not isinstance(value, str):
            return False
        original_words = ['يتحدث', 'المحاضر', 'بوضوح']
        original_word_count = len(original_words)
        cleaned_value = re.sub('[.,!?;:"\\\'«»]', '', value)
        cleaned_value = re.sub('\\s+', ' ', cleaned_value).strip()
        response_words = cleaned_value.split()
        response_contains_original_words = all((word in response_words for word in original_words))
        if not response_contains_original_words:
            return False
        if len(response_words) <= original_word_count:
            return False
        return True



class DataIdx357InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_357')

    def check_following(self, value):
        """
        Checks if the response lists the UN official languages in bullet points,
        argues for their importance, and uses a persuasive style.

        It checks for:
        1. Presence of a bulleted list.
        2. Approximately 5 to 6 items in the bulleted list.
        3. Presence of substantial text outside the list items, acting as a proxy
           for introduction, conclusion, or argumentation.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction constraints, False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        lines = value.strip().split('\n')
        bullet_pattern = re.compile('^\\s*[\\*\\-\\•]+\\s+')
        list_item_count = 0
        non_bullet_lines = []
        is_bullet_list_present = False
        for line in lines:
            stripped_line = line.strip()
            if not stripped_line:
                continue
            if bullet_pattern.match(line):
                is_bullet_list_present = True
                list_item_count += 1
                content_after_bullet = bullet_pattern.sub('', line).strip()
                if not content_after_bullet:
                    pass
            else:
                non_bullet_lines.append(stripped_line)
        has_correct_list_structure_and_count = is_bullet_list_present and list_item_count >= 5 and (list_item_count <= 6)
        non_bullet_text_length = sum((len(line) for line in non_bullet_lines))
        min_non_list_chars = 50
        has_sufficient_non_list_text = non_bullet_text_length >= min_non_list_chars
        return has_correct_list_structure_and_count and has_sufficient_non_list_text



class DataIdx358InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_358')

    def check_following(self, value):
        """
        Checks if the response follows the instruction not to use passive voice sentences.
        This implementation performs a simplified check for common passive constructions
        in modern Arabic reports, specifically looking for the patterns "تم ال"
        or "يتم ال" followed by a noun (Masdar).

        Note: This is a heuristic and does not cover all forms of passive voice
        in Arabic, which would require advanced morphological and syntactic analysis.

        Args:
            value: A string representing the response (the report text).

        Returns:
            True if the simplified check finds no such passive constructions,
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        passive_indicators = ['تم ال', 'يتم ال']
        for indicator in passive_indicators:
            if indicator in value:
                return False
        return True



class DataIdx359InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_359')

    def check_following(self, value):
        """Checks if the response consists of exactly 5 sentences.

        Args:
            value: A string representing the response (the story).

        Returns:
            True if the response has exactly 5 sentences, False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentences = re.split('[.!?]+', value)
        valid_sentences = [s.strip() for s in sentences if s.strip()]
        return len(valid_sentences) == 5



class DataIdx360InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_360')

    def check_following(self, value):
        """Checks if the response lists 5 numbered items (1-5), each enclosed in square brackets.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        processed_lines = [line.strip() for line in lines if line.strip()]
        if len(processed_lines) != 5:
            return False
        pattern = re.compile('^(\\d+)\\.\\s*\\[.*\\]$')
        for i, line in enumerate(processed_lines):
            match = pattern.match(line)
            if not match:
                return False
            try:
                number_in_line = int(match.group(1))
            except ValueError:
                return False
            expected_number = i + 1
            if number_in_line != expected_number:
                return False
        return True



class DataIdx361InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_361')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 361.
        - Contains 'تفاؤل' at least once.
        - Must end with 'انطلق!'.
        - Does not use prohibition style (heuristic: does not contain 'لا ت').

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        has_tafaul = 'تفاؤل' in cleaned_value
        ends_with_intaliq_exclamation = cleaned_value.endswith('انطلق!')
        no_prohibition_style = 'لا ت' not in cleaned_value
        return has_tafaul and ends_with_intaliq_exclamation and no_prohibition_style



class DataIdx362InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_362')

    def check_following(self, value):
        """Checks if the response is a dialogue of 2 to 3 lines.

        Args:
            value: A string representing the response.

        Returns:
            True if the response has 2 or 3 non-empty lines, False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        non_empty_lines = [line for line in lines if line.strip()]
        line_count = len(non_empty_lines)
        return 2 <= line_count <= 3



class DataIdx363InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_363')

    def check_following(self, value):
        """Checks if the response uses the word "صحة" at least twice.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        keyword = 'صحة'
        count = value.count(keyword)
        return count >= 2



class DataIdx364InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_364')

    def check_following(self, value):
        """Checks if the response is structured into exactly two paragraphs.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains exactly two non-empty paragraphs,
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        normalized_value = value.replace('\r\n', '\n')
        paragraphs = normalized_value.split('\n\n')
        non_empty_paragraphs = [p.strip() for p in paragraphs if p.strip()]
        return len(non_empty_paragraphs) == 2



class DataIdx365InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_365')

    def check_following(self, value):
        """Checks if the response follows the constraints for question 365.
        Constraints:
        1. Exactly two sentences (implied by structure).
        2. First sentence ends with '...'.
        3. Second sentence starts with 'ثم'.
        4. Ends with a standard sentence terminator (. ! ?).
        5. No other sentence terminators (. ! ?) or '...' within the response except for the specified '...' and the final terminator.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the structural instructions or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        stripped_ending = cleaned_value.rstrip()
        if not stripped_ending:
            return False
        last_char = stripped_ending[-1]
        sentence_terminators = ['.', '!', '?']
        if last_char not in sentence_terminators:
            return False
        final_term_idx_in_cleaned = len(stripped_ending) - 1
        dots_sequence = '...'
        dots_idx = cleaned_value.find(dots_sequence)
        if dots_idx == -1:
            return False
        if cleaned_value.find(dots_sequence, dots_idx + 1) != -1:
            return False
        if dots_idx >= final_term_idx_in_cleaned:
            return False
        before_dots = cleaned_value[:dots_idx]
        if not before_dots:
            return False
        for terminator in sentence_terminators:
            if terminator in before_dots:
                return False
        if dots_sequence in before_dots:
            return False
        after_dots = cleaned_value[dots_idx + len(dots_sequence):]
        second_sentence_part_stripped_leading_ws = after_dots.lstrip()
        thumma_prefix = 'ثم'
        if not second_sentence_part_stripped_leading_ws.startswith(thumma_prefix):
            return False
        after_thumma_content = second_sentence_part_stripped_leading_ws[len(thumma_prefix):]
        if not after_thumma_content.strip():
            return False
        content_to_check = cleaned_value[dots_idx + len(dots_sequence):final_term_idx_in_cleaned]
        for terminator in sentence_terminators:
            if terminator in content_to_check:
                return False
        if dots_sequence in content_to_check:
            return False
        return True



class DataIdx366InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_366')

    def check_following(self, value):
        """Checks if the response is a single sentence and does not contain 'ال'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if 'ال' in value:
            return False
        cleaned_value = value.strip()
        terminal_punctuation = '.!?'
        if cleaned_value and cleaned_value[-1] in terminal_punctuation:
            cleaned_value = cleaned_value[:-1]
        cleaned_value = cleaned_value.strip()
        for punc in terminal_punctuation:
            if punc in cleaned_value:
                return False
        return True



class DataIdx367InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_367')

    def check_following(self, value):
        """Checks if the response is a paragraph with at least 17 sentences.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        sentence_enders = '[.?!؟]+'
        sentences = re.split(sentence_enders, value.strip())
        non_empty_sentences = [s.strip() for s in sentences if s.strip()]
        minimum_sentences = 17
        sentence_count = len(non_empty_sentences)
        return sentence_count >= minimum_sentences



class DataIdx368InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_368')

    def check_following(self, value):
        """Checks if the response is a very short story (max 80 words) as required by the instruction.
        Args:
            value: A string representing the response.

        Returns:
            True if the response has 80 words or less, False otherwise.
        """
        words = value.split()
        word_count = len(words)
        return word_count <= 80



class DataIdx369InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_369')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        sentences = [s.strip() for s in value.split('.') if s.strip()]
        if len(sentences) != 2:
            return False
        if not sentences[0].startswith('القاهرة'):
            return False
        if not sentences[1].startswith('وتعتبر'):
            return False
        return True



class DataIdx370InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_370')

    def check_following(self, value):
        """Checks if the response is a short paragraph not exceeding 45 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (<= 45 words), False otherwise.
        """
        words = value.split()
        return len(words) <= 45



class DataIdx371InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_371')

    def check_following(self, value):
        """Checks if the response lists 5 items separated by exactly '####'."""
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        if len(lines) != 5:
            return False
        for line in lines:
            parts = line.split('####')
            if len(parts) != 2:
                return False
            city = parts[0].strip()
            population = parts[1].strip()
            if not city or not population:
                return False
        return True



class DataIdx372InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_372')

    def check_following(self, value):
        """
        Checks if the value is a non-empty string containing Arabic characters,
        at least one space (suggesting two halves of a verse), and no newlines,
        as a basic structural check for a single Arabic poetic verse.
        Reliable checks for wisdom, meter, or rhyme are not feasible
        with basic string operations.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        cleaned_value = value.strip()
        has_arabic = False
        for char in cleaned_value:
            if '\u0600' <= char <= 'ۿ':
                has_arabic = True
                break
        if not has_arabic:
            return False
        if ' ' not in cleaned_value:
            return False
        if '\n' in value or '\r' in value:
            return False
        return True



class DataIdx373InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_373')

    def check_following(self, value):
        """Checks if the response has exactly 3 sentences and no commas.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the syntactic instructions, False otherwise.
        """
        if not isinstance(value, str) or not value:
            return False
        if ',' in value:
            return False
        parts = re.split('[.!?]', value)
        non_empty_parts = [part for part in parts if part.strip()]
        return len(non_empty_parts) == 3



_color_patterns = {'أبيض': 'white', 'بيضاء': 'white', 'أسود': 'black', 'سوداء': 'black', 'أحمر': 'red', 'حمراء': 'red', 'قرمزي': 'red', 'أزرق': 'blue', 'زرقاء': 'blue', 'سماوي': 'blue', 'نيلي': 'blue', 'أخضر': 'green', 'خضراء': 'green', 'أصفر': 'yellow', 'صفراء': 'yellow', 'بني': 'brown', 'بنية': 'brown', 'برتقالي': 'orange', 'برتقالية': 'orange', 'بنفسجي': 'purple', 'بنفسجية': 'purple', 'وردي': 'pink', 'وردية': 'pink', 'رمادي': 'grey', 'رمادية': 'grey', 'ذهبي': 'gold', 'ذهبية': 'gold', 'فضي': 'silver', 'فضية': 'silver'}
_color_variations = sorted(_color_patterns.keys(), key=len, reverse=True)
_regex_pattern = re.compile('\\b(' + '|'.join((re.escape(v) for v in _color_variations)) + ')\\b')

class DataIdx374InstructionChecker(IFevalSynArInstructions):
    _color_patterns = _color_patterns
    _regex_pattern = _regex_pattern

    def __init__(self):
        super().__init__('idx_374')

    def check_following(self, value):
        """Checks if the response includes at least three different types of colors in Arabic.

        Args:
            value: A string representing the response (paragraph in Arabic).

        Returns:
            True if the response follows the instruction (>= 3 distinct colors), False otherwise.
        """
        if not isinstance(value, str):
            return False
        found_base_colors = set()
        matches = self._regex_pattern.findall(value)
        for match in matches:
            if match in self._color_patterns:
                found_base_colors.add(self._color_patterns[match])
        return len(found_base_colors) >= 3



class DataIdx375InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_375')

    def check_following(self, value):
        """Checks if the response follows the specified format for providing two tips.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        required_start_1 = 'النصيحة الأولى:'
        required_separator = '***'
        required_start_2 = 'النصيحة الثانية:'
        if required_start_1 not in value or required_separator not in value or required_start_2 not in value:
            return False
        try:
            index_1 = value.index(required_start_1)
            index_sep = value.index(required_separator, index_1 + len(required_start_1))
            index_2 = value.index(required_start_2, index_sep + len(required_separator))
            return True
        except ValueError:
            return False



class DataIdx376InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_376')

    def check_following(self, value):
        """Checks if the response is a restaurant review in Arabic,
        mentions "طعام لذيذ" and "خدمة رائعة", and uses at least three adjectives.
        Note: Checking for the third adjective is approximated using a predefined list
        and basic string manipulation due to constraints (no imports).
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        mentions_delicious_food = 'طعام لذيذ' in value
        mentions_great_service = 'خدمة رائعة' in value
        common_adjectives_for_third_check = ['جميل', 'كبير', 'صغير', 'جيد', 'ممتاز', 'نظيف', 'سريع', 'بطيء', 'لطيف', 'سيء', 'قذر', 'جديد', 'قديم', 'لذيذ', 'رائعة']
        arabic_punctuation = '.,!؟؛:'
        words = value.split()
        adjective_count = 0
        found_adjectives = set()
        for word in words:
            clean_word = word.strip(arabic_punctuation)
            if clean_word.endswith('ة'):
                clean_word = clean_word[:-1]
            if clean_word in common_adjectives_for_third_check:
                found_adjectives.add(clean_word)
        uses_at_least_three_adjectives = len(found_adjectives) >= 3
        return mentions_delicious_food and mentions_great_service and uses_at_least_three_adjectives



class DataIdx377InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_377')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 377.

        Constraints:
        1. Write a definition for 'الصداقة'. (Semantic - not checked)
        2. In one sentence. (Structural - weakly checked by limiting punctuation)
        3. Use the word 'الصداقة' twice. (Structural - checked)
        4. Underline the definition. (Structural - checked by presence of '__')

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the structural constraints, False otherwise.
        """
        if not isinstance(value, str):
            return False
        word_to_check = 'الصداقة'
        count_of_word = value.count(word_to_check)
        if count_of_word != 2:
            return False
        if '__' not in value:
            return False
        sentence_terminators = ['.', '!', '?']
        terminator_count = sum((value.count(term) for term in sentence_terminators))
        if terminator_count > 1:
            return False
        return True



class DataIdx378InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_378')

    def check_following(self, value):
        """
        Checks if the response is a short thank you letter containing the word 'تقدير'.

        Args:
            value: A string representing the response (the letter).

        Returns:
            True if the response contains 'تقدير' at least once and is reasonably short,
            False otherwise.
        """
        contains_taqdeer = 'تقدير' in value
        max_length = 200
        is_short = len(value) <= max_length
        return contains_taqdeer and is_short



class DataIdx379InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_379')

    def check_following(self, value):
        """Checks if the response is a single line Arabic verse containing 'شمس' and 'قمر'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        contains_shams = 'شمس' in value
        contains_qamar = 'قمر' in value
        is_single_line = '\n' not in value
        contains_arabic = any(('\u0600' <= char <= 'ۿ' for char in value))
        return contains_shams and contains_qamar and is_single_line and contains_arabic



class DataIdx380InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_380')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        target_word = 'المعرفة'
        count = 0
        punctuation_separators = ',.!?;:"\'()[]{}<>/\\-'
        processed_value = value
        for p in punctuation_separators:
            processed_value = processed_value.replace(p, ' ')
        words = processed_value.split()
        for word in words:
            if word == target_word:
                count += 1
        return count >= 3



class DataIdx381InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_381')

    def check_following(self, value):
        """Checks if the response is a single Arabic sentence mentioning an Arab capital starting with 'ب'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        terminal_punctuations = ['.', '؟', '!']
        if not cleaned_value:
            return False
        if cleaned_value[-1] not in terminal_punctuations:
            return False
        if any((c in cleaned_value[:-1] for c in terminal_punctuations)):
            return False
        required_capitals = ['بغداد', 'بيروت']
        found_capital = False
        for capital in required_capitals:
            if capital in cleaned_value:
                found_capital = True
                break
        if not found_capital:
            return False
        return True



class DataIdx382InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_382')

    def check_following(self, value):
        """Checks if the response is a slogan for a technology company that does not exceed three words and contains the word 'مستقبل'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if 'مستقبل' not in value:
            return False
        words = value.split()
        if len(words) > 3:
            return False
        return True



class DataIdx383InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_383')

    def check_following(self, value):
        """
        Checks if the response follows the instructions for question IDX 383.
        Constraints:
        - Paragraph about feelings on a rainy day (Implicitly checked by checking other constraints)
        - Include atmosphere, sounds, feelings (Implicitly checked)
        - 6 to 8 sentences long.
        - Avoid negative words.

        Args:
            value: A string representing the response paragraph.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not value or not isinstance(value, str):
            return False
        terminators = {'.', '!', '؟'}
        sentence_count = sum((1 for char in value if char in terminators))
        if not 6 <= sentence_count <= 8:
            return False
        negative_terms = ['لا', 'لم', 'لن', 'ليس', 'غير', 'دون', 'بدون', 'صعب', 'حزين', 'سيء', 'مؤلم', 'مشكلة', 'قلق', 'خوف', 'مستحيل', 'لا يستطيع', 'لا يمكن']
        value_lower = value.lower()
        for term in negative_terms:
            if term.lower() in value_lower:
                return False
        return True



class DataIdx384InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_384')

    def check_following(self, value):
        """Checks if the response follows the instruction:
        - Exactly three lines.
        - First line is a question (ends with ?).
        - Second line is a short answer (نعم or لا).
        - Third line is an explanation ending with !.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.strip().split('\n')
        if len(lines) != 3:
            return False
        line1 = lines[0].strip()
        line2 = lines[1].strip()
        line3 = lines[2].strip()
        if not line1.endswith('?'):
            return False
        if line2 not in ['نعم', 'لا']:
            return False
        if not line3.endswith('!'):
            return False
        return True



class DataIdx385InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_385')

    def check_following(self, value):
        """Checks if the response uses a table format with the specified columns.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        required_columns = ['القسم', 'المحتوى', 'المدة الزمنية']
        found_header_row = False
        for line in lines:
            if '|' in line:
                if all((col in line for col in required_columns)):
                    found_header_row = True
                    break
        return found_header_row



class DataIdx386InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_386')

    def check_following(self, value):
        """
        Checks if the response potentially contains at least three descriptive elements,
        approximated by counting segments separated by commas or 'و' after cleaning.
        This is a heuristic due to limitations (no NLP libraries or external dictionaries).
        It primarily works for responses where adjectives are listed using 'و' or ','.
        
        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response likely follows the instruction (contains at least 3
            elements separated by 'و' or ','), False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = re.sub('[.,!?;:،]', '', value)
        cleaned_value = re.sub('\\s+', ' ', cleaned_value).strip()
        if not cleaned_value:
            return False
        segments = re.split('\\s*و\\s*|,\\s*', cleaned_value)
        valid_segments = [segment.strip() for segment in segments if segment.strip()]
        return len(valid_segments) >= 3



class DataIdx387InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_387')

    def check_following(self, value):
        """Checks if the response provides instructions for hand washing, based on keyword presence and length.
           It attempts to adhere to the 'simple instructions for a young child' constraint
           by checking for relevant terms. The 'simple words' constraint is hard to check
           programmatically but is implicitly related to the use of basic handwashing terms.

        Args:
            value: A string representing the response.

        Returns:
            True if the response seems to follow the instruction, False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        key_terms = ['يد', 'ماء', 'صابون', 'اغسل', 'افرك', 'اشطف', 'جفف', 'نظيفة']
        cleaned_value = value.replace('.', '').replace(',', '').replace('!', '').replace('؟', '').replace(':', '').replace('؛', '').replace('\n', ' ').lower()
        cleaned_value = ' '.join(cleaned_value.split())
        terms_found = set()
        for term in key_terms:
            if term in cleaned_value:
                terms_found.add(term)
        min_required_terms = 3
        content_check_passed = len(terms_found) >= min_required_terms
        min_chars = 40
        length_check_passed = len(value.strip()) >= min_chars
        return content_check_passed and length_check_passed



class DataIdx388InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_388')

    def check_following(self, value):
        """
        Checks if the response is a single sentence containing a singular imperative verb
        urging exercise, directed at one person.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        sentence_terminators = ['.', '!', '?']
        terminator_count = 0
        last_char_is_terminator = False
        for i, char in enumerate(cleaned_value):
            if char in sentence_terminators:
                terminator_count += 1
                if i == len(cleaned_value) - 1:
                    last_char_is_terminator = True
        if terminator_count > 1:
            return False
        if terminator_count == 1 and (not last_char_is_terminator):
            return False
        imperative_keywords = ['مارس', 'مارسي', 'تمرن', 'تمرني', 'العب', 'الْعبي', 'اركض', 'ارْكضي', 'امش', 'امشي', 'حافظ', 'حافظي', 'اهتم', 'اهتمي', 'تحرك', 'تحركي']
        has_imperative_keyword = any((keyword in value for keyword in imperative_keywords))
        if not has_imperative_keyword:
            return False
        exercise_keywords = ['الرياضة', 'رياضة', 'التمرين', 'تمرين', 'صحتك', 'صحتكِ', 'جسمك', 'جسمكِ', 'نشاط', 'النشاط', 'بدنك', 'بدنكِ', 'اللياقة', 'لياقة', 'رياضية', 'الرياضية', 'صحة', 'جسم']
        has_exercise_keyword = any((keyword in value for keyword in exercise_keywords))
        if not has_exercise_keyword:
            return False
        return True



class DataIdx389InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_389')

    def check_following(self, value):
        """Checks if the response ends with the required phrase 'في انتظارك'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        required_ending = 'في انتظارك'
        return value.endswith(required_ending)



class DataIdx390InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_390')

    def check_following(self, value):
        """Checks if the response contains a sentence using a simile to describe sadness.
        It specifically looks for the presence of simile particles ('مثل', 'كأن')
        and common words related to sadness.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response likely contains a simile describing sadness, False otherwise.
        """
        simile_particles = ['مثل', 'كأن']
        sadness_words = ['حزن', 'ألم', 'كآبة', 'ثقل', 'ظلمة', 'دمع', 'بكاء', 'ضيق', 'مرير', 'قلب مكسور', 'أسى']
        has_simile_particle = any((particle in value for particle in simile_particles))
        has_sadness_word = any((word in value for word in sadness_words))
        return has_simile_particle and has_sadness_word



class DataIdx391InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_391')

    def check_following(self, value):
        """Checks if the response is a poem about the desert not exceeding 30 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (primarily checking word count), False otherwise.
        """
        words = value.split()
        word_count = len(words)
        return word_count <= 30



class DataIdx392InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_392')

    def check_following(self, value):
        """Checks if the response is a JSON string containing a weather description
           with 'مشمس' and no common sentence punctuation within the string value.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        try:
            data = json.loads(value)
        except json.JSONDecodeError:
            return False
        PUNCTUATION_CHARS_TO_EXCLUDE = set('.,!?;:')
        keyword = 'مشمس'

        def find_string_values(item):
            string_values = []
            if isinstance(item, str):
                string_values.append(item)
            elif isinstance(item, dict):
                for v in item.values():
                    string_values.extend(find_string_values(v))
            elif isinstance(item, list):
                for element in item:
                    string_values.extend(find_string_values(element))
            return string_values
        all_strings = find_string_values(data)
        found_valid_string = False
        for s in all_strings:
            if keyword in s:
                has_punctuation = any((char in PUNCTUATION_CHARS_TO_EXCLUDE for char in s))
                if not has_punctuation:
                    found_valid_string = True
                    break
        return found_valid_string



class DataIdx393InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_393')

    def check_following(self, value):
        """Checks if the response (poetry) contains no punctuation marks.

        Args:
            value: A string representing the response (two lines of poetry).

        Returns:
            True if the response follows the instruction (no punctuation), False otherwise.
        """
        if not isinstance(value, str):
            return False
        punctuation_chars = set('!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~،؛؟٫٬')
        for char in value:
            if char in punctuation_chars:
                return False
        return True



class DataIdx394InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_394')

    def check_following(self, value):
        """Checks if the response is a paragraph with at least 30 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        return len(words) >= 30



class DataIdx395InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_395')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 395.

        Constraints:
        1. Must be a numbered list.
        2. Must list exactly three types of fruits.
        3. Each fruit name must start with the letter 'الميم' (م), considering 'ال' prefix.
        4. The word 'فاكهة' must be used at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if 'فاكهة' not in value:
            return False
        list_item_pattern = re.compile('^\\s*\\d+[\\.\\-]\\s*(.*)$', re.MULTILINE)
        matches = list_item_pattern.findall(value)
        if len(matches) != 3:
            return False
        meem_char = 'م'
        al_prefix = 'ال'
        for item_content in matches:
            stripped_item = item_content.strip()
            if not stripped_item:
                return False
            starts_with_meem = stripped_item.startswith(meem_char)
            starts_with_al_and_meem = stripped_item.startswith(al_prefix) and len(stripped_item) > len(al_prefix) and stripped_item[len(al_prefix):].lstrip().startswith(meem_char)
            if not (starts_with_meem or starts_with_al_and_meem):
                return False
        return True



class DataIdx396InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_396')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 396.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        request_string = 'اكتب جملة واحدة تصف فيها شعورك اليوم. يجب أن تتضمن الجملة كلمة "رائع". لا تستخدم أي حروف عطف (مثل و، أو، لكن). يجب أن تكون الجملة طويلة قدر الإمكان.'
        value_trimmed = value.strip()
        if not value_trimmed.startswith(request_string):
            return False
        answer_part_raw = value_trimmed[len(request_string):]
        answer_part = answer_part_raw.strip()
        if not answer_part:
            return False
        if 'رائع' not in answer_part:
            return False
        if re.search('\\b(أو|لكن)\\b', answer_part):
            return False
        if re.search('\\bو\\w+', answer_part):
            return False
        if not (answer_part.endswith('.') or answer_part.endswith('؟') or answer_part.endswith('!')):
            return False
        terminator_count = answer_part.count('.') + answer_part.count('؟') + answer_part.count('!')
        if terminator_count != 1:
            return False
        return True



class DataIdx397InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_397')

    def check_following(self, value):
        """
        Checks if the response is an Arabic question starting with 'هل',
        ending with '؟', has a body, and structured to expect a 'نعم' answer
        (by not containing common negation markers).
        """
        if not isinstance(value, str) or not value.strip():
            return False
        cleaned_value = value.strip()
        if not cleaned_value.startswith('هل'):
            return False
        if not cleaned_value.endswith('؟'):
            return False
        if len(cleaned_value) < len('هل') + len('؟') + 1:
            return False
        question_body = cleaned_value[len('هل'):len(cleaned_value) - len('؟')].strip()
        if not question_body:
            return False
        negation_found = False
        if ' ليس' in f' {question_body}' or question_body.startswith('ليس'):
            negation_found = True
        if ' لا' in question_body:
            negation_found = True
        forms_of_laysa_other = ['لست', 'ليست', 'لسنا', 'لستم', 'لستن', 'ليسوا']
        if any((f' {form}' in f' {question_body}' for form in forms_of_laysa_other)):
            negation_found = True
        if negation_found:
            return False
        return True



class DataIdx398InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_398')

    def check_following(self, value):
        """Checks if the response describes a historical event in one paragraph,
        mentions date and key figures, and does not exceed 80 words.

        Constraints:
        1. One paragraph
        2. Mention date
        3. Mention key figures
        4. Not exceed 80 words

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        cleaned_value = value.strip()
        words = re.split('\\s+', cleaned_value)
        words = [word for word in words if word]
        word_count = len(words)
        if word_count == 0 or word_count > 80:
            return False
        if '\n\n' in cleaned_value or cleaned_value.count('\n') > 3:
            return False
        date_keywords = ['عام', 'سنة', 'تاريخ']
        has_year = bool(re.search('\\d{4}', cleaned_value))
        has_any_number = bool(re.search('\\d', cleaned_value))
        has_date_keyword = any((keyword in cleaned_value for keyword in date_keywords))
        if not (has_year or (has_any_number and has_date_keyword)):
            return False
        figure_keywords_arabic = ['شخصيات', 'قادة', 'زعماء', 'ملوك', 'رؤساء', 'شخصية', 'الشخصيات الرئيسية', 'زعيم', 'قائد', 'ملك', 'رئيس', 'الشخصيات', 'القادة', 'الزعماء', 'الملوك', 'الرؤساء', 'الشخصية', 'الرئيس', 'الملك', 'القائد', 'الزعيم']
        has_figure_keyword = any((keyword in cleaned_value for keyword in figure_keywords_arabic))
        if not has_figure_keyword:
            return False
        return True



class DataIdx399InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_399')

    def check_following(self, value):
        """Checks if the response describes an abstract painting using only long sentences.
        A sentence is considered long if it contains at least 15 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not value or not isinstance(value, str):
            return False
        potential_sentences = re.split('[.?!؟]+', value)
        sentences = [s.strip() for s in potential_sentences if s.strip()]
        if not sentences:
            return False
        long_sentence_threshold = 15
        for sentence in sentences:
            words = sentence.split()
            word_count = len(words)
            if word_count < long_sentence_threshold:
                return False
        return True



class DataIdx400InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_400')

    def check_following(self, value):
        """Checks if the response is exactly one riddle with the answer 'الكتاب'.

        This implementation assumes the answer is presented using a specific format
        like 'الإجابة: الكتاب' or 'Answer: الكتاب' following the riddle text.
        It checks for exactly one occurrence of a common answer marker followed by 'الكتاب'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        pattern = '(الإجابة:|الجواب:|الحل:|Answer:)\\s*الكتاب'
        pattern_to_count = '(?:الإجابة|الجواب|الحل|Answer):\\s*الكتاب'
        matches = re.findall(pattern_to_count, value)
        return len(matches) == 1



class DataIdx401InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_401')

    def check_following(self, value):
        """Checks if the response follows the instruction not to use the word 'أنا'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        return value.find('أنا') == -1



class DataIdx402InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_402')

    def check_following(self, value):
        """Checks if the response is a birthday greeting in Arabic colloquial language.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        value_str = value.strip()
        birthday_indicators = ['عيد ميلاد', 'سنة حلوة', 'عقبال', 'ينعاد عليك', 'كل عام وأنت بخير', 'كل عام', 'مبروك العمر', 'عمر مديد']
        for indicator in birthday_indicators:
            if indicator in value_str:
                return True
        return False



class DataIdx403InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_403')

    def check_following(self, value):
        """
        Checks if every word in the response starts with the character 'ل'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        trimmed_value = value.strip()
        if not trimmed_value:
            return False
        words = trimmed_value.split()
        for word in words:
            if not word or word[0] != 'ل':
                return False
        return True



class DataIdx404InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_404')

    def check_following(self, value):
        """
        Checks if the response is a single Arabic interrogative sentence
        starting with 'لماذا' and asking about the reason for the train's delay.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        if not stripped_value.endswith('؟'):
            return False
        if '.' in stripped_value[:-1]:
            return False
        if '!' in stripped_value[:-1]:
            return False
        if '؟' in stripped_value[:-1]:
            return False
        if not stripped_value.startswith('لماذا'):
            return False
        if 'القطار' not in stripped_value:
            return False
        delay_keywords_found = False
        for keyword in ['تأخر', 'تأخير', 'متأخر', 'متأخرة']:
            if keyword in stripped_value:
                delay_keywords_found = True
                break
        if not delay_keywords_found:
            return False
        return True



class DataIdx405InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_405')

    def check_following(self, value):
        """Checks if the response consists of exactly three sentences.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        segments = re.split('[.!?]+', cleaned_value)
        non_empty_segments = [s.strip() for s in segments if s.strip()]
        return len(non_empty_segments) == 3



class DataIdx406InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_406')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        text = value.strip()
        if not text:
            return True
        text_normalized = text.replace('!', '.').replace('؟', '.')
        sentences = [s for s in text_normalized.split('.') if s.strip()]
        sentence_count = len(sentences)
        return sentence_count <= 5



class DataIdx407InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_407')

    def check_following(self, value):
        if not isinstance(value, str):
            return False
        words = value.split()
        all_caps_word_count = 0
        for word in words:
            latin_alpha_chars = ''
            for char in word:
                char_ord = ord(char)
                if char_ord >= 65 and char_ord <= 90 or (char_ord >= 97 and char_ord <= 122):
                    latin_alpha_chars += char
            if latin_alpha_chars:
                is_all_latin_upper = True
                for char in latin_alpha_chars:
                    if ord(char) >= 97 and ord(char) <= 122:
                        is_all_latin_upper = False
                        break
                if is_all_latin_upper:
                    all_caps_word_count += 1
        return all_caps_word_count == 1



class DataIdx408InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_408')

    def check_following(self, value):
        """Checks if the response is an Arabic sentence expressing happiness and containing two synonymous words for happiness.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        happiness_synonyms = ['سعادة', 'فرح', 'بهجة', 'سرور', 'ابتهاج', 'غبطة', 'حبور', 'مرح']
        found_synonyms = set()
        for synonym in happiness_synonyms:
            if synonym in value:
                found_synonyms.add(synonym)
        return len(found_synonyms) >= 2



class DataIdx409InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_409')

    def check_following(self, value):
        """Checks if the response (Arabic paragraph) does not contain any commas.
        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain any commas, False otherwise.
        """
        if ',' in value:
            return False
        else:
            return True



class DataIdx410InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_410')

    def check_following(self, value):
        """Checks if the response is brief and concise as required by the instruction.
        The instruction asks for a brief and clear explanation of 'Supply and Demand',
        stating the answer must be concise and direct. This check primarily
        enforces the 'brief' and 'concise' aspect by checking the length.
        It does not check for clarity, correctness, or directness of the content itself.

        Args:
            value: A string representing the response.

        Returns:
            True if the response's length is within a predefined limit for brevity,
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        max_length = 400
        return len(value) <= max_length



class DataIdx411InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_411')

    def check_following(self, value):
        """Checks if the response is a numbered list of exactly three items.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is a numbered list (1., 2., 3. or 1), 2), 3))
            with exactly three items, False otherwise.
        """
        lines = value.strip().splitlines()
        non_empty_lines = [line.strip() for line in lines if line.strip()]
        if len(non_empty_lines) < 3:
            return False
        patterns = [re.compile('^1[\\.\\)]\\s*.+'), re.compile('^2[\\.\\)]\\s*.+'), re.compile('^3[\\.\\)]\\s*.+')]
        for i in range(3):
            if i >= len(non_empty_lines) or not patterns[i].match(non_empty_lines[i]):
                return False
        if len(non_empty_lines) > 3:
            if re.match('^\\d+[\\.\\)]\\s*.+', non_empty_lines[3]):
                return False
        return True



class DataIdx412InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_412')

    def check_following(self, value):
        """Checks if the response is a summary with a concluding sentence expressing opinion.
           Heuristically checks for minimum length and presence of at least two sentences,
           as a summary is expected to be more than one sentence and a concluding sentence
           is added afterwards.
        Args:
            value: A string representing the response.

        Returns:
            True if the response likely follows the instruction, False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        min_length = 50
        if len(value.strip()) < min_length:
            return False
        sentences = []
        temp_sentence = ''
        sentence_terminators = '.!؟'
        for char in value:
            temp_sentence += char
            if char in sentence_terminators:
                sentences.append(temp_sentence.strip())
                temp_sentence = ''
        if temp_sentence.strip():
            sentences.append(temp_sentence.strip())
        sentences = [s for s in sentences if s]
        if len(sentences) < 2:
            return False
        return True



class DataIdx413InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_413')

    def check_following(self, value):
        """Checks if the response is a short advertisement for an inkless pen,
        including a two-word product name, a key feature, and a price.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        text = value.strip()
        MIN_CHARS = 50
        MAX_CHARS = 600
        if not MIN_CHARS <= len(text) <= MAX_CHARS:
            return False
        two_word_name_pattern = '\\b[\\u0600-\\u06FF]+\\s+[\\u0600-\\u06FF]+\\b'
        name_found = bool(re.search(two_word_name_pattern, text))
        if not name_found:
            return False
        feature_keywords = ['لا ينفد حبره', 'بدون حبر', 'حبر لا ينفد', 'لا يحتاج حبر', 'لا ينتهي حبره', 'قلم بلا حبر']
        feature_found = any((keyword in text for keyword in feature_keywords))
        if not feature_found:
            return False
        price_found = bool(re.search('\\d+', text))
        if not price_found:
            return False
        return True



class DataIdx414InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_414')

    def check_following(self, value):
        """Checks if the response is a short story not exceeding 100 words and uses at least three exclamation marks.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        word_count = len(words)
        word_count_ok = word_count <= 100
        exclamation_count = value.count('!')
        exclamation_count_ok = exclamation_count >= 3
        return word_count_ok and exclamation_count_ok



class DataIdx415InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_415')

    def check_following(self, value):
        """Checks if the response is a sentence in the passive voice (Arabic).

        Args:
            value: A string representing the response (Arabic sentence).

        Returns:
            True if the response follows the instruction (appears to contain a passive form) or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        arabic_words = re.findall('[\\u0600-\\u06FF]+', value)
        if not arabic_words:
            return False
        common_passive_verbs_list = {'كتب', 'فتح', 'علم', 'شرب', 'اكل', 'اخذ', 'سئل', 'فهم', 'سمع', 'رئي', 'جمع', 'عرف', 'قيل', 'بيع', 'سيق', 'عيد', 'عوقب', 'سلم', 'كرم', 'نظف', 'عومل', 'شوهد', 'اكرم', 'اقام', 'انزل', 'اعيد', 'ارسل', 'تسلم', 'تكسر', 'تعومل', 'اجتمع', 'اكتشف', 'استخدم', 'استعمل', 'استخرج', 'استشهد', 'يكتب', 'يفتح', 'يعلم', 'يشرب', 'يؤكل', 'يؤخذ', 'يسأل', 'يفهم', 'يسمع', 'يرى', 'يجمع', 'يعرف', 'يقال', 'يباع', 'يساق', 'يعاد', 'يعاقب', 'يسلم', 'يكرم', 'ينظف', 'يعامل', 'يشاهد', 'يكرم', 'يقام', 'ينزل', 'يعاد', 'يرسل', 'يتسلم', 'يتكسر', 'يتعامل', 'يجتمع', 'يكتشف', 'يستخدم', 'يستعمل', 'يستخرج', 'يستشهد'}
        for word in arabic_words:
            if word.startswith('است') and len(word) >= 6:
                return True
            if word.startswith('يست') and len(word) >= 6:
                return True
            if word.startswith('تست') and len(word) >= 6:
                return True
            if word.startswith('ا') and len(word) == 4:
                return True
            if word in common_passive_verbs_list:
                return True
        return False



class DataIdx416InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_416')

    def check_following(self, value):
        """Checks if the response provides exactly three distinct rephrased sentences.
        Args:
            value: A string representing the response, expected to contain three rephrased sentences.

        Returns:
            True if the response contains three parts separated by newlines or dots, False otherwise.
        """
        parts_newline = [line.strip() for line in value.strip().split('\n')]
        non_empty_parts_newline = [part for part in parts_newline if part]
        if len(non_empty_parts_newline) == 3:
            return True
        lines = value.strip().split('\n')
        non_empty_lines = [line.strip() for line in lines if line.strip()]
        return len(non_empty_lines) == 3



class DataIdx417InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_417')

    def check_following(self, value):
        """Checks if the response is a short text message inviting a friend to lunch tomorrow,
        not exceeding 30 words, and containing 'غداء' and 'غداً'.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        word_count = len(words)
        if word_count > 30:
            return False
        if 'غداء' not in value:
            return False
        if 'غداً' not in value:
            return False
        return True



class DataIdx418InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_418')

    def check_following(self, value):
        """Checks if the response is a simple fruit salad recipe with at least 4 fruits and no 'ثم'.

        Args:
            value: A string representing the response (the recipe).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if 'ثم' in value:
            return False
        fruit_names = ['تفاح', 'موز', 'فراولة', 'عنب', 'برتقال', 'مانجو', 'كيوي', 'أناناس', 'بطيخ', 'شمام', 'كرز', 'توت']
        found_fruits = set()
        for fruit in fruit_names:
            if re.search('\\b' + re.escape(fruit) + '\\b', value):
                found_fruits.add(fruit)
        if len(found_fruits) < 4:
            return False
        return True



class DataIdx419InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_419')

    def check_following(self, value):
        """Checks if the response follows the instruction: write nothing if understood, write 'لم أفهم' if not understood.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is empty/whitespace or exactly 'لم أفهم', False otherwise.
        """
        if not value.strip():
            return True
        if value == 'لم أفهم':
            return True
        return False



class DataIdx420InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_420')

    def check_following(self, value):
        """Checks if the response follows the instruction for IDX 420.

        The instruction requires a single sentence in Modern Standard Arabic
        expressing wishes for the future, with NO punctuation marks.
        This automated check focuses solely on the punctuation constraint,
        as checking for "single sentence", "Fusha", or "wishes for the future"
        reliably from string content alone is beyond simple string checks.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains no punctuation marks, False otherwise.
        """
        forbidden_punctuation = set('. , ; : ! ? ( ) [ ] { } " \' - – — / \\ * & # @ % ^ ~ < > = + | ، ؛ ؟ ٪ ٫ ٬ … ‘ ’ “ ”')
        if not isinstance(value, str):
            return False
        for char in value:
            if char in forbidden_punctuation:
                return False
        return True



class DataIdx421InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_421')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 421.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        normalized_value = value.strip().replace('\r\n', '\n')
        if not normalized_value:
            return False
        parts = normalized_value.split('\n\n')
        if len(parts) != 3:
            return False
        for i, part in enumerate(parts):
            if not part.strip():
                return False
            lines_in_part = part.split('\n')
            if any((line.strip() == '' for line in lines_in_part)):
                return False
        paragraph2 = parts[1]
        count_sustainability = paragraph2.count('الاستدامة')
        if count_sustainability < 2:
            return False
        return True



class DataIdx422InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('422')

    def check_following(self, value):
        """Checks if the response follows the constraints for question 422.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if not value.strip().startswith('في كل صباح'):
            return False
        common_verbs = {'أستيقظ', 'أنهض', 'أغسل', 'أتناول', 'أشرب', 'أرتدي', 'أذهب', 'أقرأ', 'أصلي', 'أستعد', 'أنظف', 'أمشط', 'أفرش', 'أفتح', 'أبدأ', 'أفطر', 'أتوضأ', 'أغادر', 'أمارس'}
        cleaned_value = value
        punctuation_to_remove = string.punctuation + '،'
        for p in punctuation_to_remove:
            cleaned_value = cleaned_value.replace(p, ' ')
        words = set(cleaned_value.split())
        found_verbs = set()
        for verb in common_verbs:
            if verb in words:
                found_verbs.add(verb)
            elif f'و{verb}' in words:
                found_verbs.add(verb)
        verb_count = len(found_verbs)
        if verb_count < 4:
            return False
        return True



class DataIdx423InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_423')

    def check_following(self, value):
        """Checks if the response describes a historical city, uses sensory description,
           and mentions at least three historical elements, and is in a paragraph format.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response appears to follow the instructions, False otherwise.
        """
        min_length = 80
        if not isinstance(value, str) or len(value.strip()) < min_length:
            return False
        historical_terms = {'قلعة', 'آثار', 'متحف', 'قصر', 'مسجد', 'كنيسة', 'سوق', 'سور', 'معلم', 'مبنى', 'مدينة تاريخية', 'معلم تاريخي', 'مبانٍ قديمة', 'أسوار قديمة', 'سوق قديم', 'مسجد تاريخي', 'كنيسة تاريخية', 'شارع قديم', 'حقبة تاريخية', 'قرن', 'تاريخ'}
        cleaned_value = re.sub('[^\\w\\s]', ' ', value)
        cleaned_value = re.sub('\\s+', ' ', cleaned_value).strip()
        words = set(cleaned_value.split())
        found_historical_elements_types = set()
        single_word_terms = {term for term in historical_terms if ' ' not in term}
        multi_word_terms = {term for term in historical_terms if ' ' in term}
        for term in single_word_terms:
            if term in words:
                found_historical_elements_types.add(term)
        value_to_search_phrases = value
        for term in multi_word_terms:
            if term in value_to_search_phrases:
                found_historical_elements_types.add(term)
        mentions_at_least_three_elements = len(found_historical_elements_types) >= 3
        return len(value.strip()) >= min_length and mentions_at_least_three_elements



class DataIdx424InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_424')

    def check_following(self, value):
        """Checks if the response has a word count between 190 and 280 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the word count is within the specified range (190-280), False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return 190 <= word_count <= 280



class DataIdx425InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_425')

    def check_following(self, value):
        """Checks if the response is a short message inviting a friend to visit
        The National Museum, ensuring the museum name is included.

        Args:
            value: A string representing the response.

        Returns:
            True if the response includes the required museum name, False otherwise.
        """
        required_museum_name = 'المتحف الوطني'
        if required_museum_name in value:
            return True
        else:
            return False



class DataIdx426InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_426')

    def check_following(self, value):
        """
        Checks if the response is exactly 4 sentences long.
        Assumes sentences are terminated by '.', '!', or '?'.
        Counts the number of sentence-ending punctuation marks.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains exactly 4 sentence-ending punctuation marks, False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentence_enders = ['.', '!', '?']
        count = sum((value.count(end) for end in sentence_enders))
        return count == 4



class DataIdx427InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_427')

    def check_following(self, value):
        """Checks if the response is a dialogue meeting the constraints:
        - At least 6 lines.
        - Contains at least one question mark (Arabic or Latin).
        Checking if it's specifically between two people or about hobbies is not feasible
        with simple string checks.

        Args:
            value: A string representing the response (the dialogue).

        Returns:
            True if the response meets the line count and question requirements,
            False otherwise.
        """
        lines = value.splitlines()
        min_lines_met = len(lines) >= 6
        question_present = '؟' in value or '?' in value
        return min_lines_met and question_present



class DataIdx428InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_428')

    def check_following(self, value):
        """Checks if the response provides a name in bold markdown format.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not value or not isinstance(value, str):
            return False
        bold_matches = re.findall('\\*\\*(.*?)\\*\\*', value)
        for match in bold_matches:
            if match.strip():
                return True
        return False



class DataIdx429InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_429')

    def check_following(self, value):
        """Checks if the response is a math puzzle that uses the addition (+) operation at least once.
        The primary check is for the presence of the '+' character in the response string.

        Args:
            value: A string representing the response (the student's math puzzle).

        Returns:
            True if the response string contains the '+' character, False otherwise.
        """
        if value is None:
            return False
        return '+' in value



class DataIdx430InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_430')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 430.
        Constraints:
        - Must include the word 'تكنولوجيا' at least three times.
        - Other constraints (topic, style) are not checked programmatically here as they are subjective or require complex NLP.

        Args:
            value: A string representing the response.

        Returns:
            True if the response includes 'تكنولوجيا' at least 3 times, False otherwise.
        """
        if not isinstance(value, str):
            return False
        technology_count = value.count('تكنولوجيا')
        return technology_count >= 3



class DataIdx431InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_431')

    def check_following(self, value):
        """Checks if the response follows the constraints:
        1. Max 30 words.
        2. Includes time information (heuristic).
        3. Includes place information (heuristic).

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count > 30:
            return False
        text = value
        time_indicators = ['الساعة', 'وقت', 'مساء', 'صباح', 'ظهراً', 'ليلاً', 'العصر', 'المغرب', 'مساءً', 'صباحًا', 'ظهرا', 'ليلا', 'الساعه']
        has_time = any((ind in text for ind in time_indicators))
        if not has_time:
            return False
        place_indicators = ['في', 'مكان', 'منزل', 'بيت', 'مطعم', 'مقهى', 'عند', 'إلى']
        has_place = any((ind in text for ind in place_indicators))
        if not has_place:
            return False
        return True



class DataIdx432InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_432')

    def check_following(self, value):
        """Checks if the response starts with 'عيدكم' and contains 'مبارك' at least three times.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        starts_with_eidkum = value.strip().startswith('عيدكم')
        mubarak_count = value.count('مبارك')
        has_three_mubarak = mubarak_count >= 3
        return starts_with_eidkum and has_three_mubarak



class DataIdx433InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_433')

    def check_following(self, value):
        """Checks if the response is written in the first person (Arabic).
        Args:
            value: A string representing the response (expected to be a poem in Arabic).

        Returns:
            True if the response contains indicators of the first person (انا, نحن, or common suffixes), False otherwise.
        """
        first_person_patterns = '\\b(أنا|نحن|\\w+تُ|\\w+ي|\\w+نا)\\b'
        if re.search(first_person_patterns, value):
            return True
        else:
            return False



class DataIdx434InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_434')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 434.

        Instructions: Provide a brief explanation of 'Artificial Intelligence' in less than fifty words.
        Place your entire explanation between single quotes.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not (value.startswith("'") and value.endswith("'")):
            return False
        content = value[1:-1]
        words = content.strip().split()
        return len(words) < 50



class DataIdx435InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_435')

    def check_following(self, value):
        """
        Checks if the response (an Arabic email) includes the word 'حجز' at least once.
        Args:
            value: A string representing the response (the email).

        Returns:
            True if the response includes 'حجز', False otherwise.
        """
        return 'حجز' in value



class DataIdx436InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_436')

    def check_following(self, value):
        """Checks if the response contains two parts separated by '=========='
        and if both parts are non-empty after stripping whitespace.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction regarding structure,
            False otherwise.
        """
        separator = '=========='
        parts = value.split(separator)
        if len(parts) != 2:
            return False
        part1 = parts[0].strip()
        part2 = parts[1].strip()
        if not part1 or not part2:
            return False
        return True



class DataIdx437InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_437')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 437.
        Instructions: Write a brief formal paragraph about the importance of education.
                      Use bullet points for three main points.
                      Mark the most important point with an asterisk (*).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        bullet_points = []
        first_bp_index = -1
        for i, line in enumerate(lines):
            stripped_line = line.strip()
            if stripped_line.startswith(('-', '*', '+')):
                bullet_points.append(stripped_line)
                if first_bp_index == -1:
                    first_bp_index = i
        if len(bullet_points) != 3:
            return False
        asterisk_marked_points = [point for point in bullet_points if '*' in point]
        if len(asterisk_marked_points) != 1:
            return False
        if first_bp_index == 0:
            return False
        else:
            pre_bullet_lines = lines[:first_bp_index]
            pre_bullet_text = ''.join(pre_bullet_lines).strip()
            if not pre_bullet_text:
                return False
        return True



class DataIdx438InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_438')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 438.
        Instructions: Write a paragraph of at least 200 words explaining different article types.
                      Must mention at least three different types and briefly explain characteristics.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count < 200:
            return False
        type_phrases = {'وصفي': ['المقالة الوصفية'], 'تحليلي': ['المقالة التحليلية'], 'جدلي': ['المقالة الجدلية'], 'إقناعي': ['المقالة الإقناعية'], 'سردي': ['المقالة السردية'], 'تفسيري': ['المقالة التفسيرية', 'المقالة التوضيحية'], 'نقدي': ['المقالة النقدية']}
        found_types = set()
        text_to_search = value
        for type_identifier, phrases in type_phrases.items():
            for phrase in phrases:
                if phrase in text_to_search:
                    found_types.add(type_identifier)
                    break
        if len(found_types) < 3:
            return False
        return True



class DataIdx439InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_439')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 439.
        Instructions: Write one sentence wishing someone a happy day.
                      Must start with 'أتمنى' and end with 'سعيد'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value.startswith('أتمنى'):
            return False
        cleaned_for_end_check = cleaned_value.rstrip('.!?').strip()
        if not cleaned_for_end_check.endswith('سعيد'):
            return False
        terminators = ['.', '!', '?']
        remaining_terminators = sum((cleaned_for_end_check.count(t) for t in terminators))
        if remaining_terminators > 0:
            return False
        return True



class DataIdx440InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('440')

    def check_following(self, value):
        """Checks if the response contains the words 'سفر' and 'طائرة' at least twice each.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        safar_count = value.count('سفر')
        taira_count = value.count('طائرة')
        return safar_count >= 2 and taira_count >= 2



class DataIdx441InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_441')

    def check_following(self, value):
        """Checks if the response meets the constraints:
        - At least two sentences.
        - Includes the word 'فخر'.
        - Includes the word 'إنجاز'.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction, False otherwise.
        """
        if not isinstance(value, str):
            return False
        has_fakhr = 'فخر' in value
        has_injaz = 'إنجاز' in value
        sentence_ending_punctuations = ['.', '!', '?']
        has_at_least_two_sentences = any((p in value for p in sentence_ending_punctuations))
        return has_fakhr and has_injaz and has_at_least_two_sentences



class DataIdx442InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_442')

    def check_following(self, value):
        """Checks if the response is a persuasive text about recycling using statistics.

        Args:
            value: A string representing the response.

        Returns:
            True if the response appears to follow the instruction (contains recycling keywords and numbers/percentages),
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        recycling_keywords = ['إعادة التدوير', 'تدوير', 'النفايات', 'البيئة', 'الموارد', 'تلوث', 'قمامة']
        has_recycling_topic = any((keyword in value for keyword in recycling_keywords))
        has_statistics_indicators = any((char.isdigit() or char == '%' for char in value))
        return has_recycling_topic and has_statistics_indicators



class DataIdx443InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_443')

    def check_following(self, value):
        """
        Checks if the response is a single sentence, at least 20 words long,
         and contains the words "الشمس", "البحر", and "الرمال".

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        terminators = ['.', '!', '?']
        terminator_count = sum((value.count(t) for t in terminators))
        is_single_sentence = terminator_count == 1
        words = value.split()
        num_words = len(words)
        is_long_enough = num_words >= 20
        has_shams = 'الشمس' in value
        has_bahr = 'البحر' in value
        has_ramal = 'الرمال' in value
        has_all_words = has_shams and has_bahr and has_ramal
        return is_single_sentence and is_long_enough and has_all_words



class DataIdx444InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_444')

    def check_following(self, value):
        """Checks if the response is a short Arabic message thanking for help.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        contains_arabic = any(('\u0600' <= char <= 'ۿ' for char in value))
        if not contains_arabic:
            return False
        THANKS_KEYWORDS = ['شكر', 'ممتن', 'جزيل الشكر', 'شكرا', 'شكراً', 'أشكر', 'ممتنة']
        HELP_KEYWORDS = ['مساعدة', 'عون', 'دعم', 'وقفت', 'وقوفك', 'ساعدت', 'يعاون', 'جهد', 'فضل']
        thanks_found = any((keyword in value for keyword in THANKS_KEYWORDS))
        help_found = any((keyword in value for keyword in HELP_KEYWORDS))
        if not (thanks_found and help_found):
            return False
        MAX_LENGTH = 300
        is_short = len(value) <= MAX_LENGTH
        if not is_short:
            return False
        return True



class DataIdx445InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_445')

    def check_following(self, value):
        """Checks if the response is a numbered list of exactly 7 items,
        where each item starts with 'من أبرز...'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        required_prefix = 'من أبرز'
        list_item_pattern = re.compile('^\\s*\\d+[\\.\\)]\\s*(.*)$')
        lines = value.strip().splitlines()
        valid_items_content = []
        for line in lines:
            match = list_item_pattern.match(line)
            if match:
                content = match.group(1).strip()
                valid_items_content.append(content)
        if len(valid_items_content) != 7:
            return False
        for item_content in valid_items_content:
            if not item_content.startswith(required_prefix):
                return False
        return True



class DataIdx446InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_446')

    def check_following(self, value):
        """Checks if the response explains the concept of 'Supply and Demand' in five points.

        Args:
            value: A string representing the response.

        Returns:
            True if the response appears to contain exactly 5 non-empty lines, False otherwise.
            This checker primarily verifies the number of points. Checking the content
            (Supply/Demand concept) and brevity requires NLP and is not included.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        non_empty_lines = [line.strip() for line in lines if line.strip()]
        return len(non_empty_lines) == 5



class DataIdx447InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_447')

    def check_following(self, value):
        """Checks if the response lists exactly 7 bullet points starting with '-'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response contains exactly 7 lines that, after stripping leading/trailing whitespace,
            start with '-', and False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.splitlines()
        bullet_point_count = 0
        for line in lines:
            stripped_line = line.strip()
            if stripped_line.startswith('-'):
                bullet_point_count += 1
        return bullet_point_count == 7



class DataIdx448InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_448')

    def check_following(self, value):
        """Checks if the response is a very short story of exactly two sentences,
        ending with a question mark, as per the instructions.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not value or not isinstance(value, str):
            return False
        stripped_value = value.strip()
        if not stripped_value.endswith('?'):
            return False
        if len(stripped_value) < 2:
            return False
        value_before_last = stripped_value[:-1]
        sentence_enders = {'.', '!', '?'}
        internal_enders_count = sum((1 for char in value_before_last if char in sentence_enders))
        return internal_enders_count == 1



class DataIdx449InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_449')

    def check_following(self, value):
        """Checks if the response describes a historical figure without mentioning their name,
           and includes the word 'إنجاز'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if 'إنجاز' not in value:
            return False
        common_historical_names = ['نابليون', 'قيصر', 'الإسكندر', 'غاندي', 'آينشتاين', 'كليوباترا', 'هتلر', 'لينكولن', 'واشنطن', 'تشرشل', 'نلسون مانديلا', 'محمد', 'عيسى', 'موسى', 'إبراهيم']
        for name in common_historical_names:
            if name in value:
                return False
        return True



class DataIdx450InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_450')

    def check_following(self, value):
        """Checks if the response correctly identifies the sentence as correct or provides the correct sentence.
        The original sentence 'إن المعلمين مخلصون في عملهم' is grammatically correct.
        A correct response should either state that the sentence is correct or provide the exact original sentence.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is correct according to the constraints, False otherwise.
        """
        correct_forms = {'إن المعلمين مخلصون في عملهم', 'الجملة صحيحة', 'لا يوجد خطأ', 'صحيحة', 'الجملة لا يوجد فيها خطأ نحوي', 'الجملة صحيحة لا يوجد فيها خطأ نحوي', 'لا يوجد خطأ نحوي في الجملة', 'الجملة صحيحة نحويًا'}
        normalized_value = value.strip()
        return normalized_value in correct_forms



class DataIdx451InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_451')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 451.

        The instructions are:
        1. The description must be in two separate paragraphs.
        2. The two paragraphs must be separated by exactly two empty lines (

).
        3. The second paragraph must start with the word "لكن".

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        parts = value.split('\n\n\n')
        if len(parts) != 2:
            return False
        second_paragraph = parts[1]
        if not second_paragraph.strip().startswith('لكن'):
            return False
        return True



class DataIdx452InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_452')

    def check_following(self, value):
        """Checks if the response follows the instructions: one paragraph only and no exclamation marks.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if '\n\n' in value:
            return False
        if '!' in value:
            return False
        return True



class DataIdx453InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_453')

    def check_following(self, value):
        """Checks if the response has more than five words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response has more than five words, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        return len(words) > 5



class DataIdx454InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_454')

    def check_following(self, value):
        """Checks if the response is a recipe for a traditional Arabic dish,
           at least 150 words long, and includes sections for ingredients,
           preparation method, and serving.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count < 150:
            return False
        normalized_value = value.replace('\n', ' ').replace('\r', ' ')
        has_ingredients = 'المكونات' in normalized_value
        has_preparation = 'طريقة التحضير' in normalized_value
        has_serving = 'تقديم الطبق' in normalized_value
        if not (has_ingredients and has_preparation and has_serving):
            return False
        return True



class DataIdx455InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_455')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 455.
        Instructions:
        - List three things that make you happy.
        - The list must be numbered.
        - The word 'السعادة' (Happiness) must be mentioned at least once in the introduction before the list.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        list_item_pattern = '^\\s*(\\d+|[٠١٢٣٤٥٦٧٨٩]+)[.)].*'
        all_matches = list(re.finditer(list_item_pattern, value, re.MULTILINE))
        if len(all_matches) != 3:
            return False
        first_item_start_index = all_matches[0].start()
        intro_part = value[:first_item_start_index]
        if 'السعادة' not in intro_part:
            return False
        return True



class DataIdx456InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_456')

    def check_following(self, value):
        """Checks if the response consists of exactly two lines.
        Constraints on content and verb types are not checked due to complexity.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is exactly two lines long, False otherwise.
        """
        lines = value.strip().split('\n')
        non_empty_lines = [line for line in lines if line.strip()]
        lines = value.strip().split('\n')
        non_empty_lines = [line for line in lines if line.strip()]
        if len(non_empty_lines) != 2:
            return False
        if not non_empty_lines[0] or not non_empty_lines[1]:
            return False
        return True



class DataIdx457InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_457')

    def check_following(self, value):
        """Checks if the response is an Arabic conditional sentence using 'إن' and containing 'النجاح' to express the outcome of studying hard.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        has_in = 'إن' in value
        has_najah = 'النجاح' in value
        is_not_empty = bool(value and value.strip())
        return has_in and has_najah and is_not_empty



class DataIdx458InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_458')

    def check_following(self, value):
        """Checks if the response is a short, polite, concise email to a colleague requesting the last meeting report.
        
        Checks include:
        1. Length is within a typical range for a short email.
        2. Contains keywords related to requesting the last/previous meeting report.
        3. Contains common polite phrases.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        min_length = 50
        max_length = 250
        if not min_length <= len(cleaned_value) <= max_length:
            return False
        report_last_keywords = ['تقرير الاجتماع الأخير', 'تقرير الاجتماع الاخير', 'تقرير الاجتماع الماضي', 'تقرير الاجتماع السابق', 'تقرير آخر اجتماع']
        request_indicators = ['أحتاج', 'احتاج', 'أرجو', 'ارجو', 'إرسال', 'ارسال', 'يمكنك', 'أود الحصول', 'ارسال لي', 'هل يمكن إرسال', 'هل تستطيع إرسال', 'تزويدي بـ']
        has_report_mention = any((keyword in cleaned_value for keyword in report_last_keywords))
        has_request_indicator = any((indicator in cleaned_value for indicator in request_indicators))
        if not (has_report_mention and has_request_indicator):
            return False
        polite_phrases = ['من فضلك', 'لو سمحت', 'شكرا لك', 'شكراً لك', 'شكرا', 'ممتن لك', 'مع الشكر', 'إذا أمكن', 'فضلاً', 'رجاءً', 'أكون ممتناً', 'مع جزيل الشكر']
        is_polite = any((phrase in cleaned_value for phrase in polite_phrases))
        if not is_polite:
            return False
        return True



class DataIdx459InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_459')

    def check_following(self, value):
        """Checks if the response is a valid title for a CPA resume based on constraints.

        Constraints:
        1. Must include the word 'محترف'.
        2. Must be less than 10 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        has_professional = 'محترف' in value
        words = value.split()
        word_count = len(words)
        is_less_than_10_words = word_count < 10
        return has_professional and is_less_than_10_words



class DataIdx460InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_460')

    def check_following(self, value):
        """Checks if the response follows the instruction.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain exclamation marks, False otherwise.
        """
        if '!' in value:
            return False
        return True



class DataIdx461InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_461')

    def check_following(self, value):
        """Checks if the response contains at least five non-empty lines,
           representing at least five speech exchanges in the dialogue.
        Args:
            value: A string representing the response (the dialogue).

        Returns:
            True if the response follows the instruction (at least 5 exchanges),
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = [line for line in value.strip().split('\n') if line.strip()]
        return len(lines) >= 5



class DataIdx462InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('462')

    def check_following(self, value):
        """Checks if the response includes some indication of the main character's feelings.
           Note: Checking for past tense, ensuring feelings relate to the main character
           during the trip, and using sophisticated language analysis requires advanced NLP
           and is not fully implemented here. This check only verifies the presence of
           common emotion-related keywords or phrases.
        Args:
            value: A string representing the response.

        Returns:
            True if emotion keywords or phrases are found, False otherwise.
        """
        emotion_indicators = ['فرح', 'حزن', 'خوف', 'دهشة', 'إثارة', 'قلق', 'سعادة', 'راحة', 'اندهاش', 'فضول', 'رهبة', 'توتر', 'استرخاء', 'ذهول', 'انبهار', 'ملل', 'إحباط', 'مشاعر', 'شعرت', 'شعور', 'أحسست', 'أحس', 'كنت أشعر', 'شعوري', 'أشعر', 'حسيت']
        return any((indicator in value for indicator in emotion_indicators))



class DataIdx463InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_463')

    def check_following(self, value):
        """Checks if the response is a valid tab-separated CSV with specific columns and at least 4 entries.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.strip().splitlines()
        if len(lines) < 4:
            return False
        header = lines[0].split('\t')
        if len(header) != 2 or header[0] != 'الاسم' or header[1] != 'العمر':
            return False
        for line in lines[1:]:
            cols = line.split('\t')
            if len(cols) != 2:
                return False
        return True



class DataIdx464InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_464')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 464.
        Constraints:
        1. Not exceeding two lines.
        2. Avoid using the word 'جيد' (good).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.strip().splitlines()
        if len(lines) > 2:
            return False
        if re.search('\\bجيد\\b', value):
            return False
        return True



class DataIdx465InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_465')

    def looks_like_recipe_list_item(self, line):
        """Checks if a line looks like a list item (bullet point or numbered)."""
        if re.match('^[\\*\\-\\•]\\s*', line.strip()):
            return True
        if re.match('^\\d+[\\.\\)]\\s*', line.strip()):
            return True
        return False

    def looks_like_recipe_section(self, text, is_ingredients_section):
        """Checks if a paragraph looks like an ingredients or steps section."""
        lines = text.strip().split('\n')
        has_keyword = False
        if is_ingredients_section:
            if 'المكونات' in text or 'المقادير' in text:
                has_keyword = True
        elif 'خطوات' in text or 'طريقة' in text:
            has_keyword = True
        has_list_structure = len(lines) > 1
        if not has_list_structure:
            if len(lines) == 1 and self.looks_like_recipe_list_item(lines[0]):
                has_list_structure = True
        return has_keyword or has_list_structure

    def check_following(self, value):
        """
        Checks if the response:
        1. Is in two separate paragraphs (

 separator).
        2. The first paragraph is for ingredients (contains keyword or looks like a list).
        3. The second paragraph is for steps (contains keyword or looks like a list).
        """
        parts = re.split('\\n\\s*\\n', value.strip())
        if len(parts) != 2:
            return False
        para1 = parts[0].strip()
        para2 = parts[1].strip()
        if not para1 or not para2:
            return False
        is_para1_ingredients_like = self.looks_like_recipe_section(para1, is_ingredients_section=True)
        is_para2_steps_like = self.looks_like_recipe_section(para2, is_ingredients_section=False)
        return is_para1_ingredients_like and is_para2_steps_like



class DataIdx466InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_466')

    def check_following(self, value):
        """Checks if the response is a two-word phrase ending with '!'."""
        if not isinstance(value, str):
            return False
        trimmed_value = value.strip()
        if not trimmed_value.endswith('!'):
            return False
        phrase_without_punct = trimmed_value[:-1].strip()
        words = [word for word in phrase_without_punct.split() if word]
        if len(words) != 2:
            return False
        return True



class DataIdx467InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_467')

    def check_following(self, value):
        """Checks if the response is a short email inviting a classmate to study together,
        without using any numbers.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (no numbers), False otherwise.
        """
        for char in value:
            if char.isdigit():
                return False
        return True



class DataIdx468InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_468')

    def check_following(self, value):
        """Checks if the response lists three items numbered ١, ٢, ٣ and avoids the letter 'و'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if 'و' in value:
            return False
        num1 = '١'
        num2 = '٢'
        num3 = '٣'
        idx1 = value.find(num1)
        idx2 = value.find(num2)
        idx3 = value.find(num3)
        if not (idx1 != -1 and idx2 != -1 and (idx3 != -1) and (idx1 < idx2) and (idx2 < idx3)):
            return False
        return True



class DataIdx469InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_469')

    def check_following(self, value):
        """Checks if the response is a persuasive argument about reading,
           uses 'قراءة' at least twice, and is between 70 and 100 words.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        word_count = len(words)
        if not 70 <= word_count <= 100:
            return False
        keyword = 'قراءة'
        keyword_count = 0
        for word in words:
            cleaned_word = word.strip('.,!?:;؛')
            if cleaned_word == keyword:
                keyword_count += 1
        if keyword_count < 2:
            return False
        return True



class DataIdx470InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_470')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 470.
        Instructions:
        1. Rewrite the sentence into two paragraphs.
        2. Separate paragraphs by exactly three newlines (

).
        3. Second paragraph must contain 'الابتكار' at least twice.
        4. Only periods (.) are allowed as punctuation.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        for char in value:
            if not (char == '.' or char.isspace() or char.isalpha() or char.isdigit()):
                return False
        parts = value.split('\n\n\n')
        if len(parts) != 2:
            return False
        if not parts[0] or not parts[1]:
            return False
        paragraph2 = parts[1]
        innovation_count = paragraph2.count('الابتكار')
        if innovation_count < 2:
            return False
        return True



class DataIdx471InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_471')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 471.
        Constraints:
        - Use '!' at least 3 times.
        - Include the word 'تهاني' at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        has_enough_exclamations = value.count('!') >= 3
        has_congratulations_word = 'تهاني' in value
        return has_enough_exclamations and has_congratulations_word



class DataIdx472InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_472')

    def check_following(self, value):
        """Checks if the response provides two examples of main dishes from Moroccan cuisine
        without using the forbidden words "المغرب" or "مغربي".

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        forbidden_words = ['المغرب', 'مغربي']
        for word in forbidden_words:
            if word in value:
                return False
        return True



class DataIdx473InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_473')

    def check_following(self, value):
        """Checks if the response describes a city in no more than 150 words,
        using the word "نهر" exactly once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count > 150:
            return False
        cleaned_words = []
        punctuation = '.,،؛؟!:'
        pattern = re.compile(f'[{re.escape(punctuation)}]+')
        for word in words:
            cleaned_word = pattern.sub('', word)
            cleaned_words.append(cleaned_word)
        nehir_count = cleaned_words.count('نهر')
        if nehir_count != 1:
            return False
        return True



class DataIdx474InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_474')

    def check_following(self, value: str):
        """
        Checks if the response describes 3 steps using 'أولاً', 'ثم', 'أخيراً' in order.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction, False otherwise.
        """
        firstly_word = 'أولاً'
        then_word = 'ثم'
        finally_word = 'أخيراً'
        firstly_present = firstly_word in value
        then_present = then_word in value
        finally_present = finally_word in value
        if not (firstly_present and then_present and finally_present):
            return False
        firstly_count = value.count(firstly_word)
        then_count = value.count(then_word)
        finally_count = value.count(finally_word)
        if firstly_count != 1 or then_count != 1 or finally_count != 1:
            return False
        try:
            firstly_index = value.find(firstly_word)
            then_index = value.find(then_word)
            finally_index = value.find(finally_word)
            if not firstly_index < then_index < finally_index:
                return False
        except Exception:
            return False
        return True



class DataIdx475InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_475')

    def check_following(self, value):
        """Check if the response is a short poem about the moon and does not contain any commas.

        Args:
            value: A string representing the response (the poem).

        Returns:
            True if the response does not contain a comma, False otherwise.
        """
        if ',' in value:
            return False
        return True



class DataIdx476InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('476')

    def check_following(self, value):
        """Checks if the response follows the instruction: write a short story about a talking animal, not exceeding 50 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not exceed 50 words, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        return len(words) <= 50



class DataIdx477InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_477')

    def check_following(self, value):
        """Checks if the response follows the constraints: 15-20 sentences, no exclamation marks.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if '!' in value:
            return False
        sentences = re.split('[.؟]+|\\.\\.\\.', value)
        sentences = [s.strip() for s in sentences if s.strip()]
        sentence_count = len(sentences)
        if 15 <= sentence_count <= 20:
            return True
        else:
            return False



class DataIdx478InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('478')

    def check_following(self, value):
        """Checks if the response ends with an answer within a single pair of parentheses ()."""
        if not isinstance(value, str) or not value:
            return False
        if not value.endswith(')'):
            return False
        last_open_idx = value.rfind('(')
        if last_open_idx == -1:
            return False
        last_close_idx = len(value) - 1
        if last_open_idx >= last_close_idx - 1:
            return False
        if value[-2] == ')':
            return False
        content = value[last_open_idx + 1:last_close_idx].strip()
        if not content:
            return False
        return True



class DataIdx479InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_479')

    def check_following(self, value):
        """Checks if the response follows the instruction for IDX 479.

        Constraints:
        1. Contains the word 'تقنيات' at least three times.
        2. Does not exceed 45 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        keyword_count = value.lower().count('تقنيات')
        keyword_condition = keyword_count >= 3
        words = value.split()
        word_count = len(words)
        word_count_condition = word_count <= 45
        return keyword_condition and word_count_condition



class DataIdx480InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_480')

    def check_following(self, value):
        lines = value.strip().split('\n')
        valid_items = 0
        non_empty_lines = 0
        for line in lines:
            stripped_line = line.strip()
            if not stripped_line:
                continue
            non_empty_lines += 1
            is_bullet = stripped_line.startswith(('-', '*', '•'))
            content_after_bullet = stripped_line.lstrip('*-•').strip()
            has_content = bool(content_after_bullet)
            if is_bullet and has_content:
                valid_items += 1
        return valid_items >= 10 and valid_items == non_empty_lines



class DataIdx481InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_481')

    def check_following(self, value):
        """
        Checks if the response is a single sentence expressing optimism about the future,
        containing the word 'مشرق' and ending with a single sentence terminator.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if 'مشرق' not in value:
            return False
        sentence_terminators = ['.', '!', '؟']
        stripped_value = value.strip()
        ends_with_terminator = any((stripped_value.endswith(term) for term in sentence_terminators))
        if not ends_with_terminator:
            return False
        terminator_count = sum((value.count(term) for term in sentence_terminators))
        if terminator_count != 1:
            return False
        return True



class DataIdx482InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_482')

    def check_following(self, value):
        """
        Checks if the response is a valid passive voice conversion of "فتح الحارس الباب."
        and includes the word "الباب".

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains "الباب" and a passive form of "فتح", False otherwise.
        """
        if not isinstance(value, str):
            return False
        contains_bab = 'الباب' in value
        contains_futiha_diacritized = 'فُتِحَ' in value
        contains_futiha_undiacritized = 'فُتِح' in value
        return contains_bab and (contains_futiha_diacritized or contains_futiha_undiacritized)



class DataIdx483InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        """Initializes the checker for instruction IDX 483."""
        super().__init__('idx_483')

    def check_following(self, value: str) -> bool:
        """
        Checks if the response string follows the instructions for IDX 483:
        "Write a short thank you message to someone who provided you with a service.
         You must specifically mention the reason for the thank you."

        Args:
            value: A string representing the student's response (Arabic text).

        Returns:
            True if the response follows the instruction constraints, False otherwise.
        """
        if not isinstance(value, str):
            return False
        text = value.strip()
        thank_you_keywords = ['شكرا', 'شكر', 'ممتن', 'ممتنة']
        contains_thank_you = any((keyword in text for keyword in thank_you_keywords))
        if not contains_thank_you:
            return False
        words = text.split()
        word_count = len(words)
        is_short = 5 <= word_count <= 30
        if not is_short:
            return False
        reason_pattern = re.compile('(شكرا|شكر|ممتن|ممتنة)\\s+(?:على|ل|ب|في|بسبب)\\s*\\S+')
        mentions_reason_structure = bool(reason_pattern.search(text))
        return mentions_reason_structure



class DataIdx484InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_484')

    def check_following(self, value):
        """Checks if the response is a text of four paragraphs where the third is the shortest.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        paragraphs = re.split('\\n\\s*\\n+', value)
        cleaned_paragraphs = [p.strip() for p in paragraphs if p.strip()]
        if len(cleaned_paragraphs) != 4:
            return False
        lengths = [len(p) for p in cleaned_paragraphs]
        third_paragraph_length = lengths[2]
        if third_paragraph_length > lengths[0]:
            return False
        if third_paragraph_length > lengths[1]:
            return False
        if third_paragraph_length > lengths[3]:
            return False
        return True



class DataIdx485InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_485')
        self.prohibited_adjectives = {'جميل', 'جميلة', 'جميلون', 'جميلات', 'كبير', 'كبيرة', 'كبار', 'صغير', 'صغيرة', 'صغار', 'جديد', 'جديدة', 'جدد', 'قديم', 'قديمة', 'قدماء', 'واسع', 'واسعة', 'ضيق', 'ضيقة', 'نظيف', 'نظيفة', 'متسخ', 'متسخة', 'هادئ', 'هادئة', 'صاخب', 'صاخبة', 'مشمس', 'مشمسة', 'ممطر', 'ممطرة', 'بارد', 'باردة', 'حار', 'حارة', 'قريب', 'قريبة', 'بعيد', 'بعيدة', 'نشيط', 'نشيطة', 'نشيطون', 'كسول', 'كسولة', 'كسالى', 'مهم', 'مهمة', 'سهل', 'سهلة', 'صعب', 'صعبة', 'سعيد', 'سعيدة', 'سعداء', 'حزين', 'حزينة', 'حزانى', 'سريع', 'سريعة', 'بطيء', 'بطيئة', 'قوي', 'قوية', 'أقوياء', 'ضعيف', 'ضعيفة', 'ضعفاء', 'طويل', 'طويلة', 'طوال', 'قصير', 'قصيرة', 'قصار', 'غني', 'غنية', 'أغنياء', 'فقير', 'فقيرة', 'فقراء', 'حلو', 'حلوة', 'مر', 'مرة', 'نظيف', 'نظيفة', 'قذر', 'قذرة', 'شجاع', 'شجاعة', 'شجعان', 'جبان', 'جبانة', 'جبناء', 'ذكي', 'ذكية', 'أذكياء', 'غبي', 'غبية', 'أغبياء', 'كريم', 'كريمة', 'كرام', 'بخيل', 'بخيلة', 'بخلاء', 'أبيض', 'بيضاء', 'بيض', 'أسود', 'سوداء', 'سود', 'أحمر', 'حمراء', 'حمر', 'أزرق', 'زرقاء', 'زرق', 'أخضر', 'خضراء', 'خضر', 'أصفر', 'صفراء', 'صفر', 'بني', 'بنية', 'رمادي', 'رمادية'}
        self.punctuation_chars = '.,!?;:()[]{}\'"`،؛؟!'

    def check_following(self, value):
        """Checks if the response contains words from a predefined list of common adjectives."""
        if not isinstance(value, str):
            return False
        words = value.split()
        for word in words:
            cleaned_word = word.strip(self.punctuation_chars)
            cleaned_word = cleaned_word.replace('ـ', '').replace('\u200c', '').replace('\u200d', '')
            if cleaned_word in self.prohibited_adjectives:
                return False
        return True



class DataIdx486InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_486')

    def check_following(self, value):
        """Checks if the response is a single declarative sentence announcing a store opening with name and location.
           Programmatically checks for:
           1. Contains exactly one sentence.
           2. The sentence ends with a period ('.') to signify it's declarative.
           3. Does not contain other sentence-ending punctuation ('?', '!').
           (Semantic checks for mentioning store name and location are not included as they require advanced NLP).
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the structural instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        text = value.strip()
        if not text:
            return False
        if '?' in text or '!' in text:
            return False
        if not text.endswith('.'):
            return False
        text_without_last_char = text[:-1]
        if '.' in text_without_last_char:
            return False
        return True



class DataIdx487InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_487')

    def check_following(self, value: str) -> bool:
        """
        Checks if the response follows the instructions for IDX 487.
        Constraints:
        - Formal introduction for a seminar on an economic topic (hard to check).
        - Must welcome attendees (hard to check reliably).
        - Must introduce the main speaker (if there is one).
        - Must highlight the *name of the main speaker* using asterisks.

        Focusing on the most programmatically checkable constraint: highlighting the speaker's name.
        Logic:
        1. Check if any text is enclosed in asterisks (`*...*`). If yes, assume the formatting rule was applied and return True.
        2. If no text is enclosed in asterisks, check if there is a clear pattern of a speaker being introduced without asterisks.
           (e.g., "نرحب بـ الدكتور أحمد", "الآن مع الأستاذة ليلى").
        3. If such an unformatted pattern is found (and no `*...*` was found in step 1), return False (failure: introduced speaker but didn't format).
        4. If no `*...*` was found (step 1) and no unformatted pattern was found (step 3), return True (likely no speaker was introduced, or intro wasn't caught by regex, so formatting rule wasn't violated).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the highlight constraint or False otherwise.
        """
        has_formatted_name = re.search('\\*(.+?)\\*', value)
        if has_formatted_name:
            return True
        unformatted_intro_pattern = re.compile('(?:نرحب بـ|يقدم لنا|الآن مع|ضيفنا|المتحدث الرئيسي|مع سعادة|معالي|الأستاذ|الدكتور|السيدة|السيد)\\s+\\b(?:\\w+\\s*){1,4}\\b')
        has_unformatted_intro = unformatted_intro_pattern.search(value)
        if has_unformatted_intro:
            return False
        else:
            return True



class DataIdx488InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_488')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        target_word = 'المعرفة'
        punctuation = '.,;!?:،؛«»()[]{}<>"\''
        words = value.split()
        count = 0
        for word in words:
            cleaned_word = word.strip(punctuation)
            if cleaned_word == target_word:
                count += 1
        return count >= 4



class DataIdx489InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_489')

    def check_following(self, value):
        """Checks if the response is less than 160 characters.
        Args:
            value: A string representing the response.

        Returns:
            True if the response is less than 160 characters, False otherwise.
        """
        return len(value) < 160



class DataIdx490InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_490')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 490.

        Instructions:
        1. Answer in three separate paragraphs.
        2. Separate each paragraph by exactly one empty line.
        3. The second paragraph must contain the word "تواصل" at least twice.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.split('\n')
        paragraphs = []
        current_paragraph_lines = []
        state = 'start'
        separator_line_count = 0
        for line in lines:
            stripped_line = line.strip()
            if stripped_line:
                if state == 'in_separator':
                    if separator_line_count != 1:
                        return False
                    paragraphs.append('\n'.join(current_paragraph_lines))
                    current_paragraph_lines = [stripped_line]
                    separator_line_count = 0
                    state = 'in_paragraph'
                else:
                    state = 'in_paragraph'
                    current_paragraph_lines.append(stripped_line)
            elif state == 'start':
                pass
            elif state == 'in_paragraph':
                if current_paragraph_lines:
                    paragraphs.append('\n'.join(current_paragraph_lines))
                    current_paragraph_lines = []
                    separator_line_count = 1
                    state = 'in_separator'
                else:
                    pass
            elif state == 'in_separator':
                separator_line_count += 1
        if state == 'in_paragraph':
            if current_paragraph_lines:
                paragraphs.append('\n'.join(current_paragraph_lines))
        if len(paragraphs) != 3:
            return False
        second_paragraph = paragraphs[1]
        target_word = 'تواصل'
        count = 0
        punctuation = '.,!?;:()،؛؟!"\'،؛؟٪٫۔٬۞﴾\\FD3F'
        words = second_paragraph.split()
        for word in words:
            cleaned_word = word.strip(punctuation)
            if cleaned_word == target_word:
                count += 1
        if count < 2:
            return False
        return True



class DataIdx491InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_491')

    def check_following(self, value):
        """Checks if the response starts with a phrase expressing doubt in Arabic.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        doubt_prefixes = ['ربما', 'قد يكون', 'لست متأكداً', 'من الصعب الجزم', 'يعتمد على', 'ليس بالضرورة', 'أشك في أن', 'من الممكن أن', 'ليس واضحاً ما إذا كان']
        cleaned_value = value.strip()
        for prefix in doubt_prefixes:
            if cleaned_value.startswith(prefix):
                return True
        return False



class DataIdx492InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_492')

    def check_following(self, value):
        """Check if the response does not use the word "لكن".

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain the word "لكن", False otherwise.
        """
        return 'لكن' not in value



class DataIdx493InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_493')

    def check_following(self, value):
        """Checks if the response is a nominal sentence preserving the meaning of 'الطفل يلعب في الحديقة'.
        The original sentence is 'الطفل يلعب في الحديقة', which is already a nominal sentence.
        A valid answer should typically start with the subject 'الطفل' and contain the core meaning elements.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value.startswith('الطفل'):
            return False
        action_present = False
        if 'يلعب' in cleaned_value or 'لاعب' in cleaned_value:
            action_present = True
        if not action_present:
            return False
        if 'في الحديقة' not in cleaned_value:
            return False
        return True



class DataIdx494InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_494')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 494.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        line_count_ok = value.count('\n') <= 1
        word_present = 'حصريًا' in value
        exclamation_count_ok = value.count('!') == 1
        return line_count_ok and word_present and exclamation_count_ok



class DataIdx495InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_495')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.replace(',', ' ').replace('.', ' ').replace(';', ' ').replace(':', ' ').replace('!', ' ').replace('?', ' ').strip()
        words = cleaned_value.split()
        keyword_count = words.count('مطعم')
        return keyword_count >= 4



class DataIdx496InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_496')

    def check_following(self, value):
        """Checks if the response is a story about a talking cat that does not exceed 100 words and does not use quotation marks.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if '"' in value:
            return False
        words = value.split()
        word_count = len(words)
        if word_count > 100:
            return False
        return True



class DataIdx497InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_497')

    def check_following(self, value):
        """Checks if the response is a list of exactly 5 points,
        each starting with the Arabic word 'لأن'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.splitlines()
        points = [line.strip() for line in lines if line.strip()]
        if len(points) != 5:
            return False
        required_start_word = 'لأن'
        for point in points:
            if not point.startswith(required_start_word):
                return False
        return True



class DataIdx498InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_498')

    def check_following(self, value):
        """Checks if the response is a short dialogue using question and exclamation marks.
        Args:
            value: A string representing the response (the dialogue).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        has_question_mark = '?' in value
        has_exclamation_mark = '!' in value
        words = value.split()
        word_count = len(words)
        min_word_count = 50
        max_word_count = 250
        is_short_enough = min_word_count <= word_count <= max_word_count
        return has_question_mark and has_exclamation_mark and is_short_enough



class DataIdx499InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_499')

    def check_following(self, value):
        """Checks if the response follows the constraints for IDX 499:
        - At least 3 sentences.
        - No more than 5 sentences.
        - Starts with a question (first sentence ends with '?').
        """
        cleaned_value = value.strip()
        sentences = []
        current_sentence_chars = []
        delimiters = ['.', '?', '!']
        for char in cleaned_value:
            current_sentence_chars.append(char)
            if char in delimiters:
                sentence = ''.join(current_sentence_chars).strip()
                if sentence:
                    sentences.append(sentence)
                current_sentence_chars = []
        num_sentences = len(sentences)
        count_ok = 3 <= num_sentences <= 5
        first_sentence_ok = False
        if num_sentences > 0:
            first_sentence = sentences[0]
            first_sentence_ok = first_sentence.endswith('?')
        return count_ok and first_sentence_ok



class DataIdx500InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_500')

    def check_following(self, value):
        """
        Checks if the response follows the instructions for IDX 500.
        - Must be a single sentence.
        - Must start with 'أتمنى'.
        - Must contain 'توفيق'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        if not stripped_value.startswith('أتمنى'):
            return False
        if 'توفيق' not in stripped_value:
            return False
        terminators = ['.', '!', '?']
        terminator_count = sum((stripped_value.count(t) for t in terminators))
        if terminator_count > 1:
            return False
        return True



class DataIdx501InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_501')

    def check_following(self, value):
        """Checks if the response ends with the word 'جميل'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response ends with 'جميل', False otherwise.
        """
        target_word = 'جميل'
        cleaned_value = value.rstrip()
        return cleaned_value.endswith(target_word)



class DataIdx502InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_502')

    def check_following(self, value):
        """Checks if the response does not contain the Arabic comma character.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain the Arabic comma (،), False otherwise.
        """
        return '،' not in value



class DataIdx503InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_503')

    def check_following(self, value):
        """Checks if the word 'عاجل' appears exactly once in the report.
        Args:
            value: A string representing the response.

        Returns:
            True if 'عاجل' appears exactly once, False otherwise.
        """
        count = value.count('عاجل')
        return count == 1



class DataIdx504InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_504')

    def check_following(self, value):
        """Checks if the response is a poetic sentence about the night.
           Focuses on checking for keywords related to 'night' as 'poetic' and 'sentence' are subjective and hard to automate reliably.
        Args:
            value: A string representing the response.

        Returns:
            True if the response contains keywords related to night, False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        night_keywords = ['ليل', 'نجوم', 'قمر', 'ظلام', 'دجى', 'عتمة', 'سكون', 'هدوء', 'مساء', 'سهر', 'أرق', 'ظلمة', 'ليلى']
        for keyword in night_keywords:
            if keyword in value:
                return True
        return False



class DataIdx505InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_505')

    def check_following(self, value):
        """Checks if the response is a valid JSON itinerary for Beirut focused on culture/art without mentioning nightlife.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        try:
            json.loads(value)
        except json.JSONDecodeError:
            return False
        if 'الحياة الليلية' in value:
            return False
        return True



class DataIdx506InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_506')

    def check_following(self, value):
        """Checks if the response is a single paragraph not exceeding 40 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        if not stripped_value:
            return False
        if '\n\n' in stripped_value:
            return False
        words = [word for word in stripped_value.split() if word]
        if 0 < len(words) <= 40:
            return True
        else:
            return False



class DataIdx507InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_507')

    def check_following(self, value):
        """Checks if the response describes a favorite food dish in detail (at least 160 words) and starts with the dish name.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        trimmed_value = value.strip()
        words = trimmed_value.split()
        word_count = len([word for word in words if word])
        if word_count < 160:
            return False
        forbidden_intros = ['طبقي المفضل', 'أحب طبق', 'الطبق الذي أحب', 'سأصف', 'أتحدث عن', 'وصفي ل', 'وصف ل', 'هذا الطبق يسمى', 'الطبق هو', 'يدعى هذا الطبق', 'يسمى هذا الطبق', 'طبقي المفضل هو', 'الطبق الذي أحبه هو']
        all_forbidden_starts = set()
        for prefix in forbidden_intros:
            all_forbidden_starts.add(prefix)
            all_forbidden_starts.add(f'{prefix} ')
            all_forbidden_starts.add(f'{prefix}:')
        for forbidden_start in all_forbidden_starts:
            if trimmed_value.startswith(forbidden_start):
                return False
        return True



class DataIdx508InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_508')

    def check_following(self, value):
        """Checks if the response explains two methods separated by ---.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        parts = value.split('---')
        if len(parts) != 2:
            return False
        method1 = parts[0].strip()
        method2 = parts[1].strip()
        if not method1 or not method2:
            return False
        return True



class DataIdx509InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_509')

    def check_following(self, value):
        """Checks if the response is a single Arabic sentence containing a conjunction indicating choice ('أو').

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        is_arabic = bool(re.search('[\\u0600-\\u06FF]', value))
        if not is_arabic:
            return False
        contains_choice_conjunction = bool(re.search('\\bأو\\b', value))
        if not contains_choice_conjunction:
            return False
        terminators = ['.', '؟', '!', '٫']
        terminator_count = sum((value.count(t) for t in terminators))
        is_single_sentence = terminator_count == 1
        return is_single_sentence



class DataIdx510InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_510')

    def check_following(self, value):
        """Checks if the response contains exactly two sentences, the first ending in '.',
        and the second ending in '?', ignoring the 'related' constraint.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the punctuation and count constraints,
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        potential_sentences = re.split('(?<=[.!?])\\s*', cleaned_value)
        sentences = [s.strip() for s in potential_sentences if s.strip()]
        if len(sentences) != 2:
            return False
        first_sentence = sentences[0]
        second_sentence = sentences[1]
        if not first_sentence or not second_sentence:
            return False
        if not first_sentence.endswith('.'):
            return False
        if not second_sentence.endswith('?'):
            return False
        return True



class DataIdx511InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_511')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 511.
        Instructions:
        1. Explain AI simply (cannot check)
        2. Use Markdown headings (check for #, ##, etc. at line start)
        3. Mention 'التكنولوجيا' at least 3 times (count occurrences)
        4. Between 200 and 300 words (count words)

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the checked instructions or False otherwise.
        """
        has_headings = False
        lines = value.split('\n')
        potential_prefixes = ['# ', '## ', '### ', '#### ', '##### ', '###### ']
        for line in lines:
            stripped_line = line.strip()
            if stripped_line:
                for prefix in potential_prefixes:
                    if stripped_line.startswith(prefix):
                        has_headings = True
                        break
            if has_headings:
                break
        technology_count = value.count('التكنولوجيا')
        technology_count_ok = technology_count >= 3
        words = value.split()
        word_count = len(words)
        word_count_ok = 200 <= word_count <= 300
        return has_headings and technology_count_ok and word_count_ok



class DataIdx512InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_512')

    def check_following(self, value):
        """Checks if the response is in bullet points (interpreted as separate lines) and has at least 4 points.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.split('\n')
        points = [line.strip() for line in lines if line.strip()]
        return len(points) >= 4



class DataIdx513InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_513')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 513.
        Instructions:
        1. Story from a toy's perspective (cannot check programmatically).
        2. Less than 10 sentences.
        3. Includes the word 'لعب'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the checkable instructions, False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentence_terminators = ['.', '!', '?']
        sentence_count = 0
        for terminator in sentence_terminators:
            sentence_count += value.count(terminator)
        is_less_than_10_sentences = sentence_count < 10
        includes_word_l3b = 'لعب' in value
        return is_less_than_10_sentences and includes_word_l3b



class DataIdx514InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('514')

    def check_following(self, value):
        """Checks if the response starts with the word 'بسبب'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response starts with 'بسبب' (after stripping leading/trailing whitespace), False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        return cleaned_value.startswith('بسبب')



class DataIdx515InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_515')

    def check_following(self, value):
        """Checks if the response is a single sentence not exceeding ten words.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not value or not value.strip():
            return False
        words = value.split()
        if len(words) > 10:
            return False
        cleaned_value = value.rstrip('.!?')
        sentence_terminators = ['.', '!', '?']
        for terminator in sentence_terminators:
            if terminator in cleaned_value:
                return False
        return True



class DataIdx516InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_516')

    def check_following(self, value: str) -> bool:
        """Checks if the response follows the instructions for IDX 516.

        Instructions:
        1. Answer 'نعم' or 'لا' ONLY to 'Are cats mammals?'. (Implied: Must start with 'نعم' as it's the correct answer).
        2. Explain the answer in a single paragraph. (Implicit check: structure implies this).
        3. The paragraph must start with 'لأن'.
        4. The explanation must not exceed 50 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        value = value.strip()
        if not value.startswith('نعم'):
            return False
        search_start_index = len('نعم')
        idx_laan = value.find('لأن', search_start_index)
        if idx_laan == -1:
            return False
        explanation_raw = value[idx_laan:]
        explanation_stripped = explanation_raw.lstrip()
        if not explanation_stripped.startswith('لأن'):
            return False
        explanation_content = explanation_stripped[len('لأن'):].lstrip()
        words = explanation_content.split()
        word_count = len(words)
        if word_count > 50:
            return False
        return True



class DataIdx517InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_517')

    def check_following(self, value):
        """Checks if the response is a single sentence asking about time and uses a question mark only once.
        
        Args:
            value: A string representing the response.

        Returns:
            True if the response contains exactly one question mark, False otherwise.
        """
        return value.count('?') == 1



class DataIdx518InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_518')

    def check_following(self, value):
        """Checks if the response is one short tip based on length and sentence count heuristics.
        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the checkable constraints (short, roughly one or two sentences) or False otherwise.
        """
        MAX_CHARS = 150
        MAX_SENTENCES = 2
        if not value or not value.strip():
            return False
        stripped_value = value.strip()
        if len(stripped_value) > MAX_CHARS:
            return False
        sentences = re.split('[.!?؟]+', stripped_value)
        valid_sentences = [s.strip() for s in sentences if s.strip()]
        if not valid_sentences:
            return False
        if len(valid_sentences) > MAX_SENTENCES:
            return False
        return True



class DataIdx519InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_519')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 519.
        Constraints:
        1. Includes the word "قلب" exactly three times.
        2. Uses at least 5 different rhyming words (interpreted as at least 5 distinct rhyme endings at the end of lines).

        Args:
            value: A string representing the response (the song).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        heart_count = value.count('قلب')
        if heart_count != 3:
            return False
        lines = value.strip().split('\n')
        rhyme_keys = set()
        punctuation = '.,!?:;ء-،'
        for line in lines:
            line = line.strip()
            if not line:
                continue
            words = [word for word in line.split() if word]
            if not words:
                continue
            last_word = words[-1]
            while last_word and last_word[-1] in punctuation:
                last_word = last_word[:-1]
            if not last_word:
                continue
            if len(last_word) >= 2:
                rhyme_key = last_word[-2:]
            else:
                rhyme_key = last_word
            rhyme_keys.add(rhyme_key)
        if len(rhyme_keys) < 5:
            return False
        return True



class DataIdx520InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_520')

    def check_following(self, value):
        """Checks if the response uses the word "الرياضة" at least 5 times.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        word_to_count = 'الرياضة'
        count = value.count(word_to_count)
        return count >= 5



class DataIdx521InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_521')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 521.

        The response must be a single sentence in Arabic describing happiness
        and containing the word 'بهجة' at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the checkable instructions, False otherwise.
        """
        contains_bahja = 'بهجة' in value
        sentence_terminators = ['.', '!', '?']
        terminator_count = sum((value.count(term) for term in sentence_terminators))
        is_single_sentence = terminator_count <= 1
        return contains_bahja and is_single_sentence



class DataIdx522InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_522')

    def check_following(self, value):
        """Checks if the response follows the instructions for question IDX 522.

        Args:
            value: A string representing the response (email).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count > 120:
            return False
        tadreeb_count = 0
        furas_count = 0
        punctuation = '.,!?;:()[]{}<>"\'\n\t'
        for word in words:
            cleaned_word = word.strip(punctuation)
            if cleaned_word == 'تدريب':
                tadreeb_count += 1
            elif cleaned_word == 'فرص':
                furas_count += 1
        if tadreeb_count < 2 or furas_count < 2:
            return False
        return True



class DataIdx523InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_523')

    def check_following(self, value):
        """Checks if the response is a paragraph defining AI between 90 and 110 words.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return 90 <= word_count <= 110



class DataIdx524InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_524')

    def check_following(self, value):
        """Checks if the response is an Arabic sentence with exactly two words ending with a question mark.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        if not stripped_value.endswith('?'):
            return False
        words = [word for word in stripped_value.split() if word]
        if len(words) != 2:
            return False
        return True



class DataIdx525InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_525')

    def check_following(self, value):
        """Checks if the response is a single question without a question mark.
        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain a question mark, False otherwise.
        """
        return '?' not in value



class DataIdx526InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_526')

    def check_following(self, value):
        """
        Checks if the response is a short paragraph of exactly three sentences
        describing spring, using the words 'الأزهار' and 'الأشجار' at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        contains_azhar = 'الأزهار' in value
        contains_ashjar = 'الأشجار' in value
        sentence_enders = ['.', '؟', '!']
        sentence_count = sum((value.count(ender) for ender in sentence_enders))
        return contains_azhar and contains_ashjar and (sentence_count == 3)



class DataIdx527InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_527')

    def check_following(self, value):
        """Checks if the response contains only Arabic numerals, uses 'استراحة' at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        western_numerals = '0123456789'
        arabic_numerals = '٠١٢٣٤٥٦٧٨٩'
        contains_break = 'استراحة' in value
        contains_western_numeral = any((char in western_numerals for char in value))
        return contains_break and (not contains_western_numeral)



class DataIdx528InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_528')

    def check_following(self, value):
        """Checks if the response follows the instruction.

        The instruction asks for a dialogue between two friends about the weather in Arabic.
        There are no specific constraints mentioned in the prompt regarding length,
        specific content, or format beyond being a dialogue about the weather.
        Therefore, any non-empty string is considered to follow the implicitly checkable
        constraints of providing *some* response.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is a non-empty string, False otherwise.
        """
        return isinstance(value, str) and len(value.strip()) > 0



class DataIdx529InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_529')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 529.
        Constraints:
        1. Use simile style (أسلوب التشبيه).
        2. Include the word 'ثلج' at least twice.
        (Subjective constraints like being touching/expressive are not checked).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the checkable instructions, False otherwise.
        """
        if not isinstance(value, str):
            return False
        value_lower = value.lower()
        snow_count = value_lower.count('ثلج')
        if snow_count < 2:
            return False
        simile_indicators = ['كأن', 'مثل', 'يشبه', 'كما']
        has_simile = any((indicator in value for indicator in simile_indicators))
        if not has_simile:
            return False
        return True



class DataIdx530InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_530')

    def check_following(self, value):
        """Checks if the response contains at least 4 lines.

        Args:
            value: A string representing the response (the dialogue).

        Returns:
            True if the response has 4 or more lines, False otherwise.
        """
        lines = value.split('\n')
        num_lines = len(lines)
        return num_lines >= 4



class DataIdx531InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_531')

    def check_following(self, value):
        """Checks if the response is a single sentence about reading importance enclosed in parentheses."""
        if not isinstance(value, str) or not value.startswith('(') or (not value.endswith(')')):
            return False
        inner_content = value[1:-1]
        inner_content_stripped = inner_content.rstrip()
        if not inner_content_stripped:
            return False
        terminators = ['.', '?', '!']
        if inner_content_stripped[-1] not in terminators:
            return False
        content_before_last_char = inner_content_stripped[:-1]
        if any((char in terminators for char in content_before_last_char)):
            return False
        return True



class DataIdx532InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_532')

    def check_following(self, value):
        """
        Checks if the response string contains the Arabic word for 'الشمس' (The Sun).
        This check is a heuristic based on the constraint that the answer to the
        riddle should be 'الشمس'. A perfect check (solving the riddle from text)
        is not feasible. This function assumes the student might include the
        answer or a phrase indicating the answer in their response string (the riddle text).

        Args:
            value: A string representing the response (the riddle text provided by the student).

        Returns:
            True if the string contains the substring 'الشمس', False otherwise or if value is not a string.
        """
        if not isinstance(value, str):
            return False
        return 'الشمس' in value



class DataIdx533InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_533')

    def check_following(self, value):
        """Checks if the response follows the constraints: 7 comma-separated items with no dots.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if '.' in value:
            return False
        items = value.split(',')
        if len(items) != 7:
            return False
        if not all((item.strip() for item in items)):
            return False
        return True



class DataIdx534InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_534')

    def check_following(self, value):
        """Checks if the response consists of exactly 20 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response has exactly 20 words, False otherwise.
        """
        words = value.split()
        return len(words) == 20



class DataIdx535InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_535')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 535.

        Args:
            value: A string representing the response (the dialogue).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value:
            return False
        if any((char.isdigit() for char in value)):
            return False
        price_count = value.count('سعر')
        if price_count != 1:
            return False
        question_mark_count = value.count('?')
        if question_mark_count != 1:
            return False
        lines = [line.strip() for line in value.splitlines() if line.strip()]
        question_mark_at_end_of_line_count = sum((1 for line in lines if line.endswith('?')))
        if question_mark_at_end_of_line_count != 1:
            return False
        num_lines = len(lines)
        if num_lines != 7:
            return False
        return True



class DataIdx536InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_536')

    def check_following(self, value):
        """Checks if the response is a formal and polite letter to the mayor complaining about noise in a residential area.
        Args:
            value: A string representing the response (the letter).

        Returns:
            True if the response follows the instruction (contains key elements), False otherwise.
        """
        recipient_phrases = ['رئيس البلدية', 'السيد رئيس البلدية', 'حضرة رئيس البلدية', 'سيادة رئيس البلدية']
        noise_keywords = ['ضوضاء', 'إزعاج', 'أصوات عالية', 'صخب']
        area_keywords = ['منطقة', 'حي', 'سكنية']
        formality_phrases = ['تحية طيبة وبعد', 'مع خالص الشكر', 'وتقبلوا فائق الاحترام', 'وبعد', 'السلام عليكم', 'الاحترام والتقدير', 'نرجو من سيادتكم', 'نتقدم إليكم']
        has_recipient_info = any((phrase in value for phrase in recipient_phrases))
        has_noise_topic = any((keyword in value for keyword in noise_keywords))
        has_area_reference = any((keyword in value for keyword in area_keywords))
        has_formality_indicator = any((phrase in value for phrase in formality_phrases))
        is_following = has_recipient_info and has_noise_topic and has_area_reference and has_formality_indicator
        return is_following



class DataIdx537InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_537')

    def check_following(self, value):
        """Checks if the response follows the constraints.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (does not exceed 30 words),
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return word_count <= 30



class DataIdx538InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_538')

    def check_following(self, value):
        """Checks if the response is a table with 3 columns (الاسم, العمر, المدينة) and 4 data rows.
        Assumes markdown table format is the most likely interpretation.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = [line.strip() for line in value.strip().split('\n') if line.strip()]
        header_idx = -1
        separator_idx = -1
        for i, line in enumerate(lines):
            if line.startswith('|') and '|' in line[1:]:
                if header_idx == -1:
                    header_idx = i
                elif separator_idx == -1 and i > header_idx and all((c in '| -:' for c in line)):
                    separator_idx = i
                    break
        if header_idx == -1 or separator_idx == -1 or separator_idx != header_idx + 1:
            return False
        header_line = lines[header_idx]
        header_cols = [col.strip() for col in header_line.strip('|').split('|')]
        required_cols = {'الاسم', 'العمر', 'المدينة'}
        if set(header_cols) != required_cols or len(header_cols) != 3:
            cleaned_cols = {col for col in header_cols if col}
            if cleaned_cols != required_cols or len(cleaned_cols) != 3:
                return False
        data_rows = [line for i, line in enumerate(lines) if i > separator_idx and line.startswith('|') and line.endswith('|') and ('|' in line[1:-1])]
        if len(data_rows) != 4:
            return False
        for row in data_rows:
            cells = [cell.strip() for cell in row.strip('|').split('|')]
            if len(cells) < 3:
                return False
        return True



class DataIdx539InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_539')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        punctuation_chars = '.,;:"\'?!()[]{}-/\\<>@#$%^&*~`|،؛؟'
        if not value or not value.strip():
            return False
        for char in value:
            if char in punctuation_chars:
                return False
        return True



class DataIdx540InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_540')

    def check_following(self, value):
        """Checks if the response is a single sentence about reading importance containing 'المعرفة' twice.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        keyword = 'المعرفة'
        keyword_count = value.count(keyword)
        if keyword_count != 2:
            return False
        sentence_enders = ['.', '!', '?']
        ender_count = 0
        for ender in sentence_enders:
            ender_count += value.count(ender)
        if ender_count > 1:
            return False
        return True



class DataIdx541InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_541')

    def check_following(self, value):
        """Checks if the response paragraph describing Riyadh does not exceed 50 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (<= 50 words), False otherwise.
        """
        words = value.split()
        return len(words) <= 50



class DataIdx542InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('542')

    def check_following(self, value):
        """Checks if the response contains the word 'المعرفة' at least twice.
        Args:
            value: A string representing the response (the dialogue).

        Returns:
            True if 'المعرفة' appears 2 or more times, False otherwise.
        """
        word_to_check = 'المعرفة'
        count = value.count(word_to_check)
        return count >= 2



class DataIdx543InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_543')

    def check_following(self, value):
        """Checks if the response is one exclamation sentence about a beautiful natural landscape,
        ending with an exclamation mark.
        Focuses on structural constraints: single sentence and ending punctuation.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if len(cleaned_value) < 2:
            return False
        if not cleaned_value.endswith('!'):
            return False
        text_before_end = cleaned_value[:-1]
        for term in ['.', '?', '!']:
            if term in text_before_end:
                return False
        return True



class DataIdx544InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_544')

    def check_following(self, value):
        """Checks if the Arabic response is one sentence, starts with 'التعليم', and has more than 15 words.
        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows all instructions, False otherwise.
        """
        if not isinstance(value, str):
            return False
        if '\n' in value:
            return False
        sentence_terminators = ['.', '!', '؟']
        terminator_count = 0
        for term in sentence_terminators:
            terminator_count += value.count(term)
        if terminator_count > 1:
            return False
        cleaned_value = value.lstrip()
        if not cleaned_value.startswith('التعليم'):
            return False
        words = cleaned_value.split()
        word_count = len(words)
        if word_count <= 15:
            return False
        return True



class DataIdx545InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_545')

    def check_following(self, value):
        """Checks if the response provides three examples in an unnumbered list format.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = [line.strip() for line in value.strip().split('\n')]
        non_empty_lines = [line for line in lines if line]
        if len(non_empty_lines) != 3:
            return False
        numbered_pattern = re.compile('^\\d+[\\.\\)]')
        for line in non_empty_lines:
            if numbered_pattern.match(line):
                return False
        return True



class DataIdx546InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_546')

    def check_following(self, value):
        """Checks if the response lists three benefits of public transport data analysis,
           with each benefit starting with the word "تحسين".

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        non_empty_lines = [line.strip() for line in lines if line.strip()]
        if len(non_empty_lines) != 3:
            return False
        prefix = 'تحسين'
        for line in non_empty_lines:
            if not line.startswith(prefix):
                return False
        return True



class DataIdx547InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_547')

    def check_following(self, value):
        """Checks if the response is a single paragraph describing learning a new language,
        includes 'تحدي', 'ممتع', 'مفيد', and does not exceed five sentences.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if '\n\n' in value:
            return False
        required_words = ['تحدي', 'ممتع', 'مفيد']
        for word in required_words:
            if word not in value:
                return False
        sentence_delimiters = ['.', '؟', '!']
        sentences = []
        current_sentence_chars = []
        for char in value:
            current_sentence_chars.append(char)
            if char in sentence_delimiters:
                sentence_text = ''.join(current_sentence_chars).strip()
                if sentence_text:
                    sentences.append(sentence_text)
                current_sentence_chars = []
        last_fragment = ''.join(current_sentence_chars).strip()
        if last_fragment:
            sentences.append(last_fragment)
        num_sentences = len(sentences)
        if num_sentences > 5:
            return False
        return True



class DataIdx548InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_548')

    def check_following(self, value):
        """Checks if the response is a poem that does not exceed five verses,
        and includes the words 'شمس' and 'قمر'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the programmable instructions or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = [line for line in value.strip().split('\n') if line.strip()]
        num_lines = len(lines)
        if num_lines == 0 or num_lines > 5:
            return False
        has_shams = 'شمس' in value
        has_qamar = 'قمر' in value
        if not has_shams or not has_qamar:
            return False
        return True



class DataIdx549InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_549')

    def check_following(self, value):
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        sentences = [s.strip() for s in re.split('[.?!]+', cleaned_value) if s.strip()]
        if len(sentences) > 5:
            return False
        first_person_markers_found = False
        words = ' '.join(cleaned_value.split()).split()
        if 'أنا' in words or 'نحن' in words:
            first_person_markers_found = True
        if any((word.endswith('تُ') for word in words)):
            first_person_markers_found = True
        if not first_person_markers_found:
            return False
        return True



class DataIdx550InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_550')

    def check_following(self, value):
        """Checks if the response contains a list of five tips,
        each on a single line ending with appropriate punctuation.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction, False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        tips = [line.strip() for line in lines if line.strip()]
        if len(tips) != 5:
            return False
        for tip in tips:
            if not (tip.endswith('.') or tip.endswith('!')):
                return False
            internal_tip = tip[:-1]
            if '.' in internal_tip or '!' in internal_tip:
                return False
        return True



class DataIdx551InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_551')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 551.
        Constraints:
        1. Must contain the word 'اكتشاف'.
        2. Must only contain Arabic letters, spaces, and common headline punctuation.
           (Interpretation of 'الأحرف الكبيرة فقط' as standard Arabic script)

        Args:
            value: A string representing the response (the headline).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if 'اكتشاف' not in value:
            return False
        allowed_punctuation = set('.,!?;:()"\'')

        def is_allowed_char(char):
            if char.isspace():
                return True
            if char in allowed_punctuation:
                return True
            code_point = ord(char)
            if 1536 <= code_point <= 1791 or 1872 <= code_point <= 1919 or 2208 <= code_point <= 2303 or (64336 <= code_point <= 65023) or (65136 <= code_point <= 65279):
                return True
            return False
        for char in value:
            if not is_allowed_char(char):
                return False
        return True



class DataIdx552InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_552')

    def check_following(self, value):
        """Checks if the response is a brief definition of 'Sustainable Development' in exactly two sentences,
        with both sentences containing the word 'الأجيال'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentences = []
        temp_sentences = value.replace('!', '.').split('.')
        for sentence in temp_sentences:
            stripped_sentence = sentence.strip()
            if stripped_sentence:
                sentences.append(stripped_sentence)
        if len(sentences) != 2:
            return False
        word_to_find = 'الأجيال'
        for sentence in sentences:
            if word_to_find not in sentence:
                return False
        return True



class DataIdx553InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_553')

    def check_following(self, value):
        """Checks if the response contains more than 40 words.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (more than 40 words) or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        return len(words) > 40



class DataIdx554InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_554')

    def check_following(self, value):
        """Checks if the response is a single verbal sentence according to the heuristic.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        terminal_punctuation_pattern = '[.!?]'
        punc_matches = list(re.finditer(terminal_punctuation_pattern, cleaned_value))
        if len(punc_matches) > 1:
            return False
        elif len(punc_matches) == 1:
            last_punc_match = punc_matches[0]
            text_after_punc = cleaned_value[last_punc_match.end():].strip()
            if text_after_punc:
                return False
            sentence_text = cleaned_value[:last_punc_match.end()]
        else:
            sentence_text = cleaned_value
        if not sentence_text.strip():
            return False
        words = sentence_text.strip().split(maxsplit=1)
        if not words:
            return False
        first_word = words[0]
        common_verb_prefixes = ('ي', 'ت', 'أ', 'ن')
        if first_word.startswith(common_verb_prefixes):
            return True
        else:
            return False



class DataIdx555InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_555')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 555.
        Instructions:
        - Must be a single sentence (at most one sentence-ending punctuation).
        - Must not exceed ten words.
        - Must use the word 'التكنولوجيا' at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentence_enders = ['.', '!', '?']
        punctuation_count = sum((value.count(p) for p in sentence_enders))
        is_single_sentence = punctuation_count <= 1
        words = value.split()
        word_count = len(words)
        is_within_word_limit = word_count <= 10
        contains_keyword = 'التكنولوجيا' in value
        return is_single_sentence and is_within_word_limit and contains_keyword



class DataIdx556InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_556')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 556.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        closing_phrase = 'هل هناك أي شيء آخر يمكنني مساعدتك به؟'
        value_stripped = value.strip()
        if not value_stripped.endswith(closing_phrase):
            return False
        idx = value_stripped.rfind(closing_phrase)
        body = value_stripped[:idx].strip()
        words = body.split()
        min_word_count = 90
        if len(words) < min_word_count:
            return False
        return True



class DataIdx557InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_557')

    def check_following(self, value):
        """Checks if the response follows the instruction for IDX 557.

        Constraints:
        1. Message must be a short invitation to a friend to visit a science museum. (Implicitly checked by length/content)
        2. Must include the museum name and a suggested visit date. (Checked via keywords/patterns)
        3. Must not exceed 3 sentences. (Checked via sentence splitting)

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        sentence_endings = re.compile('[.!?]+')
        sentences = [s.strip() for s in sentence_endings.split(cleaned_value) if s.strip()]
        if len(sentences) > 3:
            return False
        has_museum_keyword = 'متحف' in cleaned_value
        date_keywords = ['يوم', 'تاريخ', 'موعد', 'الأحد', 'الإثنين', 'الثلاثاء', 'الأربعاء', 'الخميس', 'الجمعة', 'السبت', 'يناير', 'فبراير', 'مارس', 'أبريل', 'مايو', 'يونيو', 'يوليو', 'أغسطس', 'سبتمبر', 'أكتوبر', 'نوفمبر', 'ديسمبر']
        has_date_keyword = any((keyword in cleaned_value for keyword in date_keywords))
        has_numerical_date = re.search('\\d{1,2}[/\\-]\\d{1,2}(?:[/\\-]\\d{2,4})?', cleaned_value) is not None
        has_date_info = has_date_keyword or has_numerical_date
        content_check_passed = has_museum_keyword and has_date_info
        if not content_check_passed:
            return False
        return True



class DataIdx558InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_558')

    def check_following(self, value: str) -> bool:
        """
        Checks if the response follows the instructions for IDX 558.
        Instructions:
        - List five things to check before a long drive.
        - Use '###' as a separator.
        - Must contain the word 'سلامة' (safety) at least once.
        - Must end with 'قيادة آمنة!' (safe driving!).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        required_ending = 'قيادة آمنة!'
        separator = '###'
        required_word = 'سلامة'
        expected_item_count = 5
        if not value or not value.strip():
            return False
        if required_word not in value:
            return False
        trimmed_value = value.rstrip()
        if not trimmed_value.endswith(required_ending):
            return False
        ending_start_index = trimmed_value.rfind(required_ending)
        content_part = trimmed_value[:ending_start_index].strip()
        if not content_part:
            return False
        items = content_part.split(separator)
        if len(items) != expected_item_count:
            return False
        if any((item.strip() == '' for item in items)):
            return False
        return True



class DataIdx559InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_559')

    def check_following(self, value):
        """Checks if the response is a single sentence containing an imperative verb
           directed at a single person to open the door.
        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        response = value.strip()
        has_door = 'باب' in response
        has_singular_imperative_open = 'افتح' in response or 'افتحي' in response
        return has_door and has_singular_imperative_open



class DataIdx560InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_560')

    def check_following(self, value):
        """Checks if the response is a short Arabic dialogue between two people discussing
        the importance of reading, where one person uses 'المعرفة' at least twice,
        and the dialogue uses quotation marks. It assumes speaker identification is
        done using a format like 'Name: "Dialogue"'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the constraints, False otherwise.
        """
        if not re.search('[\\u0600-\\u06FF]', value):
            return False
        dialogue_turns = re.findall('([^:]+?):\\s*\\"([^\\"]*?)\\"', value)
        if not dialogue_turns:
            return False
        speakers = set((name.strip() for name, speech in dialogue_turns))
        if len(speakers) < 2:
            return False
        speaker_speech = {}
        for name, speech in dialogue_turns:
            speaker_speech[name.strip()] = speaker_speech.get(name.strip(), '') + speech
        keyword_met = False
        keyword = 'المعرفة'
        for name, total_speech in speaker_speech.items():
            count = total_speech.count(keyword)
            if count >= 2:
                keyword_met = True
                break
        if not keyword_met:
            return False
        return True



class DataIdx561InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_561')

    def check_following(self, value):
        """Checks if the response is a summary of at most three sentences.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains at most three sentences, False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentences = re.split('[.!?؟]', value)
        valid_sentences = [s for s in sentences if s.strip()]
        num_sentences = len(valid_sentences)
        return num_sentences <= 3



class DataIdx562InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_562')

    def check_following(self, value):
        """
        Checks if the response lists exactly five items, and each item
        appears to contain both a skill and a brief example.
        """
        cleaned_value = value.strip()
        if not cleaned_value:
            return False

        def has_sufficient_content(item):
            item = item.strip()
            if not item:
                return False
            separators = [':', '-', '.']
            first_sep_index = -1
            found_separator = False
            for sep in separators:
                idx = item.find(sep)
                if idx != -1:
                    if not found_separator or idx < first_sep_index:
                        first_sep_index = idx
                        found_separator = True
            if found_separator:
                skill_part = item[:first_sep_index].strip()
                example_part = item[first_sep_index + 1:].strip()
                if not skill_part or len(skill_part) < 2:
                    return False
                if not example_part or len(example_part) < 10:
                    return False
                return True
            else:
                if len(item) < 30:
                    return False
                return True
        lines = [line.strip() for line in cleaned_value.split('\n') if line.strip()]
        item_start_pattern = re.compile('^\\s*(\\d+\\.|\\-|\\*)\\s*')
        list_marked_lines = []
        for line in lines:
            if item_start_pattern.match(line):
                list_marked_lines.append(line)
        if len(list_marked_lines) == 5:
            all_items_sufficient = True
            for item in list_marked_lines:
                text_after_marker = item_start_pattern.sub('', item).strip()
                if not has_sufficient_content(text_after_marker):
                    all_items_sufficient = False
                    break
            if all_items_sufficient:
                return True
        if len(list_marked_lines) != 5:
            paragraphs = [p.strip() for p in cleaned_value.split('\n\n') if p.strip()]
            if len(paragraphs) == 5:
                all_paragraphs_sufficient = True
                for para in paragraphs:
                    if not has_sufficient_content(para):
                        all_paragraphs_sufficient = False
                        break
                if all_paragraphs_sufficient:
                    return True
        paragraphs_checked = 'paragraphs' in locals()
        if len(list_marked_lines) != 5 and (len(paragraphs) != 5 if paragraphs_checked else True) and (len(lines) == 5):
            all_lines_sufficient = True
            for line in lines:
                if not has_sufficient_content(line):
                    all_lines_sufficient = False
                    break
            if all_lines_sufficient:
                return True
        return False



class DataIdx563InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_563')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 563.

        The instructions require:
        1. The response is a poem in Arabic.
        2. The poem consists of two couplets (four lines).
        3. The poem is about the beauty of the moon.
        4. The word "قمر" (moon) is not used.

        This checker specifically verifies constraints 2 and 4, as 1 and 3 are difficult
        to check programmatically without advanced NLP.

        Args:
            value: A string representing the response (the poem).

        Returns:
            True if the response consists of exactly 4 lines and does not contain the
            substring "قمر", False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        lines = value.split('\n')
        if len(lines) != 4:
            return False
        if 'قمر' in value:
            return False
        return True



class DataIdx564InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_564')

    def check_following(self, value):
        """Checks if the response is a brief book description not exceeding 60 words.
        Note: Checking for author name mention is ambiguous without specific book/author knowledge,
        so this checker primarily focuses on the word count constraint.

        Args:
            value: A string representing the response (book description).

        Returns:
            True if the response follows the word count constraint (<= 60 words), False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        return len(words) <= 60



class DataIdx565InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_565')

    def check_following(self, value):
        """Checks if the response is a single sentence in Standard Arabic containing the word 'القمر' at least three times.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        word_count = value.count('القمر')
        return word_count >= 3



class DataIdx566InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_566')

    def check_following(self, value):
        """Checks if the response follows the constraints for IDX 566.
        Constraints checked:
        - Must NOT use the word "مدينة" or "المدينة".
        - Must include concepts related to at least three essential facilities or services (checked via keywords).

        Constraints NOT checked programmatically:
        - Must be a paragraph.
        - Must include at least three positive qualities.
        (These require semantic analysis beyond simple string checks).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the checkable constraints, False otherwise.
        """
        if not isinstance(value, str):
            return False
        forbidden_words = ['مدينة', 'المدينة']
        for word in forbidden_words:
            if word in value:
                return False
        facility_keywords = {'health': ['مستشفى', 'مستشفيات', 'عيادة', 'عيادات', 'صحة'], 'education': ['مدرسة', 'مدارس', 'تعليم', 'جامعة', 'جامعات'], 'green_recreation': ['حديقة', 'حدائق', 'منتزه', 'منتزهات', 'مساحة خضراء', 'مساحات خضراء', 'ملعب', 'ملاعب'], 'transportation': ['مواصلات', 'نقل عام', 'قطار', 'قطارات', 'حافلة', 'حافلات', 'مترو', 'طريق', 'طرق'], 'commerce': ['سوق', 'أسواق', 'محل', 'محلات', 'مركز تجاري', 'مراكز تجارية', 'تسوق'], 'culture_entertainment': ['مكتبة', 'مكتبات', 'متحف', 'متاحف', 'مسرح', 'مسارح', 'سينما', 'سينمات', 'مركز ثقافي', 'مراكز ثقافية'], 'safety': ['أمن', 'شرطة', 'سلامة', 'آمان'], 'services': ['خدمات', 'بنك', 'بنوك', 'بريد']}
        detected_concepts_count = 0
        for keywords in facility_keywords.values():
            concept_found = False
            for keyword in keywords:
                if keyword in value:
                    concept_found = True
                    break
            if concept_found:
                detected_concepts_count += 1
        facilities_constraint_met = detected_concepts_count >= 3
        return facilities_constraint_met



class DataIdx567InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_567')

    def check_following(self, value):
        """Checks if the response follows the instruction not to use exclamation marks.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain exclamation marks, False otherwise.
            Note: This check only verifies the 'no exclamation marks' constraint,
            as other constraints (sarcasm, common situation, purely in Arabic)
            are difficult or impossible to check reliably with just the input string
            and without external libraries or human judgment.
        """
        if '!' in value:
            return False
        return True



class DataIdx568InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_568')

    def check_following(self, value):
        """Checks if the response is a string containing the phrase 'فريق النصر' at least once.

        Args:
            value: A string representing the response (the news report).

        Returns:
            True if the value is a string and contains 'فريق النصر', False otherwise.
        """
        if not isinstance(value, str):
            return False
        required_phrase = 'فريق النصر'
        return required_phrase in value



class DataIdx569InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_569')

    def check_following(self, value):
        """Checks if the response is a single paragraph, has at least 5 sentences,
           and discusses cultural and economic importance using basic string operations.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if '\n\n' in cleaned_value:
            return False
        temp_value = cleaned_value.replace('؟', '.').replace('!', '.')
        parts = temp_value.split('.')
        num_sentences = len([p.strip() for p in parts if p.strip()])
        if num_sentences < 5:
            return False
        cultural_keywords = ['لغة', 'هوية', 'تراث', 'تاريخ', 'أدب', 'شعر', 'فن', 'حضارة', 'تواصل ثقافي', 'ثقافة', 'ثقافي']
        has_cultural = any((keyword in cleaned_value for keyword in cultural_keywords))
        economic_keywords = ['اقتصاد', 'اقتصادي', 'تجارة', 'سوق العمل', 'فرص عمل', 'شركات', 'استثمار', 'أعمال', 'مهني', 'وظائف', 'سياحة', 'نفط', 'طاقة', 'تواصل تجاري']
        has_economic = any((keyword in cleaned_value for keyword in economic_keywords))
        if not has_cultural or not has_economic:
            return False
        return True



class DataIdx570InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_570')

    def check_following(self, value):
        """Checks if the response contains at least 3 Arabic similes.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains at least 3 similes (using 'مثل' or 'كـ'), False otherwise.
        """
        if not isinstance(value, str):
            return False
        count_mithl = value.count('مثل')
        count_ka = value.count('كـ')
        count_ka_char = value.count('ك')
        count_ka_prefix = len(re.findall('ك\\S', value))
        total_similes_indicators = count_mithl + count_ka_prefix
        return total_similes_indicators >= 3



class DataIdx571InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_571')

    def check_following(self, value):
        """Checks if the response avoids using 'نعم' or 'لا'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain 'نعم' or 'لا', False otherwise.
        """
        if isinstance(value, str):
            if 'نعم' in value or 'لا' in value:
                return False
            return True
        return False



class DataIdx572InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_572')

    def check_following(self, value):
        """Checks if the response is a string and contains at least 6 sentences.

        Sentences are identified by the presence of '.', '?', '!', or '...'
        as terminators.

        Args:
            value: A string representing the response (the dialogue).

        Returns:
            True if the response is a string and has at least 6 sentences,
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        terminators_regex = '[.?!؟]|\\.\\.\\.'
        potential_sentences = re.split(terminators_regex, value)
        sentence_count = 0
        for sentence in potential_sentences:
            if sentence.strip():
                sentence_count += 1
        return sentence_count >= 6



class DataIdx573InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_573')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 573.
        The instruction is to answer the question "What is Arabic music?"
        briefly, without using the word 'موسيقى'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain the word 'موسيقى', False otherwise.
        """
        forbidden_word = 'موسيقى'
        if forbidden_word in value:
            return False
        else:
            return True



class DataIdx574InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_574')

    def check_following(self, value):
        """Checks if the response is an Arabic paragraph with at least three sentences ending with an exclamation mark.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.rstrip()
        if not stripped_value:
            return False
        ends_with_exclamation = stripped_value.endswith('!')
        if not ends_with_exclamation:
            return False
        sentences = re.split('[.!?]', value)
        non_empty_segments = [s for s in sentences if s.strip()]
        sentence_count = len(non_empty_segments)
        return sentence_count >= 3



class DataIdx575InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_575')

    def check_following(self, value):
        """Checks if the response follows the constraints for IDX 575."""
        prompt = "اكتب رسالة نصية قصيرة تعتذر فيها عن التأخر عن موعد. يجب أن تتكون الرسالة من جملتين فقط. كرر الطلب كلمة بكلمة دون تغيير، ثم قدم إجابتك. يجب أن تحتوي إجابتك على كلمة 'آسف' مرة واحدة على الأقل. لا تستخدم الاختصارات في الرسالة."
        if not value.startswith(prompt):
            return False
        response_part = value[len(prompt):].lstrip()
        if not response_part:
            return False
        if 'آسف' not in response_part:
            return False
        sentence_enders = ['.', '!', '?']
        sentences = []
        current_sentence = ''
        for char in response_part:
            current_sentence += char
            if char in sentence_enders:
                cleaned_sentence = current_sentence.strip()
                if cleaned_sentence:
                    sentences.append(cleaned_sentence)
                current_sentence = ''
        if current_sentence.strip():
            sentences.append(current_sentence.strip())
        if len(sentences) != 2:
            return False
        return True



class DataIdx576InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_576')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if len(value) < 2 or value[-1] != '.':
            return False
        if 'سعادة' not in value:
            return False
        for char in value[:-1]:
            if char.is_punctuation():
                return False
        return True



class DataIdx577InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_577')

    def check_following(self, value):
        """
        Checks if the response is a short story for children under seven in Arabic
        based on feasible programmatic heuristics: primarily Arabic characters,
        and length constraints suggesting a 'short' story format.
        It cannot reliably verify age appropriateness, narrative quality,
        or specific content suitable for young children.

        Args:
            value: A string representing the response (the story).

        Returns:
            True if the response meets basic structural and language requirements
            for a short Arabic story attempt, False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        value = value.strip()
        arabic_like_char_count = 0
        total_char_count = 0
        for char in value:
            total_char_count += 1
            if '\u0600' <= char <= 'ۿ' or 'ݐ' <= char <= 'ݿ' or 'ࢠ' <= char <= 'ࣿ' or ('ﭐ' <= char <= '﷿') or ('ﹰ' <= char <= '\ufeff') or char.isspace() or (char in '.,!?:؛؟"\'()[]{}<>/\\'):
                arabic_like_char_count += 1
        if total_char_count == 0:
            return False
        if arabic_like_char_count / total_char_count < 0.7:
            return False
        min_length = 50
        max_length = 1000
        if len(value) < min_length or len(value) > max_length:
            return False
        return True



class DataIdx578InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_578')

    def remove_arabic_diacritics_and_kashida(self, text):
        """Removes common Arabic diacritics and Tatweel (Kashida) from a string."""
        chars_to_remove = set(['ً', 'ٌ', 'ٍ', 'َ', 'ُ', 'ِ', 'ّ', 'ْ', 'ٓ', 'ٔ', 'ٕ', 'ٖ', 'ٗ', '٘', 'ٙ', 'ٚ', 'ٛ', 'ٜ', 'ٝ', 'ٞ', 'ٟ', 'ـ'])
        return ''.join((c for c in text if c not in chars_to_remove))

    def check_following(self, value):
        """Checks if the response is a short prayer in sophisticated literary style using rhyme (saj') at the end of sentences.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        total_words = len(value.split())
        max_words = 70
        if total_words == 0 or total_words > max_words:
            return False
        segments = re.split('[\\s.,;؛،\\n]+', value)
        segments = [s for s in segments if s]
        if len(segments) < 2:
            return False
        saj_found = False
        last_meaningful_char_prev_seg = None
        for i in range(len(segments)):
            seg = segments[i]
            seg_clean = self.remove_arabic_diacritics_and_kashida(seg)
            words = seg_clean.split()
            last_meaningful_char_current_seg = None
            if words:
                last_word = words[-1]
                for char in reversed(last_word):
                    if unicodedata.category(char) == 'Lo':
                        last_meaningful_char_current_seg = char
                        break
            if last_meaningful_char_prev_seg is not None and last_meaningful_char_current_seg is not None:
                if last_meaningful_char_prev_seg == last_meaningful_char_current_seg:
                    saj_found = True
                    break
            last_meaningful_char_prev_seg = last_meaningful_char_current_seg
        if not saj_found:
            return False
        return True



class DataIdx579InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_579')

    def check_following(self, value):
        if not isinstance(value, str) or not value:
            return False
        egyptian_markers = ['بتاع', 'أوي', 'عشان', 'إيه', 'مين', 'فين', 'إزاي', 'هينزل', 'هيكون فيه']
        for marker in egyptian_markers:
            if marker in value:
                return True
        return False



class DataIdx580InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_580')

    def check_following(self, value):
        """Checks if the response contains text underlined with underscores.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains at least one sequence of text
            wrapped in underscores (e.g., _some text_), False otherwise.
        """
        pattern = '_.+_'
        return re.search(pattern, value) is not None



class DataIdx581InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_581')

    def check_following(self, value):
        """
        Checks if the response is a brief definition of 'الابتكار' in one sentence,
        using the word itself.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if 'الابتكار' not in value:
            return False
        trimmed_value = value.strip()
        if '\n' in trimmed_value or '\r' in trimmed_value:
            return False
        punctuation_count = 0
        for char in trimmed_value:
            if char in ['.', '!', '?']:
                punctuation_count += 1
        if punctuation_count > 1:
            return False
        return True



class DataIdx582InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_582')

    def check_following(self, value):
        """Checks if the response is a single sentence expressing an opinion on the importance
        of learning a foreign language and uses the word 'اللغة' at least twice.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        lang_word_count = cleaned_value.count('اللغة')
        if lang_word_count < 2:
            return False
        terminal_punctuation = ['.', '؟', '!']
        sentence_enders_count = sum((cleaned_value.count(p) for p in terminal_punctuation))
        if sentence_enders_count != 1:
            return False
        if not cleaned_value.endswith(tuple(terminal_punctuation)):
            return False
        return True



class DataIdx583InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_583')

    def check_following(self, value):
        """Checks if the response is a single question about the importance of water
        using exactly one question mark.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        return value.count('?') == 1



class DataIdx584InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_584')

    def check_following(self, value):
        """Checks if the response starts with 'في صباح العيد' and contains exactly one question mark.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        required_start = 'في صباح العيد'
        starts_correctly = value.strip().startswith(required_start)
        question_mark_count = value.count('?')
        has_one_question_mark = question_mark_count == 1
        return starts_correctly and has_one_question_mark



class DataIdx585InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_585')

    def check_following(self, value):
        """Checks if the response follows the instruction for IDX 585.
        Constraints checked:
        1. Must NOT use digits (0-9).
        2. Must include some indication of Date, Place, and Time (checked via keyword presence).
        """
        for char in value:
            if '0' <= char <= '9':
                return False
        date_keywords = {'يوم', 'تاريخ', 'الموافق', 'الشهر'}
        place_keywords = {'مكان', 'منزل', 'بيت', 'قاعة', 'في'}
        time_keywords = {'وقت', 'ساعة', 'مساء', 'صباحا', 'تمام'}
        has_date = any((keyword in value for keyword in date_keywords))
        has_place = any((keyword in value for keyword in place_keywords))
        has_time = any((keyword in value for keyword in time_keywords))
        if not (has_date and has_place and has_time):
            return False
        return True



class DataIdx586InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('586')

    def check_following(self, value):
        """
        Checks if the response is a list of exactly five items and does not contain the forbidden verb 'يلعب' or its derivatives.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction, False otherwise.
        """
        if not isinstance(value, str):
            return False
        forbidden_root = 'لعب'
        if forbidden_root in value:
            return False
        items = [item.strip() for item in value.split('\n') if item.strip()]
        if len(items) != 5:
            return False
        return True



class DataIdx587InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_587')

    def check_following(self, value):
        """Checks if the response is one sentence in passive voice about reading.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentence_enders = ['.', '!', '?']
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        if not cleaned_value[-1] in sentence_enders:
            return False
        internal_enders = [char for char in cleaned_value[:-1] if char in sentence_enders]
        if internal_enders:
            return False
        passive_forms_of_read_heuristic = ['قرئ', 'يقرأ']
        found_passive_form = False
        for form in passive_forms_of_read_heuristic:
            if form in value:
                found_passive_form = True
                break
        if not found_passive_form:
            return False
        return True



class DataIdx588InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_588')

    def check_following(self, value):
        """Checks if the response expresses astonishment based on common linguistic markers.
        This check looks for the presence of an exclamation mark (!) or certain common
        Arabic phrases/words associated with expressing surprise or astonishment.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains indicators of astonishment, False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if '!' in cleaned_value:
            return True
        astonishment_indicators = ['يا له من', 'يا للعجب', 'وا عجباً', 'عجباً', 'ما أدهش', 'كم هو مدهش', 'يا سبحان الله', 'مدهش', 'تصور']
        for indicator in astonishment_indicators:
            if indicator in cleaned_value:
                return True
        return False



class DataIdx589InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_589')

    def check_following(self, value):
        """Checks if the response contains the word 'إنترنت' at least three times.

        Args:
            value: A string representing the response (rap lyrics).

        Returns:
            True if 'إنترنت' appears 3 or more times, False otherwise.
        """
        internet_count = value.count('إنترنت')
        return internet_count >= 3



class DataIdx590InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_590')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        trimmed_value = value.strip()
        if not trimmed_value:
            return False
        sentence_enders = ['.', '!', '?']
        ender_indices = []
        for i, char in enumerate(trimmed_value):
            if char in sentence_enders:
                ender_indices.append(i)
        if len(ender_indices) > 1:
            return False
        elif len(ender_indices) == 1:
            if ender_indices[0] != len(trimmed_value) - 1:
                return False
            return True
        else:
            return True



class DataIdx591InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_591')

    def check_following(self, value):
        """
        Checks if the response is an Arabic story about a talking animal in school with no more than 6 sentences.
        Note: This implementation primarily checks the sentence count constraint as reliably verifying
        the language and theme programmatically with simple string analysis is complex.

        Args:
            value: A string representing the response (the story).

        Returns:
            True if the response has 6 or fewer sentences, False otherwise.
        """
        sentences = re.split('[.!?؟]', value)
        non_empty_sentences = [s for s in sentences if s.strip()]
        sentence_count = len(non_empty_sentences)
        return sentence_count <= 6



class DataIdx592InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_592')

    def check_following(self, value):
        """Checks if the response follows the constraints for IDX 592.
        Constraints:
        1. Single sentence (checked via punctuation)
        2. Contains a nasikh verb (كان أو إحدى أخواتها)
        3. Does NOT contain any common attached pronoun suffixes at the end of words.
        Note: Checking for 'اسم', 'خبر', and 'خبر is فعلية' requires deep NLP and is omitted.
        """
        if not isinstance(value, str):
            return False
        value_stripped = value.strip()
        terminal_punctuations = ['.', '!', '؟']
        if not any((value_stripped.endswith(p) for p in terminal_punctuations)):
            return False
        punct_count = sum((value_stripped.count(p) for p in terminal_punctuations))
        if punct_count != 1:
            return False
        nasikh_verbs = ['كان', 'أصبح', 'أضحى', 'ظل', 'بات', 'صار', 'ليس', 'ما زال', 'ما برح', 'ما فتئ', 'ما انفك', 'دام']
        has_nasikh = any((verb in value_stripped for verb in nasikh_verbs))
        if not has_nasikh:
            return False
        attached_suffixes = ['كما', 'هما', 'هن', 'ت', 'تما', 'تم', 'تن', 'ني', 'ه', 'ها', 'ك', 'ي', 'نا', 'كم', 'هم', 'كن', 'ا', 'و', 'ن']
        attached_suffixes.sort(key=len, reverse=True)
        words = value_stripped.split()
        has_attached_pronoun = False
        arabic_char_pattern = '[\\u0600-\\u06FF]'
        words_cleaned = []
        for word in words:
            if word.endswith(terminal_punctuations[0]):
                word = word[:-1]
            word = word.strip()
            if word:
                words_cleaned.append(word)
        for word in words_cleaned:
            for suffix in attached_suffixes:
                if word.endswith(suffix):
                    prefix = word[:-len(suffix)]
                    if prefix and re.search(arabic_char_pattern, prefix):
                        has_attached_pronoun = True
                        break
            if has_attached_pronoun:
                break
        if has_attached_pronoun:
            return False
        return True



class DataIdx593InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_593')

    def check_following(self, value):
        """Checks if the response is a single sentence mentioning a fruit ('عنب') and a vegetable ('عدس') starting with 'ع'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentence_terminators = ['.', '!', '؟']
        terminator_count = sum((value.count(term) for term in sentence_terminators))
        if terminator_count > 1:
            return False
        has_enab = 'عنب' in value
        has_adas = 'عدس' in value
        return has_enab and has_adas



class DataIdx594InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_594')

    def check_following(self, value):
        """Checks if the response contains both a numbered list and a bulleted list."""
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        has_numbered_list = False
        has_bulleted_list = False
        numbered_pattern = '^[ \\t]*([0-9]+|[٠-٩]+)\\.\\s+'
        bulleted_pattern = '^[ \\t]*[-\\*\\•]\\s+'
        for line in lines:
            if re.match(numbered_pattern, line):
                has_numbered_list = True
            if re.match(bulleted_pattern, line):
                has_bulleted_list = True
            if has_numbered_list and has_bulleted_list:
                break
        return has_numbered_list and has_bulleted_list



class DataIdx595InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_595')

    def check_following(self, value):
        """Checks if the response is a paragraph of at least 30 words
        mentioning 'التعليم' at least 3 times.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        if len(words) < 30:
            return False
        education_count = words.count('التعليم')
        if education_count < 3:
            return False
        return True



class DataIdx596InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_596')

    def check_following(self, value):
        """Checks if the response meets the constraints for question 596.

        The response must have at least two paragraphs.
        The first paragraph must contain 100-150 words.
        The second paragraph must contain 75-100 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        paragraphs = [p.strip() for p in value.split('\n\n') if p.strip()]
        if len(paragraphs) < 2:
            return False
        para1 = paragraphs[0]
        para2 = paragraphs[1]
        word_count_para1 = len([word for word in para1.split() if word])
        if not 100 <= word_count_para1 <= 150:
            return False
        word_count_para2 = len([word for word in para2.split() if word])
        if not 75 <= word_count_para2 <= 100:
            return False
        return True



class DataIdx597InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_597')

    def check_following(self, value):
        """Checks if the response is a paragraph explaining the importance of teamwork and uses the word 'التعاون' at least twice.

        Args:
            value: A string representing the response.

        Returns:
            True if the response uses 'التعاون' at least twice, False otherwise.
        """
        count = value.count('التعاون')
        return count >= 2



class DataIdx598InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_598')

    def check_following(self, value):
        """Checks if the response is a question in Arabic without using a question mark.
        Note: This checker primarily focuses on the negative constraint (absence of '?').
              Checking if a string is a single question and in Modern Standard Arabic
              without a question mark is complex and beyond simple string checks.
              Therefore, this checker only verifies the absence of the question mark.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain a question mark, False otherwise.
        """
        if not isinstance(value, str):
            return False
        return '?' not in value



class DataIdx599InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_599')

    def check_following(self, value):
        """Checks if the response has exactly 15 characters (including spaces).

        Args:
            value: A string representing the response.

        Returns:
            True if the response has exactly 15 characters, False otherwise.
        """
        return len(value) == 15



class DataIdx600InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_600')

    def check_following(self, value):
        """
        Checks if the response converts the paragraph into a list format
        containing the key points from the original text.
        Specifically, it checks for the presence of key phrases
        across multiple lines in the response.
        """
        required_phrases = ['إدارة الوقت مهارة أساسية', 'تحديد الأولويات', 'تخطيط المهام', 'تجنب التسويف', 'تنظيم مكان العمل']
        lines = value.strip().split('\n')
        cleaned_lines = []
        for line in lines:
            cleaned_line = line.strip()
            if cleaned_line.startswith('*'):
                cleaned_line = cleaned_line[1:].strip()
            elif cleaned_line.startswith('-'):
                cleaned_line = cleaned_line[1:].strip()
            elif cleaned_line.startswith('•'):
                cleaned_line = cleaned_line[1:].strip()
            else:
                parts = cleaned_line.split('.', 1)
                if len(parts) > 1 and parts[0].isdigit():
                    cleaned_line = parts[1].strip()
            while cleaned_line and cleaned_line[-1] in '.,؛':
                cleaned_line = cleaned_line[:-1]
            cleaned_line = ' '.join(cleaned_line.split())
            if cleaned_line:
                cleaned_lines.append(cleaned_line)
        if len(cleaned_lines) < 4:
            return False
        all_phrases_found = True
        for phrase in required_phrases:
            phrase_found_in_any_line = False
            normalized_phrase = ' '.join(phrase.strip().split())
            for cleaned_line in cleaned_lines:
                if normalized_phrase in cleaned_line:
                    phrase_found_in_any_line = True
                    break
            if not phrase_found_in_any_line:
                all_phrases_found = False
                break
        return all_phrases_found



class DataIdx601InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_601')

    def check_following(self, value):
        """Checks if the response is a list of exactly five items, separated by comma, Arabic comma, or newline.
        Assumes the items are intended to be fruits, but primarily checks the count and list format.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains exactly 5 non-empty items after splitting by common list delimiters, False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.replace('\n', ',')
        cleaned_value = cleaned_value.replace('،', ',')
        items = cleaned_value.split(',')
        valid_items = [item.strip() for item in items if item.strip()]
        return len(valid_items) == 5



class DataIdx602InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_602')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 602.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        terminal_punctuations = ['.', '!', '?']
        terminal_count = sum((cleaned_value.count(p) for p in terminal_punctuations))
        if terminal_count > 1:
            return False
        forbidden_words = ['مهم', 'ضروري', 'أساسي', 'جوهري']
        forbidden_pattern = re.compile('\\b(' + '|'.join((re.escape(word) for word in forbidden_words)) + ')\\b')
        if forbidden_pattern.search(cleaned_value):
            return False
        return True



class DataIdx603InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('603')

    def check_following(self, value):
        """Checks if the response avoids negative words 'لا' and 'ليس'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if 'لا' in value or 'ليس' in value:
            return False
        return True



class DataIdx604InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('604')

    def check_following(self, value):
        """Checks if the response uses only exclamation marks at the end of sentences.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        forbidden_single_terminators = ['.', '؟']
        forbidden_multi_terminators = ['...']
        found_exclamation_terminator = False
        i = 0
        while i < len(value):
            if i + 2 < len(value) and value[i:i + 3] in forbidden_multi_terminators:
                if i + 3 >= len(value) or (i + 3 < len(value) and value[i + 3].isspace()):
                    return False
                i += 3
                continue
            char = value[i]
            if char in forbidden_single_terminators + ['!']:
                next_char_idx = i + 1
                if next_char_idx >= len(value) or (next_char_idx < len(value) and value[next_char_idx].isspace()):
                    if char in forbidden_single_terminators:
                        return False
                    elif char == '!':
                        found_exclamation_terminator = True
            i += 1
        return found_exclamation_terminator



class DataIdx605InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_605')

    def check_following(self, value):
        """Checks if the response is a maximum of two sentences.
        (Cannot reliably check for explanation correctness or example presence/correctness
        with simple string processing).

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains at most two sentences, False otherwise.
        """
        if not value or not value.strip():
            return False
        sentences = [s for s in value.replace('...', '.').split('.') if s.strip()]
        sentences = [s for s in ','.join(sentences).split('?') if s.strip()]
        sentences = [s for s in ','.join(sentences).split('!') if s.strip()]
        sentences_list = re.split('[.?!]+', value)
        sentence_count = sum((1 for sentence in sentences_list if sentence.strip()))
        return sentence_count <= 2



class DataIdx606InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_606')

    def check_following(self, value):
        """Checks if the response contains exactly two rhyming lines of poetry about Riyadh,
        not exceeding 30 words in total.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = [line.strip() for line in value.strip().split('\n') if line.strip()]
        if len(lines) != 2:
            return False
        line1 = lines[0]
        line2 = lines[1]
        all_text = line1 + ' ' + line2
        words = all_text.split()
        if len(words) > 30:
            return False
        punctuation_to_strip = '.,!?;:'

        def get_last_char_of_last_word(line):
            words_in_line = line.split()
            if not words_in_line:
                return None
            last_word = words_in_line[-1]
            last_word_stripped = last_word.rstrip(punctuation_to_strip)
            if not last_word_stripped:
                return None
            return last_word_stripped[-1]
        last_char_line1 = get_last_char_of_last_word(line1)
        last_char_line2 = get_last_char_of_last_word(line2)
        if last_char_line1 is None or last_char_line2 is None:
            return False
        if last_char_line1 != last_char_line2:
            return False
        return True



class DataIdx607InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_607')

    def check_following(self, value):
        """Checks if the response is a single sentence about the importance of sports,
        contains the word 'صحة' twice, and has no commas.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if ',' in value:
            return False
        words = value.split()
        sahha_count = words.count('صحة')
        if sahha_count < 2:
            return False
        return True



class DataIdx608InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_608')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 608.
        Constraints:
        1. Contains at least three sentences.
        2. Uses the word 'المعرفة' exactly once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        knowledge_count = value.count('المعرفة')
        if knowledge_count != 1:
            return False
        sentence_terminators = ['.', '!', '؟']
        sentences = []
        current_sentence = ''
        for char in value:
            current_sentence += char
            if char in sentence_terminators:
                cleaned_sentence = current_sentence.strip()
                if cleaned_sentence:
                    sentences.append(cleaned_sentence)
                current_sentence = ''
        cleaned_sentence = current_sentence.strip()
        if cleaned_sentence:
            sentences.append(cleaned_sentence)
        sentence_count = len(sentences)
        if sentence_count < 3:
            return False
        return True



class DataIdx609InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_609')

    def check_following(self, value):
        """Checks if the response contains a list of exactly five suggestions.
        This is done by splitting the response by lines and counting non-empty ones.

        Args:
            value: A string representing the response.

        Returns:
            True if the response appears to contain exactly 5 distinct items (lines), False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        suggestions = [line.strip() for line in lines if line.strip()]
        return len(suggestions) == 5



class DataIdx610InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_610')

    def check_following(self, value):
        """Checks if the response provides a brief description of steps for one deep breathing technique.

        The checks implemented are proxies for the constraints:
        1. Not empty: Response must contain text.
        2. Briefly describe steps: Checked via minimum and maximum word count,
           and the presence of some structural separation (like periods, commas, or newlines)
           indicating multiple points or steps are listed or described.
        3. One example: This constraint is difficult to verify reliably with simple string
           processing and is not explicitly checked. The length and structure constraints
           implicitly favor a single technique description.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction based on the implemented checks,
            or False otherwise.
        """
        if not value or not value.strip():
            return False
        words = value.split()
        word_count = len(words)
        MIN_WORDS = 10
        MAX_WORDS = 150
        if word_count < MIN_WORDS or word_count > MAX_WORDS:
            return False
        has_structure = False
        for char in ['.', ',', '\n', ';']:
            if char in value:
                has_structure = True
                break
        if not has_structure:
            return False
        return True



class DataIdx611InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_611')

    def check_following(self, value):
        """Checks if the response is a single sentence describing taste,
        uses sensory language, and includes the word 'لذيذ' at least once.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        response = value.strip()
        contains_laziz = 'لذيذ' in response
        sentence_enders = ['.', '!', '?']
        ender_count = sum((response.count(end) for end in sentence_enders))
        is_single_sentence = ender_count == 1 and response.endswith(tuple(sentence_enders))
        return contains_laziz and is_single_sentence



class DataIdx612InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_612')

    def check_following(self, value):
        """
        Checks if the response string represents a sentence with a maximum of 10 words.
        Note: This checker primarily verifies the word count constraint.
        Grammatical and semantic constraints (passive voice, starting verb,
        single sentence structure, describing event) are not verified
        due to the need for advanced NLP capabilities not available in this context.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return 1 <= word_count <= 10



class DataIdx613InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_613')

    def check_following(self, value):
        """
        Checks if the response potentially contains both a rephrased question and an answer.
        A basic check is implemented by looking for the presence of:
        1. An Arabic question mark '؟', indicating a question was asked or rephrased.
        2. At least one digit, indicating a numerical answer (common for age).

        This check is structural and does NOT verify the semantic correctness
        of the rephrasing or the accuracy of the answer. It only checks for
        the presence of common markers expected in such a response.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains both a question mark '؟' and at least one digit,
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        contains_question_mark = '؟' in value
        contains_digit = any((char.isdigit() for char in value))
        return contains_question_mark and contains_digit



class DataIdx614InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_614')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 614.

        Constraints:
        1. Use only colons for punctuation.
        2. Underline/italicize at least 8 words (checking for _word_ or *word* format).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        allowed_chars_pattern = re.compile('[^\\w\\s:]', re.UNICODE)
        if allowed_chars_pattern.search(value):
            non_alphanumeric_space = set(re.findall('[^\\w\\s]', value, re.UNICODE))
            if non_alphanumeric_space and non_alphanumeric_space != {':'}:
                return False
        formatted_words_us = re.findall('_[^_]+_', value)
        formatted_words_as = re.findall('\\*[^*]+\\*', value)
        all_formatted = [word[1:-1] for word in formatted_words_us] + [word[1:-1] for word in formatted_words_as]
        formatted_count = len(all_formatted)
        if formatted_count < 8:
            return False
        return True



class DataIdx615InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_615')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 615.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        repeated_request = "اكتب قائمة بأربعة أنواع من الفاكهة والخضروات. يجب أن تكون كل نقطة في القائمة كلمة واحدة فقط. كرر الطلب كلمة بكلمة دون تغيير، ثم قدم إجابتك. يجب أن تكون الكلمات بالترتيب الأبجدي. لا تستخدم حرف العطف 'أو' بين الكلمات."
        cleaned_value = value.strip()
        if not cleaned_value.startswith(repeated_request):
            return False
        answer_part_raw = cleaned_value[len(repeated_request):].strip()
        if 'أو' in answer_part_raw:
            return False
        answer_words_candidate = answer_part_raw.split()
        if len(answer_words_candidate) != 4:
            return False
        answer_words = answer_words_candidate
        if answer_words != sorted(answer_words):
            return False
        return True



class DataIdx616InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_616')

    def check_following(self, value):
        """Checks if the response contains the word 'مرح' at least 3 times.

        Args:
            value: A string representing the response (the email).

        Returns:
            True if the word 'مرح' appears 3 or more times, False otherwise.
        """
        count_marah = value.count('مرح')
        return count_marah >= 3



class DataIdx617InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_617')

    def check_following(self, value):
        """
        Checks if the response follows the constraints for IDX 617.
        Constraints:
        1. Exactly 26 sentences.
        2. No attached pronouns (ضمائر متصلة).
        """
        if not isinstance(value, str):
            return False
        sentences = re.split('[.!?؟]+', value)
        sentences = [s.strip() for s in sentences if s.strip()]
        sentence_count = len(sentences)
        if sentence_count != 26:
            return False
        attached_pronoun_suffixes = ['ه', 'ها', 'ي', 'ك', 'نا', 'كم', 'هم', 'هن', 'وا']
        words = value.split()
        for word in words:
            cleaned_word = word.strip().rstrip('.,!؟')
            for suffix in attached_pronoun_suffixes:
                if cleaned_word.endswith(suffix) and len(cleaned_word) > len(suffix):
                    return False
        return True



class DataIdx618InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_618')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 618.
        The main objective constraint is the word count.

        Constraints:
        - Write a short text message (implied by word limit)
        - Apologize for being late
        - Be polite (difficult to check programmatically)
        - Be short (implied by word limit)
        - Do not exceed 20 words

        This checker specifically verifies the word count constraint.

        Args:
            value: A string representing the response.

        Returns:
            True if the response has 20 words or less, False otherwise.
        """
        words = value.split()
        word_count = len(words)
        return word_count <= 20



class DataIdx619InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_619')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        bracketed_words = re.findall('\\[\\s*\\S+\\s*\\]', value)
        if len(bracketed_words) != 2:
            return False
        words = value.split()
        word_count = len(words)
        if word_count != 30:
            return False
        return True



class DataIdx620InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_620')

    def check_following(self, value):
        """Checks if the response contains five items separated by '، و'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        separator = '، و'
        items = value.split(separator)
        if len(items) != 5:
            return False
        for item in items:
            if not item.strip():
                return False
        return True



class DataIdx621InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_621')

    def check_following(self, value):
        """Checks if the response follows the constraints: max 50 words, no Af'aal Nasikha.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the verifiable instructions or False otherwise.
        """
        words_simple_split = value.split()
        word_count = len([w for w in words_simple_split if w.strip()])
        if word_count > 50:
            return False
        forbidden_single_words = ['كان', 'أصبح', 'صار', 'ليس', 'ظل', 'بات', 'أضحى', 'أمسى']
        forbidden_multi_words = ['ما زال', 'ما برح', 'ما فتئ', 'ما انفك', 'ما دام']
        punctuation_chars = '.,;?!«»()[]{}:\'"'
        cleaned_tokens = []
        for word in words_simple_split:
            cleaned_word = word
            while cleaned_word and cleaned_word[0] in punctuation_chars:
                cleaned_word = cleaned_word[1:]
            while cleaned_word and cleaned_word[-1] in punctuation_chars:
                cleaned_word = cleaned_word[:-1]
            if cleaned_word:
                cleaned_tokens.append(cleaned_word)
        for forbidden in forbidden_single_words:
            if forbidden in cleaned_tokens:
                return False
        for forbidden_phrase in forbidden_multi_words:
            if forbidden_phrase in value:
                return False
        return True



class DataIdx622InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_622')

    def check_following(self, value):
        """Checks if the response is the name of a single Arab country in Africa not starting with 'م'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        valid_countries = {'الجزائر', 'جيبوتي', 'ليبيا', 'المغرب', 'الصومال', 'السودان', 'تونس'}
        cleaned_value = value.strip()
        return cleaned_value in valid_countries



class DataIdx623InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_623')

    def check_following(self, value):
        """Checks if the response is one question in classical Arabic without using a question mark.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        has_arabic = False
        for char in value:
            if '\u0600' <= char <= 'ۿ':
                has_arabic = True
                break
        if not has_arabic:
            return False
        if '?' in value:
            return False
        if '.' in value or '!' in value or '...' in value:
            return False
        return True



class DataIdx624InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_624')

    def check_following(self, value):
        """Checks if the response defines AI without using the word 'ذكاء'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (does not contain 'ذكاء'), False otherwise.
        """
        forbidden_word = 'ذكاء'
        return forbidden_word not in value



class DataIdx625InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_625')

    def check_following(self, value):
        """Checks if the response is a persuasive paragraph about education using the word 'المعرفة' at least three times.
        Args:
            value: A string representing the response.

        Returns:
            True if the response uses 'المعرفة' three or more times, False otherwise.
        """
        keyword = 'المعرفة'
        count = value.count(keyword)
        return count >= 3



class DataIdx626InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_626')

    def check_following(self, value):
        """Checks if the response is a rewritten sentence with more words than the original 'الكتاب مفيد.'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is a string with more than 2 words, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        return len(words) > 2



class DataIdx627InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_627')

    def check_following(self, value):
        """Checks if the response meets the word count and keyword usage constraints.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = re.findall('\\b\\w+\\b', value)
        word_count = len(words)
        min_word_count_met = word_count >= 170
        keyword = 'النجاح'
        keyword_count = words.count(keyword)
        min_keyword_count_met = keyword_count >= 2
        return min_word_count_met and min_keyword_count_met



class DataIdx628InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_628')

    def check_following(self, value):
        """Checks if the response adheres to the constraints: max 60 words, includes 'تحسين' exactly once.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        punctuation = '،؛.:!؟٫'
        words = value.split()
        cleaned_words = []
        for word in words:
            cleaned_word = word.strip(punctuation)
            if cleaned_word:
                cleaned_words.append(cleaned_word)
        word_count = len(cleaned_words)
        if word_count > 60:
            return False
        target_word = 'تحسين'
        target_word_count = cleaned_words.count(target_word)
        if target_word_count != 1:
            return False
        return True



class DataIdx629InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_629')

    def check_following(self, value):
        """Checks if the response is a single Arabic sentence expressing opinion on continuous education,
        containing the words 'ضروري' and 'تطور'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        contains_daruri = 'ضروري' in value
        contains_tatawwur = 'تطور' in value
        sentence_terminators = ['.', '!', '؟']
        terminator_count = sum((value.count(term) for term in sentence_terminators))
        is_single_sentence = terminator_count <= 1
        return contains_daruri and contains_tatawwur and is_single_sentence



class DataIdx630InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_630')

    def check_following(self, value):
        """Checks if the response is a single Arabic imperative sentence encouraging daily Quran reading,
        using the word 'القرآن' exactly once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        value = value.strip()
        if not value:
            return False
        arabic_chars_present = any(('\u0600' <= char <= 'ۿ' or 'ݐ' <= char <= 'ݿ' for char in value))
        if not arabic_chars_present:
            return False
        cleaned_internal = re.sub('[.!?؟]$', '', value)
        if re.search('[.!?؟\\n]', cleaned_internal):
            return False
        punctuations = '.,;:"\'!?؟«»‘’“”()[]{}<>،؛'
        cleaned_value_for_word_count = ''.join((char if char not in punctuations else ' ' for char in value))
        words = cleaned_value_for_word_count.split()
        quran_count = words.count('القرآن')
        if quran_count != 1:
            return False
        return True



class DataIdx631InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_631')

    def check_following(self, value):
        """Checks if the response follows the instruction, specifically the word count constraint.

        Args:
            value: A string representing the response.

        Returns:
            True if the word count is 50 words or less, False otherwise.
        """
        words = value.split()
        if len(words) > 50:
            return False
        return True



class DataIdx632InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_632')

    def check_following(self, value):
        """Checks if the response is an Arabic sentence, focusing on feasibility without NLP libraries.
        Args:
            value: A string representing the response.

        Returns:
            True if the response contains Arabic characters (a necessary condition), False otherwise.
            Note: This checker cannot verify the grammatical structure (verb, subject, object)
            or the gender requirements for the subject and object without advanced NLP
            libraries which are not available under the constraints.
        """
        if not isinstance(value, str):
            return False
        value = value.strip()
        if not value:
            return False
        has_arabic_char = False
        for char in value:
            char_code = ord(char)
            if 1536 <= char_code <= 1791:
                has_arabic_char = True
                break
        if not has_arabic_char:
            return False
        words = value.split()
        if len(words) < 3:
            return False
        return True



class DataIdx633InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_633')

    def check_following(self, value):
        """Checks if the response is a paragraph about the importance of education in building societies,
           is around 110 words long, and contains the word 'تنمية' exactly twice.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        words = value.split()
        valid_words = [word for word in words if word]
        word_count = len(valid_words)
        min_word_count = 105
        max_word_count = 115
        if not min_word_count <= word_count <= max_word_count:
            return False
        tenmia_count = 0
        tenmia_word = 'تنمية'
        punctuation_to_strip = '.,!?:;،؛«»()[]{}'
        for word in valid_words:
            cleaned_word = word.strip(punctuation_to_strip)
            if cleaned_word == tenmia_word:
                tenmia_count += 1
        if tenmia_count != 2:
            return False
        return True



class DataIdx634InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_634')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 634.

        Instructions: Write a shopping list of three food items only.
                      The list must be written as bullet points.
                      Do not use any numbers.
                      Do not write the word 'و' (and) between items.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if any((char.isdigit() for char in value)):
            return False
        if 'و' in value:
            return False
        lines = value.splitlines()
        items = [line.strip() for line in lines if line.strip()]
        if len(items) != 3:
            return False
        return True



class DataIdx635InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_635')

    def check_following(self, value):
        """Checks if the response uses only third-person standalone pronouns by ensuring
        no first or second person standalone pronouns are present.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if no first or second person standalone pronouns are found, False otherwise.
        """
        forbidden_pronouns = ['أنا', 'نحن', 'أنتَ', 'أنتِ', 'أنتما', 'أنتم', 'أنتنّ']
        padded_value = ' ' + value + ' '
        for pronoun in forbidden_pronouns:
            if ' ' + pronoun + ' ' in padded_value:
                return False
        return True



class DataIdx636InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_636')

    def check_following(self, value):
        """Check if the response contains at least three digits.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains three or more digits, False otherwise.
        """
        digits = re.findall('\\d', value)
        return len(digits) >= 3



class DataIdx637InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_637')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 637.
           Specifically, checks if the response contains any numbers.
           Note: Other constraints (briefness, three steps, topic) are
           difficult to check programmatically with simple string analysis
           and are therefore not included in this automatic check.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain numbers, False otherwise.
        """
        if any((char.isdigit() for char in value)):
            return False
        return True



class DataIdx638InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_638')

    def check_following(self, value: str):
        """Checks if the response is a dialogue with at least 4 exchanges (2 per person)
           and exactly two speakers, based on simple speaker identification patterns.
           A line is considered an utterance if it starts with text followed by ':' or '-'.
           Does NOT check for topic or absence of imperative verbs due to complexity.
        """
        speaker_counts = {}
        lines = value.strip().splitlines()
        for line in lines:
            line = line.strip()
            if not line:
                continue
            split_char_idx = -1
            colon_idx = line.find(':')
            hyphen_idx = line.find('-')
            if colon_idx != -1 and (hyphen_idx == -1 or colon_idx < hyphen_idx):
                split_char_idx = colon_idx
            elif hyphen_idx != -1 and (colon_idx == -1 or hyphen_idx < colon_idx):
                split_char_idx = hyphen_idx
            if split_char_idx != -1:
                speaker = line[:split_char_idx].strip()
                if speaker:
                    speaker_counts[speaker] = speaker_counts.get(speaker, 0) + 1
        if len(speaker_counts) != 2:
            return False
        total_utterances = sum(speaker_counts.values())
        if total_utterances < 4:
            return False
        for count in speaker_counts.values():
            if count < 2:
                return False
        return True



class DataIdx639InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_639')

    def check_following(self, value):
        """
        Checks if the response is a single nominal sentence according to specific criteria.
        Constraints checked:
        1. Is a nominal sentence (checked by verifying the start of the sentence).
        2. Is only one sentence (interpreted as not containing explicit relative pronouns).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        words = cleaned_value.split()
        if not words:
            return False
        relative_pronouns = {'الذي', 'التي', 'الذين', 'اللاتي', 'اللائي', 'اللذان', 'اللتان'}
        if any((word in relative_pronouns for word in words)):
            return False
        first_word = words[0]
        starts_with_al = first_word.startswith('ال')
        common_pronouns = {'أنا', 'نحن', 'هو', 'هي', 'هم', 'هن', 'أنت', 'أنتم', 'أنتن', 'أنتما', 'هما', 'انا', 'نحن', 'هو', 'هي', 'هم', 'هن', 'انت', 'انتم', 'انتن', 'انتما', 'هما'}
        is_common_pronoun = first_word in common_pronouns
        if not starts_with_al and (not is_common_pronoun):
            return False
        return True



class DataIdx640InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_640')

    def check_following(self, value):
        """
        Checks if the response is a numbered list of exactly three tips for good health,
        where each tip starts with an imperative verb (weakly checked by ensuring
        the first word does not start with the definite article 'ال').

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.splitlines()
        expected_number = 1
        found_tips_count = 0
        numbered_line_pattern = re.compile('^\\s*(\\d+)\\.\\s*(.*)$')
        for line in lines:
            match = numbered_line_pattern.match(line)
            if match:
                num_str, tip_content_raw = match.groups()
                try:
                    num = int(num_str)
                except ValueError:
                    continue
                if num != expected_number:
                    return False
                found_tips_count += 1
                tip_content = tip_content_raw.strip()
                if not tip_content:
                    return False
                first_word_match = re.match('^\\s*(\\S+)', tip_content)
                if not first_word_match:
                    return False
                first_word = first_word_match.group(1)
                if first_word.startswith('ال'):
                    return False
                expected_number += 1
                if expected_number > 3:
                    pass
        return found_tips_count == 3



class DataIdx641InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_641')

    def check_following(self, value):
        """Checks if the response is an essay with at least 400 words.
        Args:
            value: A string representing the response (the essay).

        Returns:
            True if the response follows the instruction (at least 400 words), False otherwise.
        """
        words = value.split()
        word_count = len(words)
        return word_count >= 400



class DataIdx642InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_642')

    def check_following(self, value):
        """Checks if the response contains exactly three sentences.

        Args:
            value: A string representing the response.

        Returns:
            True if the response has exactly three sentences, False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentences = re.split('[.!?؟]+\\s*', value)
        non_empty_sentences = [s.strip() for s in sentences if s.strip()]
        sentence_count = len(non_empty_sentences)
        return sentence_count == 3



class DataIdx643InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_643')

    def check_following(self, value):
        """Checks if the response is a valid question transformation of 'الشمس تشرق كل صباح.'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value.endswith('?'):
            return False
        text_part = cleaned_value[:-1].strip()
        starts_with_hel = text_part.startswith('هل')
        starts_with_a = text_part.startswith('أ')
        if not (starts_with_hel or starts_with_a):
            return False
        if starts_with_hel and len(text_part) <= len('هل'):
            return False
        if starts_with_a and len(text_part) <= len('أ'):
            return False
        if 'الشمس' not in text_part:
            return False
        if 'تشرق' not in text_part:
            return False
        if 'كل صباح' not in text_part:
            return False
        negation_found = False
        negation_words = ['لا', 'لم', 'لن']
        for neg in negation_words:
            if f' {neg}' in text_part:
                negation_found = True
                break
            if text_part.startswith('هل' + neg) or text_part.startswith('أ' + neg):
                negation_found = True
                break
            if text_part.startswith(f'هل {neg}') or text_part.startswith(f'أ {neg}'):
                negation_found = True
                break
        if negation_found:
            return False
        return True



class DataIdx644InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_644')

    def check_following(self, value):
        """Checks if the response is the correct Arabic word for 'five'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is exactly 'خمسة', False otherwise.
        """
        correct_word = 'خمسة'
        return value == correct_word



class DataIdx645InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_645')

    def _arabic_to_int(self, arabic_str_part):
        """Converts a string of Arabic numerals to an integer.
           Returns None if the string contains non-Arabic numeral characters or is empty.
        """
        arabic_map = {'٠': '0', '١': '1', '٢': '2', '٣': '3', '٤': '4', '٥': '5', '٦': '6', '٧': '7', '٨': '8', '٩': '9'}
        standard_str = ''
        for char in arabic_str_part:
            if char in arabic_map:
                standard_str += arabic_map[char]
            else:
                return None
        if not standard_str:
            return None
        try:
            return int(standard_str)
        except ValueError:
            return None

    def check_following(self, value):
        """Checks if the response follows the instruction.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if '+' not in value:
            return False
        parts = [part.strip() for part in value.split('+')]
        if len(parts) != 2:
            return False
        part1_str = parts[0]
        part2_str = parts[1]
        num1 = self._arabic_to_int(part1_str)
        num2 = self._arabic_to_int(part2_str)
        if num1 is None or num2 is None:
            return False
        if num1 % 2 != 0 or num2 % 2 != 0:
            return False
        if abs(num1 - num2) != 2:
            return False
        return True



class DataIdx646InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_646')

    def check_following(self, value):
        """Checks if the response is a list of five items, each starting with 'ب'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        items = [item.strip() for item in value.splitlines() if item.strip()]
        if len(items) != 5:
            return False
        for item in items:
            if not item.startswith('ب'):
                return False
        return True



class DataIdx647InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('647')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        try:
            items = re.split('[,\\n]+', value)
        except ImportError:
            items = value.replace('\n', ',').split(',')
        cleaned_items = [item.strip() for item in items if item.strip()]
        return len(cleaned_items) == 13



class DataIdx648InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_648')

    def check_following(self, value):
        """Checks if the response is a single interrogative sentence asking for a name in Lebanese dialect.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value:
            return False
        if not value.strip().endswith('؟'):
            return False
        cleaned_value = value.strip()
        contains_name = 'اسم' in cleaned_value or 'إسم' in cleaned_value
        contains_sho = 'شو' in cleaned_value
        if not (contains_name and contains_sho):
            return False
        punctuation_count = cleaned_value.count('؟') + cleaned_value.count('.')
        if punctuation_count != 1:
            return False
        return True



class DataIdx649InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_649')

    def check_following(self, value):
        """Checks if the response contains exactly 25 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response has exactly 25 words, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        return len(words) == 25



class DataIdx650InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_650')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 650.
        Instructions: Write a description of a favorite place in two short paragraphs.
                      The first paragraph must contain the word 'مفضل' at least twice.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        paragraphs = []
        current_paragraph_lines = []
        for line in value.splitlines():
            if line.strip():
                current_paragraph_lines.append(line.strip())
            elif current_paragraph_lines:
                paragraphs.append(' '.join(current_paragraph_lines))
                current_paragraph_lines = []
        if current_paragraph_lines:
            paragraphs.append(' '.join(current_paragraph_lines))
        paragraphs = [p for p in paragraphs if p.strip()]
        if len(paragraphs) != 2:
            return False
        first_paragraph = paragraphs[0]
        matches = re.findall('\\bمفضل\\b', first_paragraph)
        if len(matches) < 2:
            return False
        return True



class DataIdx651InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_651')

    def check_following(self, value):
        """Checks if the response provides tips for learning a new language using ordered lists,
        mentions 'الممارسة' and 'الاستمرارية', and is over 250 words, with an informative tone.
        Checks are focused on measurable constraints: length, keywords, and ordered list format.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the measurable instructions or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        length_ok = word_count > 250
        keywords_present = 'الممارسة' in value and 'الاستمرارية' in value
        lines = value.splitlines()
        ordered_list_pattern = re.compile('^\\s*\\d+\\.\\s')
        list_items_count = 0
        for line in lines:
            if ordered_list_pattern.match(line):
                list_items_count += 1
        ordered_list_used = list_items_count >= 2
        return length_ok and keywords_present and ordered_list_used



class DataIdx652InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_652')

    def check_following(self, value):
        """Checks if the response is a single sentence with at least 12 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.strip().split()
        words = [word for word in words if word]
        word_count = len(words)
        terminal_punctuation = ['.', '!', '?']
        terminal_count = sum((value.count(p) for p in terminal_punctuation))
        return word_count >= 12



class DataIdx653InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_653')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 653.
        Instructions: Write a sentence about the importance of time, without using 'وقت' or 'زمن', but including 'الثانية'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        contains_waqt = 'وقت' in value
        contains_zaman = 'زمن' in value
        contains_thaniya = 'الثانية' in value
        return not contains_waqt and (not contains_zaman) and contains_thaniya



class DataIdx654InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_654')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 654.
        Instructions: Simple tea recipe with 4 numbered steps, use 'ماء' at least twice.
        Args:
            value: A string representing the response (the recipe).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        water_count = value.count('ماء')
        water_constraint_met = water_count >= 2
        lines = value.splitlines()
        found_step_1 = False
        found_step_2 = False
        found_step_3 = False
        found_step_4 = False
        numbered_starts_count = 0
        for line in lines:
            clean_line = line.strip()
            if clean_line.startswith('1.'):
                found_step_1 = True
                numbered_starts_count += 1
            elif clean_line.startswith('2.'):
                found_step_2 = True
                numbered_starts_count += 1
            elif clean_line.startswith('3.'):
                found_step_3 = True
                numbered_starts_count += 1
            elif clean_line.startswith('4.'):
                found_step_4 = True
                numbered_starts_count += 1
        step_constraint_met = numbered_starts_count == 4 and found_step_1 and found_step_2 and found_step_3 and found_step_4
        return water_constraint_met and step_constraint_met



class DataIdx655InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_655')

    def check_following(self, value):
        """Checks if the response mentions the word 'هواية' at least twice.
        Does NOT check for informal style or addressing style due to complexity.

        Args:
            value: A string representing the response.

        Returns:
            True if the response mentions 'هواية' at least twice, False otherwise.
        """
        if not isinstance(value, str):
            return False
        keyword = 'هواية'
        count = value.count(keyword)
        return count >= 2



class DataIdx656InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_656')

    def check_following(self, value):
        """Checks if the response is a question starting with 'هل' and ending with '؟'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        starts_with_hal = value.startswith('هل')
        ends_with_single_q_mark = value.endswith('؟') and (len(value) == 1 or value[-2] != '؟')
        return starts_with_hal and ends_with_single_q_mark



class DataIdx657InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_657')

    def check_following(self, value):
        """Checks if the response is a list of three single words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        items = [item.strip() for item in value.split('\n') if item.strip()]
        if len(items) != 3:
            return False
        for item in items:
            if ' ' in item or '\t' in item or '\n' in item or ('\r' in item):
                return False
            if not item:
                return False
        return True







class DataIdx659InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_659')

    def check_following(self, value):
        """Checks if the response compares coffee and tea in two paragraphs, starting with 'القهوة هي...' and 'الشاي هو...'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        normalized_value = value.replace('\r\n', '\n')
        paragraphs_raw = normalized_value.split('\n\n')
        paragraphs = [p.strip() for p in paragraphs_raw if p.strip()]
        if len(paragraphs) != 2:
            return False
        expected_start_paragraph1 = 'القهوة هي...'
        if not paragraphs[0].startswith(expected_start_paragraph1):
            return False
        expected_start_paragraph2 = 'الشاي هو...'
        if not paragraphs[1].startswith(expected_start_paragraph2):
            return False
        return True



class DataIdx660InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_660')

    def check_following(self, value):
        """Checks if the response contains any punctuation marks.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains no punctuation, False otherwise.
        """
        punctuation_chars = string.punctuation
        for char in value:
            if char in punctuation_chars:
                return False
        return True



class DataIdx661InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_661')

    def check_following(self, value):
        """Checks if the response follows the instructions for question IDX 661.

        Constraints:
        1. Exactly one sentence.
        2. Contains the word 'الشمس'.
        3. Contains the word 'السماء'.
        4. Does not use any exclamation marks (!).
        5. The sentence should express happiness about beautiful weather (checked implicitly by structure/keywords).

        Assuming "exactly one sentence" ending with a standard terminator (like '.') and no others.
        Based on the forbidden exclamation mark and the topic (declarative statement),
        a single full stop '.' is the expected terminator.
        Also assuming no question marks, as it's a statement of happiness.
        """
        if not isinstance(value, str):
            return False
        if '!' in value:
            return False
        if '?' in value:
            return False
        if value.count('.') != 1:
            return False
        if 'الشمس' not in value:
            return False
        if 'السماء' not in value:
            return False
        return True



class DataIdx662InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_662')

    def check_following(self, value):
        """Checks if the response contains the word 'قلم' at least three times.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        word_occurrences = re.findall('\\bقلم\\b', value)
        return len(word_occurrences) >= 3



class DataIdx663InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_663')

    def check_following(self, value):
        """Checks if the response follows the instruction for IDX 663.
        Constraints:
        1. At least two sentences.
        2. Mention at least two verbs (This constraint is difficult to check
           reliably with simple string processing and is primarily inferred
           from having descriptive sentences).

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains at least two sentence-ending punctuation marks, False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentence_terminators = ['.', '؟', '!']
        terminator_count = 0
        for char in value:
            if char in sentence_terminators:
                terminator_count += 1
        has_enough_sentences = terminator_count >= 2
        return has_enough_sentences



class DataIdx664InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_664')

    def check_following(self, value):
        """Checks if the response is written in the past tense only.
        Note: This is a heuristic check as perfect tense checking in Arabic
        requires sophisticated NLP which is beyond simple string checks.
        It checks for explicit non-past indicators.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain explicit non-past indicators,
            False otherwise.
        """
        non_past_indicators = ['سوف', 'الآن', 'غدًا', 'حاليًا', 'المستقبل']
        explicit_non_past_markers = ['سوف', 'الآن', 'غدًا', 'حاليًا', 'المستقبل']
        for marker in explicit_non_past_markers:
            if marker in value:
                return False
        return True



class DataIdx665InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_665')

    def check_following(self, value):
        """Checks if the response follows the constraints for IDX 665.
        Constraints:
        1. Less than 6 sentences.
        2. Includes the word 'شمس'.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instructions, False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentences = re.split('[.!?]', value)
        sentences = [s.strip() for s in sentences if s.strip()]
        sentence_count = len(sentences)
        sentence_count_ok = sentence_count < 6
        includes_shams = 'شمس' in value
        return sentence_count_ok and includes_shams



class DataIdx666InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_666')

    def check_following(self, value):
        """
        Checks if the response is a valid Arabic sentence where each word
        consists of at least 4 Arabic letters, based on the question constraints.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        contains_arabic = any(('\u0600' <= char <= 'ۿ' for char in value))
        if not contains_arabic:
            return False
        arabic_punctuation = '،؛؟!' + '.,'
        cleaned_value = value
        for p in arabic_punctuation:
            cleaned_value = cleaned_value.replace(p, '')
        words = cleaned_value.split()
        if not words:
            return False
        for word in words:
            arabic_letter_count = sum((1 for char in word if '\u0600' <= char <= 'ۿ' or 'ݐ' <= char <= 'ݿ' or 'ࢠ' <= char <= 'ࣿ' or ('ﭐ' <= char <= '﷿') or ('ﹰ' <= char <= '\ufeff')))
            arabic_letter_count = sum((1 for char in word if '\u0600' <= char <= 'ۿ'))
            if arabic_letter_count < 4:
                return False
        return True



class DataIdx667InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_667')

    def check_following(self, value):
        """Checks if the Arabic text value follows the instructions for IDX 667.

        The instructions are:
        1. The message must consist of exactly five sentences.
        2. The word 'خبرة' (experience) must be mentioned twice.
        3. The formal address 'حضرة السيد/السيدة' must be used.
        4. No abbreviations should be used.

        Args:
            value: A string representing the response (email body).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        text = value.strip()
        sentences = [s.strip() for s in re.split('[.!?؟]+', text) if s.strip()]
        is_five_sentences = len(sentences) == 5
        text_cleaned_for_word_count = re.sub('[^\\w\\s]', '', text)
        words = text_cleaned_for_word_count.split()
        khibrat_count = words.count('خبرة')
        is_khibrat_twice = khibrat_count == 2
        is_formal_address_used = 'حضرة السيد/السيدة' in text
        has_potential_abbreviation_pattern = bool(re.search('\\b[ا-ي]{1,3}\\.', text))
        is_no_abbreviations = not has_potential_abbreviation_pattern
        return is_five_sentences and is_khibrat_twice and is_formal_address_used and is_no_abbreviations



class DataIdx668InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_668')

    def check_following(self, value):
        """Checks if the response is structured in two separate paragraphs.
        The check looks for the presence of at least one blank line separating text segments.

        Args:
            value: A string representing the response.

        Returns:
            True if the response appears to be structured in at least two non-empty paragraphs, False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        normalized_value = value.replace('\r\n', '\n')
        paragraphs = normalized_value.split('\n\n')
        non_empty_paragraphs = [p.strip() for p in paragraphs if p.strip()]
        return len(non_empty_paragraphs) >= 2



class DataIdx669InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_669')

    def check_following(self, value):
        """Checks if the response explains at least two components of blended learning
           and uses '+++' as a separator.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        return '+++' in value



class DataIdx670InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_670')

    def check_following(self, value):
        """Checks if the response is a letter in four paragraphs,
        with each paragraph starting with 'صديقي' or 'صديقتي'.

        Args:
            value: A string representing the response (the letter).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        paragraphs = value.rstrip().split('\n\n')
        if len(paragraphs) != 4:
            return False
        required_starts = ('صديقي', 'صديقتي')
        for para in paragraphs:
            cleaned_para = para.strip()
            if not cleaned_para:
                return False
            starts_correctly = False
            for start_phrase in required_starts:
                if cleaned_para.startswith(start_phrase):
                    starts_correctly = True
                    break
            if not starts_correctly:
                return False
        return True



class DataIdx671InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_671')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 671.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        starts_correctly = value.strip().startswith('أستيقظ')
        sentence_endings = ['.', '!', '?']
        sentence_count = sum((value.count(ending) for ending in sentence_endings))
        has_enough_sentences = sentence_count >= 5
        return starts_correctly and has_enough_sentences



class DataIdx672InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_672')

    def check_following(self, value):
        """Checks if the response describes the tea preparation process in four numbered steps.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (exactly 4 numbered steps), False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        step_pattern = re.compile('^\\s*[0-9\\u0660-\\u0669]+[.\\-):]\\s*.+')
        numbered_step_count = 0
        for line in lines:
            if step_pattern.match(line):
                numbered_step_count += 1
        return numbered_step_count == 4



class DataIdx673InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_673')

    def check_following(self, value):
        """Checks if the response mentions one Arab city in a single sentence using 'تاريخ' and 'عريق'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        uses_tareekh = 'تاريخ' in value
        uses_areeq = 'عريق' in value
        if not uses_tareekh or not uses_areeq:
            return False
        sentence_terminators = ['.', '!', '?']
        is_single_sentence = True
        if len(value) > 0:
            for char in value[:-1]:
                if char in sentence_terminators:
                    is_single_sentence = False
                    break
        return is_single_sentence



class DataIdx674InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_674')

    def check_following(self, value):
        """
        Checks if the response follows the instructions for IDX 674.
        Instructions:
        - Be a single paragraph.
        - Consist of exactly three sentences.
        - Contain the word 'تفاعلية'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows all instructions, False otherwise.
        """
        if not value or not value.strip():
            return False
        if '\n\n' in value:
            return False
        sentence_endings = re.findall('[.؟!]', value)
        num_sentences = len(sentence_endings)
        sentences_count_correct = num_sentences == 3
        keyword_present = 'تفاعلية' in value
        return sentences_count_correct and keyword_present



class DataIdx675InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_675')

    def check_following(self, value):
        """Checks if the response follows the instructions:
        - Is in Arabic (assumed, not strictly checked)
        - Does not talk about animals (semantic, not strictly checked)
        - Does not use the word "شجرة".

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the checkable constraints, False otherwise.
        """
        forbidden_word = 'شجرة'
        if forbidden_word in value:
            return False
        return True



class DataIdx676InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_676')

    def check_following(self, value):
        """Checks if the response lists exactly two famous Arab writers from the modern era,
        each on a separate line, without using titles before the names.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        non_empty_lines = [line.strip() for line in lines if line.strip()]
        if len(non_empty_lines) != 2:
            return False
        forbidden_titles = ['الأستاذ', 'الدكتور', 'السيد', 'الكاتب', 'الشاعر', 'الأديب', 'الشيخ', 'الحاج', 'المرحوم', 'الأستاذ الدكتور', 'أستاذ', 'دكتور', 'سيد', 'كاتب', 'شاعر', 'أديب', 'شيخ', 'حاج', 'مرحوم']
        for line in non_empty_lines:
            for title in forbidden_titles:
                if line.startswith(title + ' '):
                    return False
            if line in forbidden_titles:
                return False
        return True



class DataIdx677InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_677')

    def check_following(self, value):
        """Checks if the response is a JSON object representing a student with 'Name', 'Age', and 'field_of_study' keys.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        try:
            data = json.loads(value)
        except json.JSONDecodeError:
            return False
        if not isinstance(data, dict):
            return False
        required_keys = ['Name', 'Age', 'field_of_study']
        for key in required_keys:
            if key not in data:
                return False
        return True



class DataIdx678InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_678')

    def check_following(self, value):
        """Checks if the response starts with 'كان يا مكان...'

        Args:
            value: A string representing the response.

        Returns:
            True if the response starts with 'كان يا مكان...' or False otherwise.
        """
        required_start = 'كان يا مكان...'
        return value.startswith(required_start)



class DataIdx679InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_679')

    def check_following(self, value):
        """Checks if the response contains at least two questions and is about space exploration in a paragraph.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        question_marks_count = value.count('?')
        space_keywords = ['الفضاء', 'استكشاف', 'كون', 'نجوم', 'كواكب', 'مجرات', 'قمر', 'شمس', 'أرض', 'مريخ', 'زهرة', 'عطارد', 'مشتري', 'زحل', 'أورانوس', 'نبتون', 'مركبة فضائية', 'صاروخ', 'محطة فضائية', 'رائد فضاء', 'تلسكوب', 'مدار', 'رحلة فضائية', 'كوكب', 'مجرة', 'بعثة فضائية', 'السماء', 'مدار']
        is_about_space = any((keyword in value for keyword in space_keywords))
        return question_marks_count >= 2 and is_about_space



class DataIdx680InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_680')

    def check_following(self, value):
        """
        Checks if the response contains linguistic indicators of mentioning 'three'
        areas and not mentioning 'four or more'. This serves as a proxy check
        for the constraint to mention exactly three main areas.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains indicators for 'three' and no indicators
            for 'four or more', False otherwise.
        """
        if not isinstance(value, str):
            return False
        indicators_of_three_word = {'ثلاثة', 'الثالث', 'ثالثاً'}
        indicators_of_four_plus_word = {'أربعة', 'الرابع', 'رابعاً', 'خمسة', 'الخامس', 'خامساً', 'ستة', 'السادس', 'سادساً'}
        has_three_word_indicator = any((marker in value for marker in indicators_of_three_word))
        has_four_plus_word_indicator = any((marker in value for marker in indicators_of_four_plus_word))
        pattern_three_digit = re.compile('(?<!\\d)[3٣](?!\\d)')
        pattern_four_plus_digit = re.compile('(?<!\\d)[4٥٦٧٨٩٤](?!\\d)')
        has_three_digit_indicator = bool(pattern_three_digit.search(value))
        has_four_plus_digit_indicator = bool(pattern_four_plus_digit.search(value))
        contains_indicator_for_three = has_three_word_indicator or has_three_digit_indicator
        contains_indicator_for_four_plus = has_four_plus_word_indicator or has_four_plus_digit_indicator
        return contains_indicator_for_three and (not contains_indicator_for_four_plus)



class DataIdx681InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_681')

    def check_following(self, value):
        """Checks if the response contains sections for ingredients and steps for a recipe,
        based on the presence of common Arabic keywords.

        Args:
            value: A string representing the response (the recipe).

        Returns:
            True if the response appears to follow the structural instruction (includes ingredients and steps), False otherwise.
        """
        if not isinstance(value, str):
            return False
        ingredient_indicators = ['المكونات', 'قائمة المكونات', 'المقادير']
        step_indicators = ['خطوات التحضير', 'الطريقة', 'كيفية التحضير']
        has_ingredients_section = any((indicator in value for indicator in ingredient_indicators))
        has_steps_section = any((indicator in value for indicator in step_indicators))
        return has_ingredients_section and has_steps_section



class DataIdx682InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_682')

    def check_following(self, value):
        """
        Checks if the response is a string, approximately 60 words,
        and contains at least two double quotation marks.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instructions, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        word_count_ok = 50 <= word_count <= 70
        quote_count = value.count('"')
        quote_count_ok = quote_count >= 2
        return word_count_ok and quote_count_ok



class DataIdx683InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_683')

    def check_following(self, value):
        """Checks if the response is a string consisting of exactly two words.

        Args:
            value: A string representing the response (the proposed company name).

        Returns:
            True if the response is a string and contains exactly two words, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        return len(words) == 2



class DataIdx684InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_684')

    def check_following(self, value):
        """Checks if the response is a sentence containing exactly ten words.
        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response contains exactly 10 words, False otherwise.
        """
        words = value.split()
        num_words = len(words)
        return num_words == 10



class DataIdx685InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_685')

    def check_following(self, value):
        """Checks if the response is a short play with one scene, two characters (seller and buyer),
        at least 10 lines of dialogue, and the dialogue is about buying a book.

        Args:
            value: A string representing the response (the play script).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        dialogue_lines_count = 0
        encountered_character_names = set()
        required_characters = {'بائع', 'مشتري'}
        lines = value.strip().split('\n')
        for line in lines:
            line = line.strip()
            if not line:
                continue
            colon_index = line.find(':')
            if colon_index != -1:
                potential_character_name = line[:colon_index].strip()
                if potential_character_name in required_characters:
                    dialogue_lines_count += 1
                    encountered_character_names.add(potential_character_name)
                else:
                    return False
            else:
                pass
        if dialogue_lines_count < 10:
            return False
        if encountered_character_names != required_characters:
            return False
        return True



class DataIdx686InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_686')

    def check_following(self, value):
        """Checks if the response is a simple fruit salad recipe including:
        - A list of ingredients (indicated by heading "المكونات" and content)
        - Numbered preparation steps (indicated by heading "خطوات التحضير" and numbered lines)
        - Use of imperative verbs in preparation steps.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        ingredients_heading = 'المكونات'
        steps_heading = 'خطوات التحضير'
        ingredients_idx = value.find(ingredients_heading)
        steps_idx = value.find(steps_heading)
        if ingredients_idx == -1 or steps_idx == -1 or ingredients_idx >= steps_idx:
            return False
        ingredients_content = value[ingredients_idx + len(ingredients_heading):steps_idx]
        if not ingredients_content.strip():
            return False
        steps_text = value[steps_idx + len(steps_heading):]
        numbered_lines = re.findall('^\\s*\\d+\\.', steps_text, re.MULTILINE)
        if len(numbered_lines) < 2:
            return False
        imperative_verbs = ['اقطع', 'اغسل', 'اخلط', 'أضف', 'ضع', 'زين', 'قدم', 'قشر', 'انزع', 'اترك', 'سخن', 'برد', 'صب', 'تأكد', 'استخدم', 'اسكب', 'قلب', 'صفف', 'تجنب', 'احذر', 'لاحظ', 'اغرف']
        imperative_found = False
        for verb in imperative_verbs:
            if re.search('\\b' + re.escape(verb) + '\\b', steps_text):
                imperative_found = True
                break
        if not imperative_found:
            return False
        return True



class DataIdx687InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_687')

    def check_following(self, value):
        """Checks if the response mentions the word 'نعناع' at least four times.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        required_word = 'نعناع'
        min_count = 4
        word_count = value.count(required_word)
        return word_count >= min_count



ARABIC_COMMON_FUNCTION_WORDS = {'من', 'إلى', 'على', 'عن', 'في', 'ب', 'ل', 'ك', 'و', 'ف', 'ثم', 'أو', 'أم', 'بل', 'لكن', 'يا', 'أيها', 'أيتها', 'هل', 'أين', 'متى', 'كيف', 'لماذا', 'من', 'ما', 'ماذا', 'أي', 'كم', 'أن', 'إن', 'كأن', 'لكن', 'ليت', 'لعل', 'قد', 'سوف', 'السين', 'تاء', 'لا', 'لم', 'لن', 'لما', 'ليس', 'غير', 'سوى', 'إذا', 'إذ', 'حيث', 'حين', 'هذا', 'هذه', 'هذان', 'هاتان', 'هؤلاء', 'ذلك', 'تلك', 'أولئك', 'الذي', 'التي', 'اللذان', 'اللتان', 'الذين', 'اللاتي', 'اللواتي', 'أنا', 'نحن', 'أنت', 'أنتما', 'أنتم', 'أنتن', 'هو', 'هما', 'هم', 'هن', 'إياك', 'إياكما', 'إياكم', 'إياكن', 'إياه', 'إياهما', 'إياهم', 'إياهن', 'كل', 'بعض', 'جميع', 'عامة', 'خاصة', 'نفس', 'عين', 'فوق', 'تحت', 'أمام', 'خلف', 'يمين', 'يسار', 'حول', 'بين', 'عند', 'لدى', 'مع', 'قبل', 'بعد', 'دون', 'مثل', 'إزاء', 'تجاه', 'صوب', 'شطر', 'كان', 'يكون', 'كن', 'ليس', 'صار', 'أصبح', 'أضحى', 'ظل', 'بات', 'مازال', 'مابرح', 'مافتئ', 'ماانفك', 'دام', 'قال', 'يقول', 'قل', 'على', 'إلى', 'عن', 'في', 'الباء', 'الكاف', 'اللام', 'واو', 'فاء', 'هناك', 'هنا', 'هناك'}
ARABIC_QUESTION_WORDS = {'هل', 'أين', 'متى', 'كيف', 'لماذا', 'من', 'ما', 'ماذا', 'أي', 'أية', 'أيهم', 'كم'}
ARABIC_PUNCTUATION = string.punctuation + '،؛؟!'

class DataIdx688InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_688')

    def check_following(self, value: str):
        """
        Checks if the response follows the instructions for IDX 688.
        - Must be between 80 and 100 words.
        - Must mention the main character's name (checked heuristically by finding a word
          that is not a common function word/particle and is longer than 1 character,
          and doesn't start with 'ال').
        - Must not use any interrogative sentences (no ? and no question words).
        """
        if '؟' in value:
            return False
        cleaned_value = value
        for p in ARABIC_PUNCTUATION:
            cleaned_value = cleaned_value.replace(p, ' ')
        cleaned_value = re.sub('\\s+', ' ', cleaned_value).strip()
        tokens = cleaned_value.split()
        word_count = len(tokens)
        if not 80 <= word_count <= 100:
            return False
        if any((token in ARABIC_QUESTION_WORDS for token in tokens)):
            return False
        name_found = False
        for token in tokens:
            token = token.strip()
            if not token:
                continue
            is_common_word = token in ARABIC_COMMON_FUNCTION_WORDS
            is_too_short = len(token) <= 1
            starts_with_al = token.startswith('ال')
            if not is_common_word and (not is_too_short) and (not starts_with_al):
                name_found = True
                break
        if not name_found:
            return False
        return True



class DataIdx689InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_689')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 689.
        Constraints:
        1. Use the keyword "العالمية" (global/international) at least three times.
        2. The answer must be in a single paragraph.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        keyword = 'العالمية'
        keyword_count = value.count(keyword)
        keyword_condition = keyword_count >= 3
        paragraph_condition = '\n\n' not in value.strip()
        return keyword_condition and paragraph_condition



class DataIdx690InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_690')

    def check_following(self, value):
        """Checks if the response uses the word 'العربية' at least three times.

        Args:
            value: A string representing the response.

        Returns:
            True if the word 'العربية' appears 3 or more times, False otherwise.
        """
        if not isinstance(value, str):
            return False
        count = value.count('العربية')
        return count >= 3



class DataIdx691InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_691')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 691.

        Args:
            value: A string representing the response (description).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().splitlines()
        num_lines = len(lines)
        if not 4 <= num_lines <= 6:
            return False
        if 'شجاع' not in value:
            return False
        return True



class DataIdx692InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_692')

    def check_following(self, value):
        """Checks if the response contains the word 'ضروري' at least three times.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        required_word = 'ضروري'
        count = value.count(required_word)
        return count >= 3



class DataIdx693InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_693')

    def check_following(self, value):
        """Checks if the response ends with a question mark.

        Args:
            value: A string representing the response.

        Returns:
            True if the response ends with a question mark, False otherwise.
        """
        if not isinstance(value, str):
            return False
        return value.endswith('؟') or value.endswith('?')



class DataIdx694InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_694')

    def check_following(self, value):
        """Checks if the response includes the word 'الاحترام' at least twice.

        Args:
            value: A string representing the response.

        Returns:
            True if the response includes 'الاحترام' at least twice, False otherwise.
        """
        count_respect = value.count('الاحترام')
        return count_respect >= 2



class DataIdx695InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_695')

    def check_following(self, value):
        """Checks if the value starts with the Arabic letter 'العين' (Ain, ع).
        This checker verifies the constraint that the answer must begin with 'ع',
        as requested in the question. It cannot programmatically verify if the
        provided value is actually the name of a Sahabi Jaleel without external data.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is a non-empty string starting with 'ع'
            after stripping leading/trailing whitespace, False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        return value.strip().startswith('ع')



class DataIdx696InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_696')

    def check_following(self, value):
        """Checks if the response lists the three primary colors in Classical Arabic with the definite article.

        The required colors are الأحمر, الأزرق, and الأصفر. Each must be
        present in the response, and the response should effectively list only these three
        using their standard names with the definite article (ال) or common prefixed forms (like وال).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        required_colors = {'الأحمر', 'الأزرق', 'الأصفر'}
        found_relevant_colors = set()
        for color in required_colors:
            if color in value:
                found_relevant_colors.add(color)
        for color in required_colors:
            if 'و' + color in value or 'و ' + color in value:
                found_relevant_colors.add(color)
        for color in required_colors:
            if color.startswith('ال'):
                stem = color[len('ال'):]
                if 'وال' + stem in value:
                    found_relevant_colors.add(color)
        return found_relevant_colors == required_colors



class DataIdx697InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_697')

    def check_following(self, value):
        """Checks if the response is a comma-separated list of 10 items
           with a total word count exceeding 50.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        items = value.split(',')
        num_items = len(items)
        words = value.split()
        total_words = len(words)
        item_count_ok = num_items == 10
        word_count_ok = total_words > 50
        return item_count_ok and word_count_ok



class DataIdx698InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_698')

    def check_following(self, value):
        """Checks if the response follows the instruction: Answer 'نعم' or 'لا' only,
        separated from the word 'سماء' by six stars (******), and the answer must be a single word.
        Expected format: [answer]******سماء

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        expected_answer_yes = 'نعم******سماء'
        expected_answer_no = 'لا******سماء'
        return value == expected_answer_yes or value == expected_answer_no



class DataIdx699InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_699')

    def check_following(self, value):
        """Checks if the response is a short news report in Arabic about a sports event,
           in the past tense, and does not exceed 70 words.

           Note: This checker primarily focuses on the word count constraint
           as checking language, topic, and tense reliably requires advanced NLP,
           which is beyond the scope of simple function checks.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the constraints (specifically word count),
            or False otherwise.
        """
        words = value.split()
        word_count = len(words)
        return word_count <= 70



class DataIdx700InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_700')

    def check_following(self, value):
        """Checks if the response follows the constraints for question 700.
        Constraints:
        1. Answer in three points, bulleted list.
        2. Avoid using the word 'الإسلامي'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if 'الإسلامي' in value:
            return False
        lines = value.splitlines()
        bullet_count = 0
        bullet_markers = ('-', '*', '•')
        for line in lines:
            stripped_line = line.lstrip()
            if stripped_line.startswith(bullet_markers):
                bullet_count += 1
        return bullet_count == 3



class DataIdx701InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_701')

    def check_following(self, value):
        """Checks if the response is a formal apology email avoiding colloquial language
           by verifying the presence of formal and apology terms.

        Args:
            value: A string representing the response.

        Returns:
            True if the response shows signs of being a formal apology email,
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        apology_terms = ['أعتذر', 'نأسف', 'اعتذار']
        formal_indicators = ['تحية طيبة وبعد', 'مع خالص التقدير', 'احتراماً', 'احترامنا', 'وتفضلوا بقبول فائق الاحترام', 'السيد', 'السيدة']
        has_apology_term = any((term in value for term in apology_terms))
        has_formal_indicator = any((phrase in value for phrase in formal_indicators))
        return has_apology_term and has_formal_indicator



class DataIdx702InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_702')

    def check_following(self, value):
        """Checks if the response is an unnumbered list of 4 items,
        where each item starts with the Arabic definite article 'ال'.
        """
        if not isinstance(value, str):
            return False
        lines = value.splitlines()
        items = [line.strip() for line in lines if line.strip()]
        if len(items) != 4:
            return False
        for item in items:
            if not item.startswith('ال'):
                return False
        return True



class DataIdx703InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_703')

    def check_following(self, value):
        """Checks if the response is a single word, starts with 'ب', and meets the 'uppercase' constraint (interpreted for Arabic).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        cleaned_value = str(value).strip()
        if not cleaned_value:
            return False
        if len(cleaned_value.split()) != 1:
            return False
        if not cleaned_value.startswith('ب'):
            return False
        return True



class DataIdx704InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_704')

    def check_following(self, value):
        """Checks if the response (tweet) meets the following constraints:
        1. Starts with a hashtag (#).
        2. Contains the word 'فوز' (win) at least once.

        Args:
            value: A string representing the response (the tweet).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        starts_with_hashtag = len(value) > 0 and value.strip().startswith('#')
        contains_word = 'فوز' in value
        return starts_with_hashtag and contains_word



class DataIdx705InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_705')

    def check_following(self, value):
        """Checks if the response provides exactly five examples, each in a single sentence, in Arabic.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not value or not isinstance(value, str):
            return False
        arabic_chars_present = False
        for char in value:
            if '\u0600' <= char <= 'ۿ' or 'ݐ' <= char <= 'ݿ' or 'ࢠ' <= char <= 'ࣿ' or ('ﭐ' <= char <= '﷿') or ('ﹰ' <= char <= '\ufeff'):
                arabic_chars_present = True
                break
        if not arabic_chars_present:
            return False
        sentences = re.split('[.!?]+\\s*', value)
        valid_sentences = [s.strip() for s in sentences if s.strip()]
        return len(valid_sentences) == 5



class DataIdx706InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_706')

    def check_following(self, value):
        """
        Checks if the response is a paragraph describing the importance of
        preserving Arab architectural heritage with exactly 23 sentences and
        without using the conjunctions 'و', 'ف', 'ثم', 'أو'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentence_delimiters = ['.', '!', '?']
        sentence_count = 0
        for delimiter in sentence_delimiters:
            sentence_count += value.count(delimiter)
        if sentence_count != 23:
            return False
        forbidden_conjunctions = ['و', 'ف', 'ثم', 'أو']
        for conj in forbidden_conjunctions:
            if conj in value:
                return False
        return True



class DataIdx707InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_707')

    def check_following(self, value):
        """Checks if the response contains exactly two titles enclosed in << >>,
        the first with < 5 words and the second with > 10 words, appearing sequentially
        with only whitespace allowed between them and surrounding the block.
        """
        stripped_value = value.strip()
        if not stripped_value.startswith('<<'):
            return False
        end1 = stripped_value.find('>>', 2)
        if end1 == -1:
            return False
        title1_raw = stripped_value[2:end1]
        title1 = title1_raw.strip()
        remaining = stripped_value[end1 + 2:]
        remaining_stripped = remaining.lstrip()
        if not remaining_stripped.startswith('<<'):
            return False
        end2_in_remaining_stripped = remaining_stripped.find('>>', 2)
        if end2_in_remaining_stripped == -1:
            return False
        title2_raw = remaining_stripped[2:end2_in_remaining_stripped]
        title2 = title2_raw.strip()
        if remaining_stripped[end2_in_remaining_stripped + 2:].strip() != '':
            return False

        def count_words(text):
            words = text.split()
            return len(words)
        if count_words(title1) >= 5:
            return False
        if count_words(title2) <= 10:
            return False
        return True



class DataIdx708InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_708')

    def is_arabic_letters_only(self, s):
        """Helper to check if a string contains only basic Arabic letters."""
        if not s:
            return False
        for char in s:
            code = ord(char)
            if not (1569 <= code <= 1594 or 1601 <= code <= 1610):
                return False
        return True

    def check_following(self, value):
        """Checks if the response is a single 18-word declarative sentence in Arabic
           containing a past tense verb.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        cleaned_value = value.strip()
        if not cleaned_value.endswith('.'):
            return False
        internal_content = cleaned_value[:-1]
        sentence_terminators = ['.', '!', '?']
        for term in sentence_terminators:
            if term in internal_content:
                return False
        words = internal_content.split()
        if len(words) != 18:
            return False
        past_tense_suffixes = ['تْ', 'وا', 'نا', 'نَ', 'تُ', 'تَ', 'تِ', 'تُمَا', 'تُمْ', 'تُنَّ']
        common_past_verbs = ['كان', 'قال', 'ذهب', 'كتب', 'قرأ', 'أكل', 'شرب', 'نام', 'قام', 'عاد', 'جاء', 'رأى', 'مشى', 'رمى', 'دعا', 'فعل', 'عمل', 'علم', 'وجد', 'أخذ', 'أمر', 'أتى', 'بنى', 'نسي', 'سار', 'باع', 'صام', 'بات', 'صار', 'ظل', 'أصبح', 'أمسى', 'أضحى', 'ليس', 'شاهد', 'زار', 'فهم', 'ترك', 'دخل', 'خرج', 'فتح', 'أغلق', 'بدأ', 'انتهى']
        found_past_verb = False
        for word in words:
            cleaned_word = word.rstrip(',;:"\'')
            if not cleaned_word:
                continue
            if cleaned_word in common_past_verbs:
                found_past_verb = True
                break
            for suffix in past_tense_suffixes:
                if cleaned_word.endswith(suffix) and len(cleaned_word) > len(suffix):
                    root_candidate = cleaned_word[:-len(suffix)]
                    if len(root_candidate) >= 2 and self.is_arabic_letters_only(root_candidate):
                        found_past_verb = True
                        break
            if found_past_verb:
                break
        return found_past_verb



class DataIdx709InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_709')

    def check_following(self, value):
        """Checks if the response follows the instruction not to use exclamation marks.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain any exclamation marks, False otherwise.
        """
        return '!' not in value



class DataIdx710InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_710')

    def check_following(self, value):
        """Checks if the response describes photosynthesis using at least 6 sentences
           and italicizes at least 3 scientific terms using single asterisks.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        sentences = re.split('[.!?]+', value)
        valid_sentences = [s.strip() for s in sentences if s.strip()]
        sentence_count = len(valid_sentences)
        italicized_terms = re.findall('\\*(.*?)\\*', value)
        italicized_count = len(italicized_terms)
        return sentence_count >= 6 and italicized_count >= 3



class DataIdx711InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_711')

    def check_following(self, value):
        """Checks if the response includes the phrase 'نتشرف بحضوركم'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response includes the phrase 'نتشرف بحضوركم', False otherwise.
        """
        required_phrase = 'نتشرف بحضوركم'
        return required_phrase in value



class DataIdx712InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_712')

    def check_following(self, value):
        """Checks if the response starts with 'أعتقد أن' and contains 'المستقبل' at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        starts_correctly = value.strip().startswith('أعتقد أن')
        contains_future = 'المستقبل' in value
        return starts_correctly and contains_future



class DataIdx713InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_713')

    def check_following(self, value):
        """Checks if the response is an Arabic slogan not exceeding 5 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not value or not isinstance(value, str):
            return False
        arabic_regex = re.compile('[\\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF\\uFB50-\\uFDFF\\uFE70-\\uFEFF]')
        if not arabic_regex.search(value):
            return False
        words = value.split()
        if len(words) > 5:
            return False
        return True



class DataIdx714InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('714')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 714.
        Constraints:
        - Write a short advertisement about a new product (e.g., mobile phone). (Difficult to check programmatically)
        - The advertisement must focus on three main features. (Difficult to check programmatically)
        - It must end with a catchy slogan. (Difficult to check programmatically)
        - The word count must be at least 40 words. (Checkable)

        Args:
            value: A string representing the response (the advertisement text in Arabic).

        Returns:
            True if the response follows the checkable instruction (word count), False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return word_count >= 40



class DataIdx715InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_715')

    def check_following(self, value):
        """Checks if the response follows the instructions for Q715.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        value = value.strip()
        if len(value) < 20:
            return False
        joy_appreciation_terms = ['مبروك', 'تهانينا', 'فرحت لك', 'فخور بك', 'جهدك', 'تعبك', 'يستحق', 'نجاحك']
        future_success_terms = ['التوفيق', 'المستقبل', 'حياتك القادمة', 'مسيرتك', 'أتمنى لك', 'بالتوفيق']
        has_joy_appreciation = any((term in value for term in joy_appreciation_terms))
        has_future_success = any((term in value for term in future_success_terms))
        if not has_joy_appreciation or not has_future_success:
            return False
        singular_address_indicators = ['تخرجك', 'جهدك', 'تعبك', 'نجاحك', 'لك', 'بك', 'عليك', 'إليك', 'فيك', 'منك', 'عنك', 'أتمنى لك', 'فخور بك']
        plural_address_indicators = ['تخرجكم', 'جهدكم', 'تعبكم', 'نجاحكم', 'لكم', 'بكم', 'عليكم', 'إليكم', 'فيكم', 'منكم', 'عنكم', 'أتمنى لكم', 'فخور بكم']
        has_singular_address_indicator = any((indicator in value for indicator in singular_address_indicators))
        has_plural_address_indicator = any((indicator in value for indicator in plural_address_indicators))
        if not has_singular_address_indicator or has_plural_address_indicator:
            return False
        if len(value) > 400:
            return False
        return True



class DataIdx716InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_716')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        try:
            data = json.loads(value)
            if not isinstance(data, list):
                return False
            if not data:
                return False
            for item in data:
                if not isinstance(item, dict):
                    return False
                if 'name' not in item or 'currency' not in item:
                    return False
                if not isinstance(item['name'], str) or not isinstance(item['currency'], str):
                    return False
            return True
        except json.JSONDecodeError:
            return False
        except Exception:
            return False



class DataIdx717InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_717')

    def check_following(self, value):
        """Checks if the response is a declarative sentence (not interrogative) in Arabic.
        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response is a declarative sentence, False otherwise.
        """
        if value is None or not isinstance(value, str):
            return False
        return not value.strip().endswith('؟')



class DataIdx718InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_718')

    def check_following(self, value):
        """Checks if the response is exactly two sentences long.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains exactly two sentences, False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentence_enders = '[.!?؟]+'
        sentences = [s.strip() for s in re.split(sentence_enders, value) if s.strip()]
        return len(sentences) == 2



class DataIdx719InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_719')

    def check_following(self, value):
        """Checks if the response contains the word 'مؤثر' at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains the word 'مؤثر', False otherwise.
        """
        required_word = 'مؤثر'
        return required_word in value



class DataIdx720InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_720')

    def check_following(self, value):
        """Checks if the response defines 'التنمية المستدامة' according to the constraints.

        Constraints:
        1. Must be a single paragraph.
        2. Must contain the word 'مستقبل' (mustaqbal) at least three times.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        is_single_paragraph = value.count('\n\n') == 0
        future_word_count = value.count('مستقبل')
        return is_single_paragraph and future_word_count >= 3



class DataIdx721InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_721')

    def check_following(self, value):
        """Checks if the response mentions the substring 'المهارات' at least 3 times.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        target_substring = 'المهارات'
        count = value.count(target_substring)
        return count >= 3



class DataIdx722InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_722')

    def check_following(self, value):
        """Checks if the response is a paragraph with at least 5 sentences,
           based on sentence-ending punctuation.
           This implementation manually splits the string based on '.', '?', '!'
           and counts the resulting non-empty segments after stripping whitespace.

        Args:
            value: A string representing the response (the student's paragraph).

        Returns:
            True if the response appears to have at least 5 sentences, False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        sentence_enders = '.?!'
        parts = []
        last_idx = 0
        for i in range(len(value)):
            if value[i] in sentence_enders:
                part = value[last_idx:i]
                parts.append(part)
                last_idx = i + 1
        if last_idx <= len(value):
            parts.append(value[last_idx:])
        sentence_count = 0
        for part in parts:
            if part.strip():
                sentence_count += 1
        return sentence_count >= 5



class DataIdx723InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_723')

    def check_following(self, value):
        """Checks if the response is a list of 7 single-word items starting with 'ت'."""
        if not isinstance(value, str):
            return False
        items = [item.strip() for item in value.strip().split('\n')]
        items = [item for item in items if item]
        if len(items) != 7:
            return False
        for item in items:
            if ' ' in item:
                return False
        if not items[0].startswith('ت'):
            return False
        return True



class DataIdx724InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_724')

    def check_following(self, value):
        """
        Checks if the string consists of only uppercase letters and other characters.
        According to Unicode standard casing, standard Arabic letters are neither
        uppercase nor lowercase. Therefore, a string containing any standard
        Arabic letter will fail the check for "uppercase letters only" if
        interpreted strictly using isupper().

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (contains no alphabetic
            characters that are not uppercase) or False otherwise.
        """
        if not isinstance(value, str):
            return False
        for char in value:
            if char.isalpha() and (not char.isupper()):
                return False
        return True



class DataIdx725InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_725')

    def check_following(self, value):
        """
        Checks if the response is a single line of Arabic text potentially representing a line of poetry.

        Constraints derived from the question "اكتب بيتاً شعرياً واحداً عن الأخلاق الحميدة":
        1. Must be a single line of poetry (بيتاً شعرياً واحداً).
           - Programmatic check: Verify it's a single line of text (no internal newlines).
           - Programmatic check: Verify a reasonable length for a line of poetry (heuristic).
           - (Difficulty: Cannot reliably check poetic meter/rhyme or if it's truly "poetry" without complex NLP).
        2. Must be about good morals (عن الأخلاق الحميدة).
           - (Difficulty: Cannot reliably check the theme programmatically without complex NLP or keyword lists, which are error-prone).
        3. Must be in Arabic.
           - Programmatic check: Verify the presence of Arabic characters.

        Given the limitations of automated checking for poetic form and theme,
        this checker focuses on the verifiable structural and linguistic aspects:
        being a single line of text within a plausible length range and containing Arabic.
        It does NOT guarantee the response is actual poetry or about morals.

        Args:
            value: A string representing the response.

        Returns:
            True if the response meets the verifiable constraints (single line, reasonable length, Arabic),
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if '\n' in cleaned_value:
            return False
        min_length = 10
        max_length = 200
        if not min_length <= len(cleaned_value) <= max_length:
            return False
        has_arabic = any(('\u0600' <= c <= 'ۿ' for c in cleaned_value))
        if not has_arabic:
            return False
        return True



class DataIdx726InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_726')

    def check_following(self, value):
        """Checks if the response is a single conditional sentence expressing a positive result.
        This check primarily verifies the presence of common Arabic conditional particles,
        as verifying "one sentence" and "positive result" reliably purely syntactically is challenging.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response contains at least one common Arabic conditional particle, False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        conditional_particles = ['إذا', 'لو', 'كلما', 'متى', 'إن', 'مهما', 'أينما', 'حيثما']
        for particle in conditional_particles:
            if particle in value:
                return True
        return False



class DataIdx727InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_727')

    def check_following(self, value):
        """Checks if the response follows the constraints for IDX 727.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        ta_count = value.count('ت')
        constraint_ta_count = ta_count >= 4
        sentence_endings_count = value.count('.') + value.count('؟') + value.count('!')
        constraint_sentence_count = sentence_endings_count < 5
        constraint_curly_braces = value.count('{') >= 2 and value.count('}') >= 2
        all_constraints_met = constraint_ta_count and constraint_sentence_count and constraint_curly_braces
        return all_constraints_met



class DataIdx728InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_728')

    def check_following(self, value):
        """
        Checks if the response contains the Arabic word 'بانتظام' and is in a single sentence.
        A single sentence is heuristically defined as containing at most one
        terminal punctuation mark (., ؟, !).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        keyword = 'بانتظام'
        contains_keyword = keyword in value
        value_stripped = value.strip()
        if not value_stripped:
            is_single_sentence = False
        else:
            terminal_punctuations = ['.', '؟', '!']
            punc_count = sum((value_stripped.count(p) for p in terminal_punctuations))
            is_single_sentence = punc_count <= 1
        return contains_keyword and is_single_sentence



class DataIdx729InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_729')

    def check_following(self, value):
        """
        Checks if the response is an Arabic paragraph describing spring,
        has at least 5 sentences (based on punctuation), uses Markdown
        syntax, and contains the words 'أزهار' and 'جميل'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        has_flowers = 'أزهار' in value
        has_beautiful = 'جميل' in value
        sentence_punctuation_count = value.count('.') + value.count('!') + value.count('?')
        has_min_sentences = sentence_punctuation_count >= 5
        uses_markdown_syntax = '**' in value or '*' in value or '_' in value
        is_following = has_flowers and has_beautiful and has_min_sentences and uses_markdown_syntax
        return is_following



class DataIdx730InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_730')

    def check_following(self, value):
        """Checks if the response is a sentence containing 'hola' exactly once and ending with a period."""
        if not isinstance(value, str):
            return False
        if value.count('hola') != 1:
            return False
        if not value.endswith('.'):
            return False
        return True



class DataIdx731InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_731')

    def check_following(self, value):
        """
        Checks if the response describes a natural scene without using past tense verbs.
        The check for past tense verbs is based on a limited blacklist of common forms.
        Note: This checker primarily focuses on the negative constraint (no past tense verbs)
        and does not verify the descriptive content (mountains, trees, river, accuracy, detail).

        Args:
            value: A string representing the response.

        Returns:
            True if the response appears to follow the instruction (specifically the lack of forbidden past tense words),
            False otherwise.
        """
        forbidden_past_tense_words = {'كان', 'كانت', 'كانوا', 'كنت', 'كنا', 'رأى', 'رأت', 'رأيت', 'رأينا', 'رأيتم', 'رأين', 'ظهر', 'ظهرت', 'ظهروا', 'بدأ', 'بدأت', 'بدأوا', 'امتد', 'امتدت', 'امتدوا', 'غطى', 'غطت', 'غطوا', 'عكس', 'عكست', 'عكسوا', 'خلق', 'بنى', 'بنت', 'جرى', 'جرت'}
        pattern = '\\b(' + '|'.join((re.escape(word) for word in forbidden_past_tense_words)) + ')\\b'
        if re.search(pattern, value):
            return False
        else:
            return True



class DataIdx732InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_732')

    def check_following(self, value):
        """Checks if the response is a numbered list containing items numbered 1 through 6.
        
        The response must contain at least six items presented as a numbered list,
        starting the numbering from 1 up to at least 6.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (is a numbered list 1-6), False otherwise.
        """
        if not isinstance(value, str):
            return False
        pattern = '^\\s*1[\\.\\)\\s].*?\\n.*?^\\s*2[\\.\\)\\s].*?\\n.*?^\\s*3[\\.\\)\\s].*?\\n.*?^\\s*4[\\.\\)\\s].*?\\n.*?^\\s*5[\\.\\)\\s].*?\\n.*?^\\s*6[\\.\\)\\s]'
        match = re.search(pattern, value, re.DOTALL | re.MULTILINE)
        return match is not None



class DataIdx733InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_733')

    def check_following(self, value):
        """Checks if the response is a short dialogue between two people about the importance of reading,
        includes at least one interrogative sentence, mentions 'أحمد' once and 'فاطمة' once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        ahmad_count = value.count('أحمد')
        if ahmad_count != 1:
            return False
        fatima_count = value.count('فاطمة')
        if fatima_count != 1:
            return False
        if '؟' not in value:
            return False
        return True



class DataIdx734InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_734')

    def check_following(self, value):
        """Checks if the response is a Facebook post announcing a party in Arabic.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (contains keywords related to party and announcement in Arabic), False otherwise.
        """
        if not isinstance(value, str):
            return False
        party_keywords = ['حفلة', 'حفل']
        announcement_keywords = ['إعلان', 'تعلن', 'ندعوكم', 'يسعدنا', 'دعوة']
        has_party_keyword = any((keyword in value for keyword in party_keywords))
        has_announcement_keyword = any((keyword in value for keyword in announcement_keywords))
        return has_party_keyword and has_announcement_keyword



class DataIdx736InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_736')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 736.
        Constraints:
        1. Answer must be a string.
        2. Answer must be enclosed in << >>.
        3. Content between << and >> must not be empty.
        4. Answer must not use the passive-like structure 'يتم إنتاج'.
           Note: This is a simplified check targeting a specific phrasing, not a full passive voice detection.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if not value.startswith('<<') or not value.endswith('>>'):
            return False
        content = value[2:-2]
        if not content or not content.strip():
            return False
        if 'يتم إنتاج' in content:
            return False
        return True



class DataIdx737InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_737')

    def check_following(self, value):
        """Checks if the response consists of exactly one word.
        Args:
            value: A string representing the response.

        Returns:
            True if the response is a single word, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.strip().split()
        return len(words) == 1



class DataIdx738InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_738')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 738.
        Instructions: Describe a traditional dish from your country.
        - The description must have a title in italics, formatted as *title*.
        - The description must be more than 80 words long.
        - The word 'لذيذ' (delicious) must be used at least twice.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        if not stripped_value.startswith('*'):
            return False
        second_star_index = stripped_value.find('*', 1)
        if second_star_index == -1 or second_star_index == 1:
            return False
        description = stripped_value[second_star_index + 1:]
        words = description.split()
        if len(words) <= 80:
            return False
        if description.count('لذيذ') < 2:
            return False
        return True



class DataIdx739InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_739')

    def check_following(self, value):
        """Checks if the response follows the instructions for question idx_739.
        Constraints:
        1. Must be a single verse of poetry about quadratic equations (hard to check programmatically).
        2. Must not contain the Arabic letter 'ر'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the constraints (specifically, the verifiable one), False otherwise.
        """
        forbidden_letter = 'ر'
        if forbidden_letter in value:
            return False
        return True



class DataIdx740InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_740')

    def check_following(self, value):
        """Checks if the response avoids using common past tense Arabic verbs.
        This is a basic check for a subset of common past tense forms.
        The check does not verify the 'literary style' or 'expressing feelings' constraints,
        as these are subjective and difficult to check programmatically without advanced NLP.

        Args:
            value: A string representing the response.

        Returns:
            False if common past tense verbs are detected, True otherwise.
        """
        forbidden_past_tense_forms = set(['كان', 'كانت', 'كانوا', 'كنت', 'كنتِ', 'كنتم', 'كنتن', 'كنا', 'كن', 'ليس', 'ليست', 'ليسوا', 'لست', 'لستِ', 'لستم', 'لستن', 'لسنا', 'صار', 'صارت', 'صاروا', 'صرت', 'صرتِ', 'صرتم', 'صرتن', 'صرنا', 'أصبح', 'أصبحت', 'أصبحوا', 'أصبحت', 'أصبحتِ', 'أصبحتم', 'أصبحن', 'أصبحنا', 'أضحى', 'أضحت', 'أضحوا', 'أضحيت', 'أضحيتِ', 'أضحيتما', 'أضحيتن', 'أضحين', 'أضحينا', 'ظل', 'ظلت', 'ظلوا', 'ظلت', 'ظلتِ', 'ظللتم', 'ظللتن', 'ظللنا', 'بات', 'باتت', 'باتوا', 'بت', 'بتِ', 'بتم', 'بتن', 'بتنا', 'أمسى', 'أمست', 'أمسوا', 'أمسيت', 'أمسيتِ', 'أمسيتما', 'أمسيتم', 'أمسيتن', 'أمسين', 'أمسينا', 'كتب', 'كتبت', 'كتبوا', 'كتبت', 'كتبتِ', 'كتبتم', 'كتبتن', 'كتبنا', 'ذهب', 'ذهبت', 'ذهبوا', 'ذهبت', 'ذهبتِ', 'ذهبتم', 'ذهبتن', 'ذهبنا', 'قرأ', 'قرأت', 'قرأوا', 'قرأت', 'قرأتِ', 'قرأتم', 'قرأتن', 'قرأنا', 'أكل', 'أكلت', 'أكلوا', 'أكلت', 'أكلتِ', 'أكلتم', 'أكلتن', 'أكلنا', 'شرب', 'شربت', 'شربوا', 'شربت', 'شربتِ', 'شربتم', 'شربتن', 'شربنا', 'قال', 'قالت', 'قالوا', 'قلت', 'قلتِ', 'قلتم', 'قلتن', 'قلنا', 'فعل', 'فعلت', 'فعلوا', 'فعلت', 'فعلتِ', 'فعلتم', 'فعلتن', 'فعلنا', 'جاء', 'جاءت', 'جاءوا', 'جئت', 'جئتِ', 'جئتم', 'جئتن', 'جئنا', 'رأى', 'رأت', 'رأوا', 'رأيت', 'رأيتِ', 'رأيتما', 'رأيتم', 'رأيتن', 'رأين', 'رأينا', 'مشى', 'مشت', 'مشوا', 'مشيت', 'مشيتِ', 'مشيتما', 'مشيتم', 'مشيتن', 'مشين', 'مشينا', 'بكى', 'بكت', 'بكوا', 'بكيت', 'بكيتِ', 'بكيتما', 'بكيتم', 'بكيتن', 'بكوا', 'بكينا', 'نام', 'نامت', 'ناموا', 'نمت', 'نمتِ', 'نمتم', 'نمتن', 'نمنا', 'قام', 'قامت', 'قاموا', 'قمت', 'قمتِ', 'قمتم', 'قمتن', 'قمنا', 'رسم', 'رسمت', 'رسموا', 'رسمت', 'رسمتِ', 'رسمتم', 'رسمتن', 'رسمنا', 'سمع', 'سمعت', 'سمعوا', 'سمعت', 'سمعتِ', 'سمعتم', 'سمعتن', 'سمعنا', 'نظر', 'نظرت', 'نظروا', 'نظرت', 'نظرتِ', 'نظرتم', 'نظرتن', 'نظرنا', 'وجد', 'وجدت', 'وجدوا', 'وجدت', 'وجدتِ', 'وجدتم', 'وجدت', 'وجدنا', 'أخذ', 'أخذت', 'أخذوا', 'أخذت', 'أخذتِ', 'أخذتم', 'أخذتن', 'أخذنا', 'بدأ', 'بدأت', 'بدأوا', 'بدأت', 'بدأتِ', 'بدأتم', 'بدأتن', 'بدأنا', 'أمر', 'أمرت', 'أمروا', 'أمرت', 'أمرتِ', 'أمرتم', 'أمرتن', 'أمرنا', 'رجع', 'رجعت', 'رجعوا', 'رجعت', 'رجعتِ', 'رجعتم', 'رجعتن', 'رجعنا', 'فتح', 'فتحت', 'فتحوا', 'فتحت', 'فتحتِ', 'فتحتم', 'فتحتن', 'فتحنا', 'غلق', 'غلقت', 'غلقوا', 'غلقت', 'غلقتِ', 'غلقتم', 'غلقتن', 'غلقنا'])
        punctuation_to_replace = '.,!?;:"\'(){}<>[]،؛؟'
        cleaned_value = value
        for p in punctuation_to_replace:
            cleaned_value = cleaned_value.replace(p, ' ')
        words = cleaned_value.split()
        for word in words:
            if word in forbidden_past_tense_forms:
                return False
        return True



class DataIdx741InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('741')

    def check_following(self, value):
        """Checks if the response follows structural constraints for question 741.
        It verifies if the response is a single sentence ending with terminal punctuation
        and if the first word is unlikely to be a definite article or common particle/preposition.
        Semantic constraints (imperative form, encouraging good deeds) cannot be verified
        with basic string checks.

        Args:
            value: A string representing the response.

        Returns:
            True if the response meets the feasible structural constraints, False otherwise.
        """
        if not value or not isinstance(value, str) or value.isspace():
            return False
        cleaned_value = value.strip()
        terminal_punctuations = ['.', '!', '؟']
        punctuation_count = 0
        for p in terminal_punctuations:
            punctuation_count += cleaned_value.count(p)
        if punctuation_count != 1:
            return False
        if not cleaned_value.endswith(tuple(terminal_punctuations)):
            return False
        last_punct_idx = -1
        for p in terminal_punctuations:
            if cleaned_value.endswith(p):
                last_punct_idx = cleaned_value.rfind(p)
                break
        sentence_body = cleaned_value[:last_punct_idx].rstrip()
        if not sentence_body or sentence_body.isspace():
            return False
        words = sentence_body.split(maxsplit=1)
        if not words:
            return False
        first_word = words[0]
        non_verb_starters = ['ال', 'و', 'ف', 'ب', 'ل', 'ك', 'يا', 'هل', 'إن', 'أن', 'قد', 'سوف', 'لم', 'لن', 'ما', 'لا', 'أ', 'ن', 'ي', 'ت']
        if first_word.startswith('ال'):
            return False
        if first_word in non_verb_starters:
            return False
        return True



class DataIdx742InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_742')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 742.
        Constraints:
        1. Title enclosed in << >> exists.
        2. Word count is >= 250.
        3. Starts with 'عزيزي أنا المستقبلي،'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        title_start = value.find('<<')
        title_end = value.find('>>')
        has_title_format = title_start != -1 and title_end != -1 and (title_start < title_end)
        words = value.split()
        word_count = len(words)
        is_long_enough = word_count >= 250
        starts_correctly = value.strip().startswith('عزيزي أنا المستقبلي،')
        return has_title_format and is_long_enough and starts_correctly



class DataIdx743InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_743')

    def check_following(self, value):
        """Checks if the response lists five points about Cairo attractions,
        each starting with the word 'زيارة'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        required_start = 'زيارة'
        expected_count = 5
        lines = [line.strip() for line in value.strip().splitlines() if line.strip()]
        if len(lines) != expected_count:
            return False
        for line in lines:
            if not line.startswith(required_start):
                return False
        return True



class DataIdx744InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_744')

    def check_following(self, value):
        """Checks if the response avoids the word 'إنترنت'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain the word 'إنترنت', False otherwise.
        """
        forbidden_word = 'إنترنت'
        if forbidden_word in value:
            return False
        return True



class DataIdx745InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_745')

    def check_following(self, value):
        """
        Checks if the response lists exactly three items in a bulleted list format.
        The content of the items (whether they are public transport types) is NOT checked,
        only the format and count.
        Args:
            value: A string representing the response.

        Returns:
            True if the response is a bulleted list with exactly 3 items, False otherwise.
        """
        lines = value.strip().split('\n')
        non_empty_lines = [line.strip() for line in lines if line.strip()]
        if len(non_empty_lines) != 3:
            return False
        bullet_chars = ['-', '*', '+']
        for line in non_empty_lines:
            is_bulleted = False
            for bullet in bullet_chars:
                if line.startswith(bullet):
                    if len(line) > len(bullet):
                        is_bulleted = True
                        break
            if not is_bulleted:
                return False
        return True



class DataIdx746InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_746')

    def check_following(self, value):
        """Checks if the response is a JSON object where the single key is
        'هل اللغة العربية لغة سامية؟' and the value is a boolean.
        Assumes 'value' is the parsed JSON object (Python dict).

        Args:
            value: A Python object representing the parsed JSON response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, dict):
            return False
        if len(value) != 1:
            return False
        expected_key = 'هل اللغة العربية لغة سامية؟'
        actual_key = list(value.keys())[0]
        if actual_key != expected_key:
            return False
        actual_value = value[expected_key]
        if not isinstance(actual_value, bool):
            return False
        return True



class DataIdx747InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_747')

    def check_following(self, value):
        """Checks if the response lists exactly eight points in bullet points.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        bullet_count = 0
        valid_bullet_chars = {'-', '*', '+'}
        for line in lines:
            stripped_line = line.lstrip()
            if not stripped_line:
                continue
            if stripped_line[0] in valid_bullet_chars:
                if stripped_line[1:].lstrip():
                    bullet_count += 1
        return bullet_count == 8



class DataIdx748InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_748')

    def check_following(self, value):
        """Checks if the response follows the instruction, specifically if it avoids the word 'ماء'.

        Args:
            value: A string representing the response (the tea recipe).

        Returns:
            True if the response does not contain the word 'ماء', False otherwise.
        """
        forbidden_word = 'ماء'
        return forbidden_word not in value



class DataIdx749InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_749')

    def check_following(self, value):
        """Checks if the response defines 'الكتاب' in one sentence without exclamation marks.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if '!' in value:
            return False
        value = value.strip()
        if not value:
            return False
        terminator_count = 0
        temp_value = value
        ellipsis_count = temp_value.count('...')
        terminator_count += ellipsis_count
        if ellipsis_count > 0:
            temp_value = temp_value.replace('...', '')
        terminator_count += temp_value.count('.')
        terminator_count += temp_value.count('؟')
        if terminator_count != 1:
            return False
        return True



class DataIdx750InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_750')

    def check_following(self, value):
        """
        Checks if the response is a list of exactly 4 steps, where each step starts with the word "أولاً".
        It also implicitly checks for distinct items which are likely presented as a list.
        """
        if not isinstance(value, str):
            return False
        lines = [line.strip() for line in value.strip().splitlines() if line.strip()]
        list_items = [line for line in lines if line.startswith('أولاً')]
        if len(list_items) != 4:
            return False
        for item in list_items:
            if not item.startswith('أولاً'):
                return False
        return True



class DataIdx751InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_751')

    def check_following(self, value):
        """Checks if the response is a single sentence about cats, including the word "مواء".

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        has_meow = 'مواء' in value
        sentence_enders = ['.', '!', '?']
        punc_count = sum((value.count(end) for end in sentence_enders))
        return has_meow and punc_count <= 1



class DataIdx752InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_752')

    def check_following(self, value):
        """Checks if the response avoids the word 'لغة' and contains at least four sentences.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if 'لغة' in value:
            return False
        sentences = [s.strip() for s in re.split('[.!?؟]', value)]
        sentences = [s for s in sentences if s]
        if len(sentences) < 4:
            return False
        return True



class DataIdx753InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_753')

    def check_following(self, value):
        """Checks if the response contains at least three dates.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains at least three recognized date formats, False otherwise.
        """
        date_pattern = '\\b(?:\\d{4}|\\d{1,2}[/\\.]\\d{1,2}[/\\.]\\d{2,4}|\\d{1,2}\\s+(?:يناير|فبراير|مارس|أبريل|مايو|يونيو|يوليو|أغسطس|سبتمبر|أكتوبر|نوفمبر|ديسمبر|محرم|صفر|ربيع الأول|ربيع الثاني|جمادى الأولى|جمادى الثانية|رجب|شعبان|رمضان|شوال|ذو القعدة|ذو الحجة|January|February|March|April|May|June|July|August|September|October|November|December)\\s+\\d{4}|(?:يناير|فبراير|مارس|أبريل|مايو|يونيو|يوليو|أغسطس|سبتمبر|أكتوبر|نوفمبر|ديسمبر|محرم|صفر|ربيع الأول|ربيع الثاني|جمادى الأولى|جمادى الثانية|رجب|شعبان|رمضان|شوال|ذو القعدة|ذو الحجة|January|February|March|April|May|June|July|August|September|October|November|December)\\s+\\d{1,2},\\s+\\d{4})\\b'
        dates_list = re.findall(date_pattern, value)
        return len(dates_list) >= 3



class DataIdx754InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_754')

    def check_following(self, value):
        """Checks if the response uses the word 'ماء' at least 10 times.

        Args:
            value: A string representing the response.

        Returns:
            True if the word 'ماء' appears 10 or more times, False otherwise.
        """
        word_to_count = 'ماء'
        count = value.count(word_to_count)
        return count >= 10



class DataIdx755InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_755')

    def check_following(self, value):
        """Checks if the response (a poem) avoids using the Arabic letter 'راء'.

        Args:
            value: A string representing the response (the poem).

        Returns:
            True if the response does not contain the letter 'ر', False otherwise.
        """
        forbidden_char = 'ر'
        if forbidden_char in value:
            return False
        return True



class DataIdx756InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_756')

    def check_following(self, value):
        """Checks if the response is a single sentence about nature, not politics, based on keywords from the instruction.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        sentence_enders = ['.', '!', '?']
        ender_count = sum((cleaned_value.count(end) for end in sentence_enders))
        if ender_count != 1:
            return False
        last_char_is_ender = False
        for end in sentence_enders:
            if cleaned_value.endswith(end):
                last_char_is_ender = True
                break
        if not last_char_is_ender:
            return False
        political_keywords = ['سياسة', 'السياسة']
        for keyword in political_keywords:
            if keyword in cleaned_value:
                return False
        nature_keywords = ['طبيعة', 'الطبيعة']
        has_nature_keyword = any((keyword in cleaned_value for keyword in nature_keywords))
        if not has_nature_keyword:
            return False
        return True



class DataIdx757InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_757')

    def check_following(self, value):
        """Checks if the response is a single word.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is a single word, False otherwise.
        """
        words = value.strip().split()
        return len(words) == 1



class DataIdx758InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_758')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 758.

        Instructions:
        1. Write a traditional food recipe from your country.
        2. The recipe should be around 180 words.
        3. Use numbers written out (one, two, three...) instead of digits (1, 2, 3...).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        min_word_count = 160
        max_word_count = 200
        word_count_ok = min_word_count <= word_count <= max_word_count
        arabic_digits = '٠١٢٣٤٥٦٧٨٩'
        western_digits = '0123456789'
        all_digits = arabic_digits + western_digits
        contains_digits = any((char in all_digits for char in value))
        return word_count_ok and (not contains_digits)



class DataIdx759InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_759')

    def check_following(self, value):
        """Checks if the response is a summary of a historical book, less than 70 words,
        mentioning 'author' and 'book'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        contains_author = 'المؤلف' in value
        contains_book = 'الكتاب' in value
        words = value.split()
        word_count = len(words)
        is_less_than_70_words = word_count < 70
        return contains_author and contains_book and is_less_than_70_words



class DataIdx760InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_760')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        has_two_lines = value.count('\n') == 1
        punctuation_chars = string.punctuation
        has_punctuation = any((char in punctuation_chars for char in value))
        does_not_have_punctuation = not has_punctuation
        return has_two_lines and does_not_have_punctuation



class DataIdx761InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_761')

    def check_following(self, value):
        """Checks if the response is an Arabic question that ends with a question mark
        and includes the word 'مستقبل'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        cleaned_value = value.strip()
        if not cleaned_value.endswith('?'):
            return False
        if 'مستقبل' not in cleaned_value:
            return False
        return True



class DataIdx762InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_762')

    def check_following(self, value):
        """Checks if the response is a dialogue with at least 7 lines and includes the word 'السعر'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        dialogue_lines = [line for line in lines if line.strip()]
        line_count = len(dialogue_lines)
        if line_count < 7:
            return False
        if 'السعر' not in value:
            return False
        return True



class DataIdx763InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_763')

    def check_following(self, value):
        """Checks if the response avoids using the word 'جداً' or its common synonyms.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (avoids forbidden words), False otherwise.
        """
        forbidden_words = ['جداً', 'كثيراً', 'للغاية', 'بشدة']
        for word in forbidden_words:
            if word in value:
                return False
        return True



class DataIdx764InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_764')

    def check_following(self, value):
        """Checks if the response is a CSV string with headers 'Name,Age,City' and at least three data rows."""
        if not isinstance(value, str):
            return False
        lines = value.strip().splitlines()
        if len(lines) < 4:
            return False
        expected_header = 'Name,Age,City'
        actual_header = lines[0].strip()
        if actual_header != expected_header:
            return False
        min_data_rows_required = 3
        actual_valid_data_rows_found = 0
        for i in range(1, len(lines)):
            stripped_row = lines[i].strip()
            if not stripped_row:
                continue
            columns = stripped_row.split(',')
            if len(columns) != 3:
                return False
            actual_valid_data_rows_found += 1
        if actual_valid_data_rows_found < min_data_rows_required:
            return False
        return True



class DataIdx765InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_765')

    def check_following(self, value):
        """
        Checks if the response follows the instructions for question IDX 765.
        Constraints:
        1. Word count between 80 and 100 words.
        2. Contains the word 'خوارزمية' at least twice.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = re.split('\\s+', value.strip())
        punctuation_chars = '.,!?;:()\\[\\]{}<>"\'«»٪؟،؛'
        punctuation_only_pattern = re.compile(f'^[{re.escape(punctuation_chars)}]+$')
        words = [word for word in words if word and (not punctuation_only_pattern.match(word))]
        word_count = len(words)
        if not 80 <= word_count <= 100:
            return False
        khawarizmiya_count = len(re.findall('\\bخوارزمية\\b', value))
        if khawarizmiya_count < 2:
            return False
        return True



class DataIdx766InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_766')

    def check_following(self, value):
        """Checks if the response describes three benefits in three lines,
        each starting with what is interpreted as an imperative verb.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        lines = [line.strip() for line in lines if line.strip()]
        if len(lines) != 3:
            return False
        for line in lines:
            trimmed_line = line.strip()
            if not trimmed_line:
                return False
            first_char = trimmed_line[0]
            if not '\u0600' <= first_char <= 'ۿ':
                return False
        return True



class DataIdx767InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_767')

    def check_following(self, value):
        """Checks if the response has more than 60 words and uses the word 'تنمية' at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        word_count = len(words)
        word_count_met = word_count > 60
        required_word = 'تنمية'
        required_word_used = required_word in value
        return word_count_met and required_word_used



class DataIdx768InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_768')

    def check_following(self, value):
        """Check if the response is a single sentence in Arabic expressing good wishes for an exam.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """

        def is_single_sentence(text):
            text = text.strip()
            if not text:
                return False
            sentence_enders = re.compile('[.!?]')
            matches = list(sentence_enders.finditer(text))
            if len(matches) > 1:
                return False
            if len(matches) == 1:
                last_match = matches[0]
                if last_match.end() != len(text):
                    if not text[last_match.end():].strip() == '':
                        return False
                return True
            return True

        def contains_arabic_and_minimal_latin(text, max_latin=2):
            text = text.strip()
            if not text:
                return False
            arabic_pattern = re.compile('[\\u0600-\\u06FF]')
            latin_pattern = re.compile('[a-zA-Z]')
            if not arabic_pattern.search(text):
                return False
            latin_count = len(latin_pattern.findall(text))
            return latin_count <= max_latin
        is_single = is_single_sentence(value)
        is_arabic = contains_arabic_and_minimal_latin(value)
        return is_single and is_arabic



class DataIdx769InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('769')

    def check_following(self, value):
        """Checks if the response contains the word 'الكتاب' at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        return 'الكتاب' in value



class DataIdx770InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_770')

    def check_following(self, value):
        """Checks if the response contains exactly three Arabic questions,
        none of which start with 'لماذا', and contains only the questions
        (by checking if it ends with '؟' and has exactly 3 question parts)."""
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value.endswith('؟'):
            return False
        parts = cleaned_value.split('؟')
        if len(parts) != 4:
            return False
        question_texts = [part.strip() for part in parts[:3]]
        if any((not text for text in question_texts)):
            return False
        for q_text in question_texts:
            words = q_text.split()
            if not words:
                return False
            first_word = words[0]
            if first_word == 'لماذا':
                return False
        return True



class DataIdx771InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_771')

    def check_following(self, value):
        """Checks if the response describes a city in less than 40 words,
        using at least two adjectives (checked via a weak heuristic).
        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.strip().split()
        word_count = len(words)
        if word_count >= 40:
            return False
        cleaned_words = []
        punctuation = '.,;!؟'
        common_prefixes = {'ال', 'و', 'ف'}
        common_short_words_to_exclude = {'و', 'ف', 'في', 'من', 'على', 'إلى', 'ب', 'ل', 'ك', 'ان', 'أن'}
        for word in words:
            processed_word = word.strip(punctuation)
            if not processed_word:
                continue
            for prefix in common_prefixes:
                if processed_word.startswith(prefix) and len(processed_word) > len(prefix):
                    processed_word = processed_word[len(prefix):]
                    break
            if processed_word not in common_short_words_to_exclude and len(processed_word) > 1:
                cleaned_words.append(processed_word)
        distinct_significant_words = set(cleaned_words)
        has_at_least_two_adjectives_heuristic = len(distinct_significant_words) >= 2
        return has_at_least_two_adjectives_heuristic



class DataIdx772InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_772')

    def check_following(self, value):
        """Checks if the response is the complete proverb 'في الاتحاد قوةٌ' with the correct diacritics.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is exactly 'في الاتحاد قوةٌ', False otherwise.
        """
        expected_answer = 'في الاتحاد قوةٌ'
        return value == expected_answer



class DataIdx773InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_773')

    def check_following(self, value):
        """Checks if the response contains the word 'مساءً' exactly once.

        Args:
            value: A string representing the response (email body).

        Returns:
            True if the string contains 'مساءً' exactly once, False otherwise.
        """
        count_masa = value.count('مساءً')
        return count_masa == 1



class DataIdx774InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_774')

    def check_following(self, value):
        """Checks if the response is a single sentence and does not exceed 15 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        trimmed_value = value.strip()
        if not trimmed_value:
            return False
        words = trimmed_value.split()
        word_count = len(words)
        if word_count > 15:
            return False
        first_term_idx = -1
        terminal_punctuations = ['.', '!', '?']
        for i, char in enumerate(trimmed_value):
            if char in terminal_punctuations:
                first_term_idx = i
                break
        if first_term_idx != -1:
            after_punctuation = trimmed_value[first_term_idx + 1:].strip()
            if after_punctuation:
                return False
        return True



class DataIdx775InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_775')

    def check_following(self, value):
        """Checks if the response starts with 'هل' and ends with exactly one '؟'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        starts_with_hel = stripped_value.startswith('هل')
        arabic_qm = '؟'
        ends_with_arabic_qm = stripped_value.endswith(arabic_qm)
        arabic_qm_count = stripped_value.count(arabic_qm)
        ends_with_exactly_one_arabic_qm = ends_with_arabic_qm and arabic_qm_count == 1
        return starts_with_hel and ends_with_exactly_one_arabic_qm



class DataIdx776InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_776')

    def check_following(self, value):
        """Checks if the response is the correct passive form of 'يقرأ الطالب الكتاب'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is the correct passive sentence, False otherwise.
        """
        expected_full_diacritics = 'يُقرأُ الكتابُ'
        expected_common = 'يُقرأ الكتاب'
        cleaned_value = value.strip()
        return cleaned_value == expected_full_diacritics or cleaned_value == expected_common



class DataIdx777InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_777')

    def check_following(self, value):
        """Checks if the response contains the word 'تراث' and is a single sentence."""
        if not value or not value.strip():
            return False
        contains_turath = 'تراث' in value
        sentence_terminators = ['.', '؟', '!']
        terminator_count = sum((value.count(term) for term in sentence_terminators))
        is_single_sentence = terminator_count <= 1
        return contains_turath and is_single_sentence



class DataIdx778InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_778')

    def check_following(self, value):
        """Checks if the response is a question starting with 'كيف', asking about learning a new skill quickly, clear and direct.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value.endswith('?'):
            return False
        cleaned_value_no_qm = cleaned_value[:-1].strip()
        if not cleaned_value_no_qm.startswith('كيف'):
            return False
        required_keywords = ['تعلم', 'مهارة', 'بسرعة']
        for keyword in required_keywords:
            if keyword not in cleaned_value_no_qm:
                return False
        return True



class DataIdx779InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_779')

    def check_following(self, value):
        """Checks if the response is a brief description of a fictional character,
        has at most three sentences, and uses the words "غامض" and "ذكي".

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        uses_غامض = 'غامض' in value
        uses_ذكي = 'ذكي' in value
        sentences = re.split('[.!?؟]+', value)
        non_empty_sentences = [s.strip() for s in sentences if s.strip()]
        sentence_count = len(non_empty_sentences)
        has_at_most_three_sentences = sentence_count <= 3
        return uses_غامض and uses_ذكي and has_at_most_three_sentences



class DataIdx780InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_780')

    def check_following(self, value):
        """Checks if the response contains at least one word in square brackets."""
        pattern = '\\[.+?\\]'
        return re.search(pattern, value) is not None



class DataIdx781InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_781')

    def check_following(self, value):
        """
        Checks if the response meets the constraints for question 781:
        1. The essay is at least 250 words long.
        2. The word 'الخيال' (imagination) is used at least 3 times.

        Args:
            value: A string representing the response text in Arabic.

        Returns:
            True if the response follows all instructions, False otherwise.
        """
        if not isinstance(value, str):
            return False
        arabic_word_pattern = re.compile('[\\u0600-\\u06FF]+')
        words = arabic_word_pattern.findall(value)
        word_count = len(words)
        min_words = 250
        word_count_ok = word_count >= min_words
        keyword = 'الخيال'
        min_keyword_count = 3
        keyword_count = words.count(keyword)
        keyword_count_ok = keyword_count >= min_keyword_count
        return word_count_ok and keyword_count_ok



class DataIdx782InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_782')

    def check_following(self, value):
        """Checks if the Arabic text follows the constraints for question 782.
        Constraints: One paragraph, exactly two sentences, explains difference between past/present verbs,
                     contains 'الزمن' and 'الحدث'.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the structural and keyword constraints, False otherwise.
        """
        sentence_enders = ['.', '!', '؟']
        sentences = re.split('([.!?؟])', value)
        sentence_parts = [part.strip() for part in sentences if part.strip() and part.strip() not in sentence_enders]
        sentence_count = len(sentence_parts)
        contains_zaman = 'الزمن' in value
        contains_hadath = 'الحدث' in value
        is_correct = sentence_count == 2 and contains_zaman and contains_hadath
        return is_correct



class DataIdx783InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_783')

    def check_following(self, value):
        """Checks if the response contains two columns 'إيجابيات' and 'سلبيات'
           with exactly two points in each. Points are counted as non-empty lines
           following the column title within their respective sections."""
        pros_title = 'إيجابيات'
        cons_title = 'سلبيات'
        idx_pros = value.find(pros_title)
        idx_cons = value.find(cons_title)
        if idx_pros == -1 or idx_cons == -1:
            return False
        if idx_pros < idx_cons:
            pros_section = value[idx_pros + len(pros_title):idx_cons]
            cons_section = value[idx_cons + len(cons_title):]
        else:
            cons_section = value[idx_cons + len(cons_title):idx_pros]
            pros_section = value[idx_pros + len(pros_title):]

        def count_points(section_text):
            if not section_text:
                return 0
            lines = section_text.splitlines()
            points = [line.strip() for line in lines if line.strip()]
            return len(points)
        num_pros_points = count_points(pros_section)
        num_cons_points = count_points(cons_section)
        return num_pros_points == 2 and num_cons_points == 2



class DataIdx784InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_784')

    def check_following(self, value):
        """Checks if the response does not contain the word 'زحام'.

        Args:
            value: A string representing the response (description of a city).

        Returns:
            True if the response does not contain 'زحام', False otherwise.
        """
        forbidden_word = 'زحام'
        return forbidden_word not in value



class DataIdx785InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_785')

    def check_following(self, value):
        """Checks if the response is a paragraph between 130 and 150 words long and contains 'العنوان' at least 4 times."""
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        word_count_ok = 130 <= word_count <= 150
        keyword = 'العنوان'
        keyword_matches = re.findall('\\b' + re.escape(keyword) + '\\b', value)
        keyword_count = len(keyword_matches)
        keyword_count_ok = keyword_count >= 4
        return word_count_ok and keyword_count_ok



class DataIdx786InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_786')

    def check_following(self, value):
        """Checks if the response follows the instructions.
        The instruction asks to write a thank you note to a friend.
        There are no specific formatting or content constraints mentioned in the question itself.
        The most basic constraint is that the response should not be empty, as an empty string
        cannot be a thank you note.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is not empty, False otherwise.
        """
        return len(value) > 0



class DataIdx787InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_787')

    def check_following(self, value):
        """Checks if the response is a recipe title in Arabic with at least three punctuation marks.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        has_arabic = any(('\u0600' <= char <= 'ۿ' for char in value))
        if not has_arabic:
            return False
        punctuation_marks = set('.,!?:;-"\'()[]{}')
        punctuation_count = sum((1 for char in value if char in punctuation_marks))
        return punctuation_count >= 3



class DataIdx788InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_788')

    def check_following(self, value):
        """Checks if the response is a non-empty string, is in Arabic, and has a minimum length,
        suggesting it's an attempt at a news report about a scientific discovery.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the basic constraints (string, not empty,
            contains Arabic characters, minimum length), False otherwise.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        if not stripped_value:
            return False
        has_arabic_char = any(('\u0600' <= c <= 'ۿ' for c in stripped_value))
        if not has_arabic_char:
            return False
        minimum_length = 100
        if len(stripped_value) < minimum_length:
            return False
        return True



class DataIdx789InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_789')

    def check_following(self, value):
        """Checks if the response is a sentence using 'هذا' and including 'كتاب'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (contains 'هذا' and 'كتاب'),
            False otherwise.
        """
        contains_hatha = 'هذا' in value
        contains_kitab = 'كتاب' in value
        return contains_hatha and contains_kitab



class DataIdx790InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_790')

    def check_following(self, value):
        """Checks if the response follows the constraints:
        - Less than 25 words.
        - Does not contain the word 'تكنولوجيا'.
        
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        word_count = len(words)
        word_count_ok = word_count < 25
        forbidden_word = 'تكنولوجيا'
        forbidden_word_absent = forbidden_word not in value
        return word_count_ok and forbidden_word_absent



class DataIdx791InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_791')

    def check_following(self, value):
        """Checks if the response explains the importance of exercise in one sentence without commas.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if ',' in value:
            return False
        sentence_terminators = ['.', '!', '?']
        for i in range(len(value)):
            if value[i] in sentence_terminators:
                if i != len(value) - 1:
                    return False
        return True



class DataIdx792InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_792')

    def check_following(self, value):
        """Checks if the response is a single sentence expressing gratitude containing 'شكراً' at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if 'شكراً' not in value:
            return False
        sentence_enders = ['.', '!', '?']
        punctuation_count = sum((value.count(p) for p in sentence_enders))
        if punctuation_count > 1:
            return False
        return True



class DataIdx793InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_793')

    def check_following(self, value):
        """Checks if the response contains the specific word 'صفقت'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is exactly the word 'صفقت', False otherwise.
        """
        required_word = 'صفقت'
        return value.strip() == required_word



class DataIdx794InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_794')

    def check_following(self, value):
        """Checks if the response is an unordered list of five distinct items,
        written entirely in lowercase.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if value != value.lower():
            return False
        lines = [line for line in value.strip().split('\n') if line.strip()]
        if len(lines) != 5:
            return False
        list_items = []
        for line in lines:
            line_stripped = line.strip()
            if line_stripped.startswith('- ') or line_stripped.startswith('* ') or line_stripped.startswith('+ '):
                item = line_stripped[2:].strip()
                if item:
                    list_items.append(item)
                else:
                    return False
            else:
                return False
        if len(list_items) != 5:
            return False
        if len(set(list_items)) != 5:
            return False
        return True




class DataIdx795InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_795')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 795.
        Instructions:
        1. List five tips for students to improve their Arabic writing skills.
        2. Each tip must be in a single sentence only.
        3. Do not use passive verbs in the tips.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        tips = [line.strip() for line in lines if line.strip()]
        if len(tips) != 5:
            return False
        sentence_enders = ['.', '؟', '!']
        for tip in tips:
            if not tip:
                return False
            if not tip.endswith(tuple(sentence_enders)):
                return False
            if any((char in sentence_enders for char in tip[:-1])):
                return False
        passive_indicators = ['يقال', 'قيل', 'يعتقد', 'اعتقد', 'يفترض', 'افترض', 'يعرف', 'عرف', 'يكتب', 'كتب', 'يقرا', 'قرئ', 'يستخدم', 'استخدم', 'يفهم', 'فهم', 'يصحح', 'صحح', 'يطلب', 'طلب', 'يمنح', 'منح', 'يؤخذ', 'اخذ']
        for tip in tips:
            for indicator in passive_indicators:
                if re.search('\\b' + re.escape(indicator) + '\\b', tip):
                    return False
        return True



class DataIdx796InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_796')

    def check_following(self, value):
        """Checks if the response is a paragraph of at least 80 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (at least 80 words),
            False otherwise.
        """
        words = value.split()
        word_count = len(words)
        return word_count >= 80



class DataIdx797InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_797')

    def check_following(self, value):
        """
        Checks if the response is a list of exactly eleven items in reverse alphabetical order.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        items = []
        try:
            parsed_list = ast.literal_eval(value)
            if isinstance(parsed_list, list):
                if all((isinstance(item, str) for item in parsed_list)):
                    items = parsed_list
                else:
                    return False
            else:
                items = [item.strip() for item in value.split(',')]
                if len(items) == 1 and (not value.strip().startswith('[')):
                    return False
        except (ValueError, SyntaxError):
            items = [item.strip() for item in value.split(',')]
            if len(items) == 1 and (not value.strip().startswith('[')) and (',' not in value):
                return False
        if len(items) != 11:
            return False
        for i in range(len(items) - 1):
            if items[i] < items[i + 1]:
                return False
        return True



class DataIdx798InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_798')

    def check_following(self, value):
        """Checks if the response is a single paragraph and contains at least 50 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        normalized_value = value.replace('\r\n', '\n').replace('\r', '\n')
        if '\n\n' in normalized_value.strip():
            return False
        if '\n\n' in normalized_value:
            return False
        words = value.split()
        word_count = len(words)
        min_words = 50
        return word_count >= min_words



class DataIdx799InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_799')

    def check_following(self, value):
        """Checks if the response uses only commas and periods for punctuation.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        forbidden_chars_string = '!"#$%&\'()*+-/:;<=>?@[\\]^_`{|}~'
        forbidden_punctuation = set(forbidden_chars_string)
        for char in value:
            if char in forbidden_punctuation:
                return False
        return True



class DataIdx800InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_800')

    def check_following(self, value):
        """Checks if the response mentions 'فواكه', 'خضروات', and 'بروتين' at least once.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        has_fruits = 'فواكه' in value
        has_vegetables = 'خضروات' in value
        has_protein = 'بروتين' in value
        return has_fruits and has_vegetables and has_protein



class DataIdx801InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_801')

    def check_following(self, value):
        """
        Checks if the response is a single interrogative sentence asking about
        Arabic writing skill development and contains the word 'اقتراح'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        contains_efterah = 'اقتراح' in cleaned_value
        ends_with_question_mark = cleaned_value.endswith('?')
        single_question_mark = cleaned_value.count('?') == 1
        is_valid = contains_efterah and ends_with_question_mark and single_question_mark
        return is_valid



class DataIdx802InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_802')

    def check_following(self, value):
        """
        Checks if the response is a single sentence starting with 'عليك'
        and ending with a single sentence-ending punctuation mark.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        trimmed_value = value.strip()
        if not trimmed_value.startswith('عليك'):
            return False
        terminators = ['.', '!', '?']
        terminator_indices = [i for i, char in enumerate(trimmed_value) if char in terminators]
        if len(terminator_indices) != 1:
            return False
        if terminator_indices[0] != len(trimmed_value) - 1:
            return False
        return True



class DataIdx803InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_803')

    def check_following(self, value):
        """Checks if the response contains exactly one line and the word 'نور'.

        Args:
            value: A string representing the response (expected to be a single poetic verse).

        Returns:
            True if the response contains 'نور' and has no newline characters, False otherwise.
        """
        contains_noor = 'نور' in value
        is_single_line = '\n' not in value.strip()
        return contains_noor and is_single_line



class DataIdx804InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_804')

    def check_following(self, value):
        """Checks if the response lists at least four items in an unnumbered list format.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = [line.strip() for line in value.strip().split('\n') if line.strip()]
        numbered_pattern = re.compile('^\\s*(\\d+\\.|\\d+\\)|[a-zA-Z]+\\.|[a-zA-Z]+\\))\\s*')
        for line in lines:
            if numbered_pattern.match(line):
                return False
        if len(lines) < 4:
            return False
        return True



class DataIdx805InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('805')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 805.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentences = re.split('[.!?](?:\\s|$)', value.strip())
        sentences = [s for s in sentences if s.strip()]
        sentence_count = len(sentences)
        if sentence_count <= 5:
            return False
        market_word_count = value.count('السوق')
        if market_word_count < 2:
            return False
        placeholders = re.findall('\\[.*?\\]', value)
        placeholder_count = len(placeholders)
        if placeholder_count != 1:
            return False
        return True



class DataIdx806InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_806')

    def check_following(self, value):
        """
        Checks if the response mentions at least two dishes tried or ordered,
        by looking for common listing structures after verbs indicating trying/ordering.

        Args:
            value: A string representing the response.

        Returns:
            True if a structure listing >= 2 items connected by 'و' or '،'
            is found after a target verb, False otherwise.
        """
        if not isinstance(value, str):
            return False
        pattern = re.compile("\\b(جربت|طلبت|أكلت|تذوقت)\\b\\s+.*?(?:[\\u0621-\\u064A\\s\\w'-]+\\s*(?:و|،)\\s*[\\u0621-\\u064A\\s\\w'-]+)", re.IGNORECASE | re.DOTALL)
        match = pattern.search(value)
        return match is not None



class DataIdx807InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_807')

    def check_following(self, value):
        """Checks if the response follows the instruction to use only capital letters at the beginning of each word.
        Since Arabic script does not have capital letters, this instruction cannot be fulfilled.

        Args:
            value: A string representing the response.

        Returns:
            Always False, as the instruction is impossible to follow in Arabic.
        """
        return False



class DataIdx808InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_808')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        try:
            data = json.loads(value)
        except Exception:
            return False
        if not isinstance(data, dict):
            return False
        if 'question' not in data or not isinstance(data.get('question'), str):
            return False
        question_text = data['question'].strip()
        if not question_text.startswith('أين تقع'):
            return False
        if not question_text.endswith('؟'):
            return False
        if question_text.count('؟') != 1:
            return False
        has_arabic_chars = False
        for char in question_text:
            if '\u0600' <= char <= 'ۿ':
                has_arabic_chars = True
                break
        if not has_arabic_chars:
            return False
        return True



class DataIdx809InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_809')

    def check_following(self, value):
        """Checks if the response follows the constraints for IDX 809.
           Constraints:
           1. Is a riddle (implied).
           2. About a book (cannot reliably verify the topic content).
           3. Answer (الكتاب) is mentioned indirectly (cannot reliably verify the indirection, but can check for absence of the direct word "الكتاب").
           4. Uses exactly one question mark '?'.
           5. Is easy (cannot reliably verify difficulty).

           This checker focuses on the programmatically verifiable constraints:
           - Absence of the direct answer word "الكتاب".
           - Exactly one question mark.
        Args:
            value: A string representing the response (the riddle).

        Returns:
            True if the response follows the verifiable constraints, False otherwise.
        """
        if not isinstance(value, str):
            return False
        question_mark_count = value.count('?')
        if question_mark_count != 1:
            return False
        forbidden_word = 'الكتاب'
        if forbidden_word in value:
            return False
        return True



class DataIdx810InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_810')

    def check_following(self, value):
        """Checks if the response provides seven tips separated by '###', 
        contains the word 'مراجعة' at least twice, and ends with 'بالتوفيق في امتحانكم!'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows all instructions, False otherwise.
        """
        tips = value.split('###')
        if len(tips) != 7:
            return False
        if value.count('مراجعة') < 2:
            return False
        if not value.endswith('بالتوفيق في امتحانكم!'):
            return False
        return True



class DataIdx811InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_811')

    def check_following(self, value):
        """Checks if the response is a string and includes the word 'أمل'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response is a string and includes 'أمل', False otherwise.
        """
        if not isinstance(value, str):
            return False
        return 'أمل' in value



class DataIdx812InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_812')

    def check_following(self, value):
        """Checks if the response consists of exactly two paragraphs.

        Args:
            value: A string representing the response.

        Returns:
            True if the response has exactly two paragraphs, False otherwise.
        """
        if not isinstance(value, str):
            return False
        paragraphs = value.split('\n\n')
        valid_paragraphs = [p.strip() for p in paragraphs if p.strip()]
        return len(valid_paragraphs) == 2



class DataIdx813InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_813')

    def check_following(self, value):
        """Checks if the response is approximately four sentences long by splitting on terminators.
        Args:
            value: A string representing the response.

        Returns:
            True if the response results in exactly four non-empty parts when split by sentence terminators, False otherwise.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        if not stripped_value:
            return False
        sentence_terminators = ['.', '!', '?']
        parts = []
        current_part_start = 0
        for i in range(len(stripped_value)):
            if stripped_value[i] in sentence_terminators:
                part = stripped_value[current_part_start:i + 1].strip()
                if part:
                    parts.append(part)
                current_part_start = i + 1
        remaining = stripped_value[current_part_start:].strip()
        if remaining:
            parts.append(remaining)
        sentence_count = len(parts)
        return sentence_count == 4



class DataIdx814InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_814')

    def check_following(self, value):
        """Checks if the response explains the importance of water for human life,
           mentions at least 3 reasons, and does not use the word 'مهم'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if 'مهم' in value:
            return False
        reasons_keywords = [['ترطيب', 'جفاف', 'حيوية', 'بقاء'], ['وظائف الجسم', 'عمليات حيوية', 'وظائف حيوية', 'صحة عامة'], ['نقل الغذاء', 'نقل العناصر', 'نقل الأكسجين', 'توصيل العناصر'], ['إزالة الفضلات', 'تخليص الجسم من السموم', 'طرد السموم', 'تخلص من الفضلات'], ['تنظيم درجة حرارة الجسم', 'درجة حرارة الجسم'], ['صحة المفاصل', 'تليين المفاصل'], ['الهضم', 'الامتصاص'], ['صحة الأعضاء', 'حماية الأعضاء']]
        matched_reasons_count = 0
        for keywords_set in reasons_keywords:
            found_in_set = False
            for keyword in keywords_set:
                if keyword in value:
                    found_in_set = True
                    break
            if found_in_set:
                matched_reasons_count += 1
        if matched_reasons_count < 3:
            return False
        return True



class DataIdx815InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_815')

    def check_following(self, value):
        """
        Checks if the response is a numbered list of exactly four steps,
        where each step appears to start with an imperative verb based on a simple heuristic.

        Constraints:
        1.  Must be a numbered list (1, 2, 3, 4).
        2.  Must contain exactly four steps.
        3.  Each step must start with a word that is likely an imperative verb (heuristic check).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        expected_number = 1
        found_steps_content = []
        step_pattern = re.compile('^\\s*(\\d+)[\\.\\)]\\s*(.+)\\r?$')
        for line in lines:
            match = step_pattern.match(line)
            if match:
                step_num_str, step_content = match.groups()
                try:
                    step_num = int(step_num_str)
                except ValueError:
                    return False
                if step_num != expected_number:
                    return False
                found_steps_content.append(step_content)
                expected_number += 1
            elif line.strip() != '':
                return False
        if len(found_steps_content) != 4 or expected_number != 5:
            return False
        imperative_starts_heuristic = ('ا', 'أ', 'إ')
        for content in found_steps_content:
            trimmed_content = content.strip()
            if not trimmed_content:
                return False
            words = trimmed_content.split(maxsplit=1)
            if not words:
                return False
            first_word = words[0]
            if not first_word.startswith(imperative_starts_heuristic):
                return False
        return True



class DataIdx816InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_816')

    def check_following(self, value):
        """Checks if the response is a sentence starting with 'إذا' (if).
        Args:
            value: A string representing the response.

        Returns:
            True if the response starts with 'إذا' after stripping leading/trailing whitespace, False otherwise.
        """
        cleaned_value = value.strip()
        return cleaned_value.startswith('إذا')



class DataIdx817InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_817')

    def check_following(self, value):
        """Checks if the response contains the phrase 'خدمة العملاء'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains 'خدمة العملاء', False otherwise.
        """
        required_phrase = 'خدمة العملاء'
        return required_phrase in value



class DataIdx818InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_818')

    def check_following(self, value):
        """Checks if the response contains exactly three questions starting with 'لماذا' in Arabic.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (3 questions starting with 'لماذا'), False otherwise.
        """
        if not isinstance(value, str):
            return False
        parts = value.split('?')
        if len(parts) != 4:
            return False
        for i in range(3):
            question_part = parts[i]
            trimmed_part = question_part.strip()
            if not trimmed_part.startswith('لماذا'):
                return False
        return True



class DataIdx819InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_819')

    def check_following(self, value):
        """Checks if the response does not contain specific Af'al Nasikha (كان، أصبح، صار، ...).

        Args:
            value: A string representing the response (Arabic text).

        Returns:
            True if the response does not contain any of the forbidden verbs respecting word boundaries,
            False otherwise.
        """
        forbidden_verbs = ['كان', 'أصبح', 'صار', 'أضحى', 'أمسى', 'بات', 'ظل', 'ليس', 'ما زال', 'ما برح', 'ما فتئ', 'ما انفك', 'ما دام']
        pattern = '\\b(' + '|'.join((re.escape(verb) for verb in forbidden_verbs)) + ')\\b'
        if re.search(pattern, value):
            return False
        else:
            return True



class DataIdx820InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_820')

    def check_following(self, value):
        """Checks if the response contains at least five distinct common Arabic demonstrative pronouns.
        It does not verify the presence or correctness of examples or the language fusha constraint
        due to the limitations of basic string processing without NLP.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains at least five distinct common demonstrative pronouns, False otherwise.
        """
        demonstratives = ['هذا', 'هذه', 'هذان', 'هاتان', 'هؤلاء', 'ذلك', 'تلك', 'أولئك']
        found_demonstratives = set()
        value_to_check = value.lower()
        for demo in demonstratives:
            if demo in value_to_check:
                found_demonstratives.add(demo)
        return len(found_demonstratives) >= 5



class DataIdx821InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_821')

    def check_following(self, value):
        """Checks if the response follows the instruction for IDX 821.
        Instruction: Write a short dialogue in Arabic between two people,
        one asking for directions to the library, and the other answering.
        Must include at least one question and at least one answer.

        Args:
            value: A string representing the response (the dialogue).

        Returns:
            True if the response follows the instruction, False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        arabic_pattern = re.compile('[\\u0600-\\u06FF]')
        if not arabic_pattern.search(value):
            return False
        if '?' not in value:
            return False
        if 'المكتبة' not in value:
            return False
        direction_keywords = ['اذهب', 'انعطف', 'مباشرة', 'يمين', 'يسار', 'للأمام', 'خلف', 'بجانب', 'عند', 'سترى', 'بعد']
        found_direction_keyword = False
        for keyword in direction_keywords:
            if re.search('\\b' + re.escape(keyword) + '\\b', value):
                found_direction_keyword = True
                break
        if not found_direction_keyword:
            first_q_idx = value.find('?')
            if first_q_idx == -1 or first_q_idx >= len(value) - 1:
                return False
            pass
        if not found_direction_keyword:
            return False
        return True



class DataIdx822InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_822')

    def check_following(self, value):
        """Checks if the response follows the instruction for IDX 822.

        Constraints:
        - Write a paragraph in Standard Arabic. (Cannot reliably check with simple code)
        - At least five sentences. (Checking this)
        - Around the importance of education in developing societies. (Cannot reliably check with simple code)
        - Emphasize the role of technology in facilitating access. (Cannot reliably check with simple code)

        Args:
            value: A string representing the response paragraph.

        Returns:
            True if the response meets the checkable constraints (sentence count), False otherwise.
        """
        if not isinstance(value, str):
            return False
        processed_value = value.replace('!', '.').replace('؟', '.')
        sentences = processed_value.split('.')
        valid_sentences = [s.strip() for s in sentences if s.strip()]
        return len(valid_sentences) >= 5



class DataIdx823InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_823')

    def check_following(self, value):
        """Checks if the response describes the importance of education in building societies in less than 55 words,
        avoiding the word 'المجتمع'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if 'المجتمع' in value:
            return False
        words = value.split()
        word_count = len(words)
        if word_count >= 55:
            return False
        return True



class DataIdx824InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_824')

    def check_following(self, value):
        """
        Checks if the response includes an address in the upper right corner.
        This is checked by looking for common formal letter openings
        and ensuring there are at least 2 non-empty lines before them,
        structurally placed at the beginning of the text.

        Args:
            value: A string representing the response.

        Returns:
            True if the response likely follows the instruction regarding
            address placement and letter structure, False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        lines = value.strip().split('\n')
        stripped_lines = [line.strip() for line in lines]
        body_start_keywords = ['السيد', 'السادة', 'تحية طيبة وبعد', 'إلى شركة', 'السادة شركة', 'الموضوع:', 'بخصوص']
        body_start_index = -1
        for i, line in enumerate(stripped_lines):
            if any((line.startswith(keyword) for keyword in body_start_keywords)):
                body_start_index = i
                break
        lines_before_body = stripped_lines[:body_start_index if body_start_index != -1 else 0]
        non_empty_lines_before_body = sum((1 for line in lines_before_body if line))
        if body_start_index >= 2 and non_empty_lines_before_body >= 2:
            return True
        else:
            return False



class DataIdx825InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_825')

    def check_following(self, value):
        """Checks if the response is a three-step numbered recipe for mint tea without using the word 'ضع'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        has_step_1 = '١.' in value or '1.' in value
        has_step_2 = '٢.' in value or '2.' in value
        has_step_3 = '٣.' in value or '3.' in value
        three_steps_present = has_step_1 and has_step_2 and has_step_3
        contains_forbidden_word = 'ضع' in value
        return three_steps_present and (not contains_forbidden_word)



class DataIdx826InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_826')

    def check_following(self, value):
        """Checks if the response contains the word 'لذيذ' at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if isinstance(value, str):
            return 'لذيذ' in value
        return False



class DataIdx827InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_827')

    def check_following(self, value):
        """
        Checks if the response is formatted as single-marker italics (*text* or _text_)
        and does not contain a question mark.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if '?' in value:
            return False
        is_italicized = False
        if len(value) >= 3:
            marker = value[0]
            if (marker == '*' or marker == '_') and value[-1] == marker:
                if value[1] != marker and value[-2] != marker:
                    is_italicized = True
        return is_italicized



class DataIdx828InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_828')

    def check_following(self, value):
        """Checks if the response starts with 'هل' and ends with exactly one question mark.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        starts_with_hel = value.strip().startswith('هل')
        ends_with_question_mark = value.strip().endswith('?')
        question_mark_count = value.strip().count('?')
        has_exactly_one_question_mark = question_mark_count == 1
        return starts_with_hel and ends_with_question_mark and has_exactly_one_question_mark



class DataIdx829InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_829')

    def check_following(self, value):
        """Checks if the response presents the information in a three-column table format."""
        required_persons_data = [('محمد', '25', 'مهندس'), ('فاطمة', '30', 'طبيبة'), ('أحمد', '28', 'معلم')]
        all_values = set((item for sublist in required_persons_data for item in sublist))
        if not all((val in value for val in all_values)):
            return False
        is_html_attempt = '<table>' in value.lower() or '<tr>' in value.lower() or '<td>' in value.lower() or ('<th>' in value.lower())
        if is_html_attempt:
            rows_html = re.findall('<tr.*?>(.*?)</tr>', value, re.IGNORECASE | re.DOTALL)
            if rows_html:
                found_persons_in_html_rows = set()
                for row_content in rows_html:
                    cells = re.findall('<(td|th).*?>(.*?)</\\1>', row_content, re.IGNORECASE | re.DOTALL)
                    cell_values = [re.sub('<.*?>', '', cell_val).strip() for tag, cell_val in cells]
                    cell_values = [val for val in cell_values if val]
                    if not cell_values:
                        continue
                    matched_person_index = -1
                    for i, person_data_set in enumerate(required_persons_data):
                        person_data_list = list(person_data_set)
                        if all((item in cell_values for item in person_data_list)):
                            if len(cells) >= 2 and len(cells) <= 4:
                                matched_person_index = i
                                break
                    if matched_person_index != -1:
                        found_persons_in_html_rows.add(matched_person_index)
                if len(found_persons_in_html_rows) == 3:
                    return True
                if '<table>' in value.lower():
                    return False
        lines = value.strip().split('\n')
        found_persons_in_text_rows = set()
        delimiter_regex = '[|\\t,]| {2,}'
        for line in lines:
            line = line.strip()
            if not line or re.fullmatch('[\\s|:_-]+', line):
                continue
            line_contains_person_data_hint = False
            for person_data_set in required_persons_data:
                if any((item in line for item in person_data_set)):
                    line_contains_person_data_hint = True
                    break
            if not line_contains_person_data_hint:
                continue
            parts = re.split(delimiter_regex, line)
            parts = [p.strip() for p in parts if p.strip()]
            matched_person_index = -1
            for i, person_data_set in enumerate(required_persons_data):
                person_data_list = list(person_data_set)
                if all((item in line for item in person_data_list)):
                    if len(parts) >= 2 and len(parts) <= 4:
                        if all((item in parts for item in person_data_list)):
                            matched_person_index = i
                            break
            if matched_person_index != -1:
                found_persons_in_text_rows.add(matched_person_index)
        if len(found_persons_in_text_rows) == 3:
            return True
        return False



class DataIdx830InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_830')

    def check_following(self, value):
        """Checks if the response avoids using any exclamation marks.
        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain any exclamation marks, False otherwise.
        """
        return '!' not in value



class DataIdx831InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_831')

    def check_following(self, value):
        """Checks if the response avoids using the forbidden word 'ناطحة سحاب'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain the word 'ناطحة سحاب', False otherwise.
        """
        forbidden_word = 'ناطحة سحاب'
        return forbidden_word not in value



class DataIdx832InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_832')

    def check_following(self, value):
        """Checks if the response contains exactly three numbered list items in Markdown format (1., 2., 3.).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction, False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = [line.strip() for line in value.splitlines() if line.strip()]
        if len(lines) != 3:
            return False
        if not lines[0].startswith('1. '):
            return False
        if not lines[1].startswith('2. '):
            return False
        if not lines[2].startswith('3. '):
            return False
        return True



class DataIdx833InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_833')

    def check_following(self, value):
        """
        Checks if the response is a congratulatory message meeting the specified criteria.

        Args:
            value: A string representing the response message.

        Returns:
            True if the message follows all instructions, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if not 60 <= word_count <= 80:
            return False
        if 'تهاني' not in value:
            return False
        if 'مستقبل' not in value:
            return False
        alf_count = value.count('ألف')
        if alf_count != 1:
            return False
        return True



class DataIdx834InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_834')

    def check_following(self, value):
        """Checks if the response is a review in Arabic, at least 100 words long,
        and implies mentioning the author and book title in the first paragraph
        by checking the first paragraph's length and basic Arabic character presence.
        Args:
            value: A string representing the response (the Arabic review).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        words = value.split()
        total_word_count = len(words)
        if total_word_count < 100:
            return False
        paragraphs = value.split('\n\n')
        first_paragraph = paragraphs[0].strip() if paragraphs else ''
        first_paragraph_words = first_paragraph.split()
        if len(first_paragraph_words) < 10:
            return False
        arabic_char_count = sum((1 for char in value if '\u0600' <= char <= 'ۿ'))
        if arabic_char_count < 50:
            return False
        return True



class DataIdx835InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_835')

    def check_following(self, value):
        """Checks if the response follows the instruction constraints for IDX 835.

        Constraints:
        1. One suggestion (Semantic - Cannot check programmatically)
        2. Improve environment (Semantic - Cannot check programmatically)
        3. Single sentence (Structural - Check for newlines and internal terminators)
        4. Starts with imperative verb (Linguistic/Structural - Heuristic check based on common non-verb starts)

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the verifiable instructions or False otherwise.
        """
        if not isinstance(value, str):
            return False
        trimmed_value = value.strip()
        if not trimmed_value:
            return False
        if '\n' in trimmed_value or '\r' in trimmed_value:
            return False
        terminators = ['.', '!', '?']
        ends_with_valid_terminator = False
        content_before_trailing_terminators = trimmed_value
        while content_before_trailing_terminators and content_before_trailing_terminators[-1] in terminators:
            ends_with_valid_terminator = True
            content_before_trailing_terminators = content_before_trailing_terminators[:-1]
        if not ends_with_valid_terminator:
            return False
        if any((term in content_before_trailing_terminators for term in terminators)):
            return False

        def is_arabic_letter_basic(char):
            if not char:
                return False
            return '\u0600' <= char <= 'ۿ'
        first_char = trimmed_value[0]
        if not is_arabic_letter_basic(first_char):
            return False
        if trimmed_value.startswith('ال'):
            return False
        if len(trimmed_value) >= 3 and trimmed_value[0] in ['و', 'ف', 'ب', 'ل', 'ك'] and (trimmed_value[1:3] == 'ال'):
            return False
        non_verb_start_words = ['هل', 'في', 'على', 'من', 'الى', 'يا', 'ماذا', 'كيف', 'متى', 'أين', 'لماذا', 'ليس', 'إن', 'أن', 'كأن', 'لكن', 'ليت', 'لعل', 'اذ', 'إذا', 'حيث', 'حين', 'عندما', 'بينما', 'أو', 'أم', 'بل', 'لا', 'لم', 'لن', 'قد', 'سوف', 'س', 'فقط']
        first_word = trimmed_value.split(maxsplit=1)[0]
        if first_word in non_verb_start_words:
            return False
        return True



class DataIdx836InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_836')

    def check_following(self, value):
        """
        Checks if the response contains a question starting with 'كيف'
        followed by an answer of at least two sentences.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        q_mark_index = value.find('?')
        if q_mark_index == -1:
            return False
        question_part = value[:q_mark_index + 1].strip()
        answer_part = value[q_mark_index + 1:].strip()
        if not question_part.startswith('كيف'):
            return False
        if not answer_part:
            return False
        sentences = re.split('[.!?]', answer_part)
        valid_sentences = [s for s in sentences if s.strip()]
        if len(valid_sentences) < 2:
            return False
        return True



class DataIdx837InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_837')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 837.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        if len(words) < 40:
            return False
        if 'التعليم' not in value:
            return False
        if '!' in value:
            return False
        return True



class DataIdx838InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_838')

    def check_following(self, value):
        """Checks if the response describes how technology can improve education
        briefly (less than 5 sentences) and avoids using the word 'الإنترنت'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if 'الإنترنت' in value:
            return False
        sentence_delimiters = ['.', '!', '؟']
        cleaned_value = value
        for delim in sentence_delimiters:
            while delim * 2 in cleaned_value:
                cleaned_value = cleaned_value.replace(delim * 2, delim)
            cleaned_value = cleaned_value.replace(delim, f'{delim}###SENTENCE_END###')
        sentences = cleaned_value.split('###SENTENCE_END###')
        non_empty_sentences = [s for s in sentences if s.strip()]
        if len(non_empty_sentences) >= 5:
            return False
        return True



class DataIdx839InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_839')

    def check_following(self, value):
        """Checks if the response meets the criteria:
        1. Describes three qualities of a healthy romantic relationship (difficult to check programmatically without NLP or strict format).
        2. Uses at least 4 exclamation marks.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (specifically checking for exclamation marks), False otherwise.
        """
        exclamation_count = value.count('!')
        if exclamation_count < 4:
            return False
        return True



class DataIdx840InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_840')

    def check_following(self, value):
        """Checks if the response is an Arabic description not exceeding 100 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (word count <= 100),
            False otherwise.
        """
        words = value.split()
        return len(words) <= 100



class DataIdx841InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_841')

    def check_following(self, value):
        """Checks if the response consists of exactly one word.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (is one word), False otherwise.
        """
        stripped_value = value.strip()
        if not stripped_value:
            return False
        words = stripped_value.split()
        return len(words) == 1



class DataIdx842InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_842')

    def check_following(self, value):
        """Checks if the response explaining the water cycle is less than 75 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response has less than 75 words, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        return len(words) < 75



class DataIdx843InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_843')

    def check_following(self, value):
        """Checks if the response follows the instructions.
        The constraints are:
        1. Recipe must include at least five different ingredients. (Cannot be reliably checked from a free-form string without NLP or domain knowledge).
        2. Must not use numbers when listing ingredients. (Checking for the presence of digits in the whole string as a proxy).

        Args:
            value: A string representing the response (the recipe).

        Returns:
            True if the response follows the checkable constraints (no numbers), False otherwise.
        """
        arabic_digits = '٠١٢٣٤٥٦٧٨٩'
        latin_digits = '0123456789'
        all_digits = arabic_digits + latin_digits
        for char in value:
            if char in all_digits:
                return False
        return True



class DataIdx844InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_844')

    def check_following(self, value):
        """
        Checks if the response contains exactly two space-separated parts,
        does not contain 'و', and each part starts with a standard Arabic letter.
        Interprets "تبدأ كل كلمة في إجابتك بحرف كبير" as "each word starts with an Arabic letter".

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if 'و' in value:
            return False
        parts = value.split()
        if len(parts) != 2:
            return False
        for part in parts:
            first_char = part[0]
            is_arabic_letter = 'ء' <= first_char <= 'غ' or 'ف' <= first_char <= 'ي'
            if not is_arabic_letter:
                return False
        return True



class DataIdx845InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_845')

    def check_following(self, value):
        """Checks if the response follows the instruction for question 845.

        Args:
            value: A string representing the response (the paragraph).

        Returns:
            True if the response mentions "القراءة" at least 3 times
            and "الأطفال" at least 2 times, False otherwise.
        """
        if not isinstance(value, str):
            return False
        reading_count = value.count('القراءة')
        children_count = value.count('الأطفال')
        return reading_count >= 3 and children_count >= 2



class DataIdx846InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_846')

    def check_following(self, value):
        """Checks if the response critiques the email focusing on the tone."""
        tone_keywords = ['نبرة', 'لهجة', 'أسلوب', 'حادة', 'قاسية', 'عدوانية', 'تهديدية', 'مباشر', 'جاف', 'غير ودية', 'غير احترافية', 'غير لبقة', 'غير شخصية', 'تهديد', 'خشونة', 'قسوة', 'انتقاد', 'تحليل', 'تقييم', 'يمكن تحسين', 'أفضل استخدام', 'يفضل استخدام']
        for keyword in tone_keywords:
            if keyword in value:
                return True
        return False



class DataIdx847InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_847')

    def check_following(self, value):
        """Checks if the response is a single sentence expressing gratitude and containing the word 'ممتن'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        if 'ممتن' not in value:
            return False
        sentence_enders = ['.', '?', '!']
        end_punctuation_count = sum((value.count(p) for p in sentence_enders))
        if end_punctuation_count > 1:
            return False
        return True



class DataIdx848InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_848')

    def check_following(self, value):
        """Checks if the response is an Arabic sentence comparing coffee and tea using 'بينما'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        contains_bainama = 'بينما' in value
        contains_coffee = 'القهوة' in value
        contains_tea = 'الشاي' in value
        return contains_bainama and contains_coffee and contains_tea



class DataIdx849InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_849')

    def check_following(self, value):
        """Checks if the response follows the instruction.
        The instruction is to write a sentence about the weather without using the word 'شمس'.
        This checker specifically verifies that the word 'شمس' is not present in the response.
        Checking if the sentence is truly "about the weather" is outside the scope of this automated check.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain the word 'شمس', False otherwise.
        """
        return 'شمس' not in value



class DataIdx850InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_850')

    def check_following(self, value):
        """Checks if the response is a dialogue with at least six turns.
        This check uses a heuristic: counting lines that start with one or more
        Arabic letters followed by a colon, assuming this format marks a turn (e.g., "اسم: حوار").
        This method does NOT check for:
        - Arabic language content beyond character presence in the pattern.
        - The content being about two friends planning a trip.
        - The use of only present tense verbs.
        These latter checks require advanced NLP capabilities not implemented here.

        Args:
            value: A string representing the response (the dialogue).

        Returns:
            True if the response appears to have at least six turns based on the heuristic, False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        lines = value.strip().split('\n')
        turn_pattern = re.compile('^[ء-ي]+:')
        turn_count = 0
        for line in lines:
            if turn_pattern.match(line.strip()):
                turn_count += 1
        return turn_count >= 6



class DataIdx851InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_851')

    def check_following(self, value):
        """Checks if the response uses only comma and period as punctuation marks.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        allowed_punctuation = {',', '.'}
        forbidden_punctuation = set(string.punctuation) - allowed_punctuation
        for char in value:
            if char in forbidden_punctuation:
                return False
        return True



class DataIdx852InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_852')

    def check_following(self, value):
        """Checks if the response is a valid Surah name starting with 'الكاف'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        valid_surahs = ['الكهف', 'الكوثر', 'الكافرون']
        cleaned_value = value.strip()
        return cleaned_value in valid_surahs



class DataIdx853InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_853')

    def check_following(self, value):
        """Checks if the story does not contain the Arabic letter 'ق'.
        Args:
            value: A string representing the response (the story).

        Returns:
            True if the story does not contain 'ق', False otherwise.
        """
        return 'ق' not in value



class DataIdx854InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_854')

    def check_following(self, value):
        """Checks if the value is one nominal sentence without any verbs (heuristic check).
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        sentence_enders = ('.', '؟', '!')
        if not cleaned_value.endswith(sentence_enders):
            return False
        if len(cleaned_value) <= 1:
            return False
        text_part = cleaned_value[:-1].strip()
        if not text_part:
            return False
        verbs_to_check = {'كان', 'يكون', 'صار', 'يصير', 'ليس', 'فعل', 'يفعل', 'قال', 'يقول', 'ذهب', 'يذهب', 'كتب', 'يكتب', 'أكل', 'يأكل', 'شرب', 'يشرب', 'نام', 'ينام', 'عرف', 'يعرف', 'عمل', 'يعمل', 'درس', 'يدرس', 'أراد', 'يريد', 'وجد', 'يجد', 'أخذ', 'يأخذ', 'جاء', 'يجيء', 'رأى', 'يرى', 'سمع', 'يسمع', 'قرأ', 'يقرأ', 'شاهد', 'يشاهد', 'ذهبوا', 'كتبوا', 'قالوا', 'كانوا', 'يكونوا', 'ذهبت', 'كتبت', 'قالت', 'كانت', 'تكون', 'ليست', 'اذهب', 'اكتب', 'قل', 'افعل', 'كل', 'نم', 'اشرب', 'اقرأ'}
        particles = ('و', 'ف', 'ب', 'ك', 'ل')
        words = text_part.split()
        for word in words:
            if word in verbs_to_check:
                return False
            if len(word) > 1 and word[0] in particles:
                word_after_particle = word[1:]
                if word_after_particle in verbs_to_check:
                    return False
        return True



class DataIdx855InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_855')

    def check_following(self, value):
        """Checks if the response is a dialogue between two people about reading,
        contains a question, has turns for each, and is at least 80 words long.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        word_count = len(words)
        if word_count < 80:
            return False
        if '؟' not in value:
            return False
        speaker_pattern = re.compile('^\\s*(\\S+):', re.MULTILINE)
        speakers = set(speaker_pattern.findall(value))
        if len(speakers) < 2:
            return False
        return True



class DataIdx856InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_856')

    def check_following(self, value: str) -> bool:
        """Checks if the response lists exactly five items, each being a single-sentence description.

        Args:
            value: A string representing the student's response.

        Returns:
            True if the response follows the instruction (5 items, each a single sentence),
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        items = [line for line in value.strip().split('\n') if line.strip()]
        if len(items) != 5:
            return False
        sentence_terminators_pattern = re.compile('[.?!]')
        for item in items:
            item_trimmed_end = item.rstrip()
            if not item_trimmed_end:
                return False
            last_char_index = len(item_trimmed_end) - 1
            if last_char_index < 0 or item_trimmed_end[last_char_index] not in '.?!':
                return False
            item_excluding_last = item_trimmed_end[:-1]
            if sentence_terminators_pattern.search(item_excluding_last):
                return False
        return True



class DataIdx857InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_857')

    def check_following(self, value):
        """Checks if the response is a single question starting with 'لماذا' and ending with '?'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction, False otherwise.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        starts_with_لماذا = stripped_value.startswith('لماذا')
        ends_with_question_mark = stripped_value.endswith('?')
        contains_single_question_mark = stripped_value.count('?') == 1
        return starts_with_لماذا and ends_with_question_mark and contains_single_question_mark



class DataIdx858InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_858')

    def check_following(self, value):
        """Checks if the response follows the instruction for IDX 858.
        Instruction: ابدأ إجابتك بـ: "حسب الطلب:". ثم اذكر أربعة كواكب في نظامنا الشمسي.
        (Start your answer with: "As requested:". Then mention four planets in our solar system.)

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        required_start = 'حسب الطلب:'
        if not value.startswith(required_start):
            return False
        planets_ar = ['عطارد', 'الزهرة', 'الأرض', 'المريخ', 'المشتري', 'زحل', 'أورانوس', 'نبتون']
        found_planets = set()
        for planet in planets_ar:
            if planet in value:
                found_planets.add(planet)
        if len(found_planets) == 4:
            return True
        else:
            return False



class DataIdx859InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_859')

    def check_following(self, value):
        """Checks if the response is a single sentence about the importance of reading
           containing 'المعرفة' and 'التطور', ending with a single sentence terminator.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        required_words = ['المعرفة', 'التطور']
        sentence_terminators = ['.', '!', '?']
        stripped_value = value.strip()
        if not stripped_value:
            return False
        has_all_words = all((word in stripped_value for word in required_words))
        if not has_all_words:
            return False
        ends_with_terminator = stripped_value.endswith(tuple(sentence_terminators))
        if not ends_with_terminator:
            return False
        terminator_count = sum((stripped_value.count(term) for term in sentence_terminators))
        if terminator_count != 1:
            return False
        return True



class DataIdx860InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_860')

    def check_following(self, value):
        """Checks if the response is a three-sentence Arabic paragraph about tolerance,
           containing the words 'respect' and 'difference'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        has_tolerance = 'التسامح' in value
        has_respect = 'احترام' in value
        has_difference = 'اختلاف' in value
        num_terminators = value.count('.') + value.count('!') + value.count('?')
        return has_tolerance and has_respect and has_difference and (num_terminators == 3)



class DataIdx861InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_861')

    def check_following(self, value):
        """Checks if the response is one question about air pollution starting with a question word and ending with '!'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        ends_with_exclamation = cleaned_value.endswith('!')
        question_words = {'هل', 'كيف', 'لماذا', 'ما', 'ماذا', 'متى', 'أين', 'أي', 'كم'}
        starts_with_question_word = False
        for word in question_words:
            if cleaned_value.startswith(word):
                starts_with_question_word = True
                break
        return ends_with_exclamation and starts_with_question_word



class DataIdx862InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_862')

    def check_following(self, value):
        """Checks if the response does not mention cats or dogs in Arabic.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain the words for cats or dogs in Arabic,
            False otherwise.
        """
        forbidden_words = ['القطط', 'الكلاب']
        for word in forbidden_words:
            if word in value:
                return False
        return True



class DataIdx863InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_863')

    def check_following(self, value):
        """Checks if the response is a four-word sentence with no punctuation.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        punctuation = set('!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~،؛؟')
        has_punctuation = any((char in punctuation for char in value))
        if has_punctuation:
            return False
        words = value.split()
        words = [word for word in words if word]
        word_count = len(words)
        if word_count != 4:
            return False
        return True



class DataIdx864InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_864')

    def check_following(self, value):
        """Checks if the response follows the instruction:
        - Three short Arabic sentences describing weather.
        - Each sentence must contain at least one word starting with 'م'.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        sentences = re.split('[.?!؛]', value)
        sentences = [s.strip() for s in sentences if s.strip()]
        if len(sentences) != 3:
            return False
        leading_punctuation = '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~«»‘’“”„'
        for sentence in sentences:
            if not any(('\u0600' <= c <= 'ۿ' for c in sentence)):
                return False
            words = sentence.split()
            found_meem = False
            for word in words:
                cleaned_word = word.lstrip(leading_punctuation)
                if cleaned_word and cleaned_word.startswith('م'):
                    found_meem = True
                    break
            if not found_meem:
                return False
        return True



class DataIdx865InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_865')

    def check_following(self, value):
        """Checks if the response is a single sentence containing 'شمس', 'قمر', and 'نجوم' in Arabic.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        has_sun = 'شمس' in cleaned_value
        has_moon = 'قمر' in cleaned_value
        has_stars = 'نجوم' in cleaned_value
        if not (has_sun and has_moon and has_stars):
            return False
        sentence_enders = {'.', '!', '?'}
        is_single_sentence = True
        if len(cleaned_value) > 1:
            for char in cleaned_value[:-1]:
                if char in sentence_enders:
                    is_single_sentence = False
                    break
        return is_single_sentence



class DataIdx866InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_866')

    def check_following(self, value):
        """Checks if the response is a single sentence containing 'لكن' and has less than 8 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        contains_lakin = 'لكن' in value
        words = value.split()
        word_count = len(words)
        less_than_eight_words = word_count < 8
        return contains_lakin and less_than_eight_words



class DataIdx867InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_867')

    def check_following(self, value):
        """Checks if the response mentions three reasons using bullet points.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.splitlines()
        bullet_count = 0
        for line in lines:
            cleaned_line = line.strip()
            if cleaned_line.startswith('•'):
                bullet_count += 1
        return bullet_count == 3



class DataIdx868InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_868')

    def check_following(self, value):
        """Checks if the response is a short text message not exceeding 100 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (word count <= 100),
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return word_count <= 100



class DataIdx869InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_869')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        paragraphs = value.split('\n')
        if len(paragraphs) != 2:
            return False
        paragraph1 = paragraphs[0]
        if not paragraph1.strip().startswith('يجب'):
            return False
        placeholder_count = 0
        search_start_index = 0
        while True:
            open_bracket_index = value.find('⟨', search_start_index)
            if open_bracket_index == -1:
                break
            close_bracket_index = value.find('⟩', open_bracket_index + 1)
            if close_bracket_index == -1:
                break
            placeholder_count += 1
            search_start_index = close_bracket_index + 1
        if placeholder_count < 2:
            return False
        return True



class DataIdx870InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_870')

    def check_following(self, value):
        """Checks if the response is a single sentence expressing a wish to visit a place,
           including 'أتمنى', potentially including a place name, and not using present tense verbs.
           Note: Checking for a place name and the absence of arbitrary present tense verbs
           is complex and not fully reliable with basic string checks.
           This checker focuses on the presence of the keyword and sentence structure.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the checkable instructions, False otherwise.
        """
        if not isinstance(value, str):
            return False
        if 'أتمنى' not in value:
            return False
        terminal_punctuation = ['.', '!', '؟']
        stripped_value = value.strip()
        if not stripped_value.endswith(tuple(terminal_punctuation)):
            return False
        for i in range(len(stripped_value) - 1):
            if stripped_value[i] in terminal_punctuation:
                return False
        return True



class DataIdx871InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_871')

    def _extract_arabic_words(self, text):
        """Extracts distinct Arabic words (sequences of Arabic characters) from a string."""
        arabic_words = re.findall('[\\u0600-\\u06FF]+', text)
        return set(arabic_words)

    def check_following(self, value):
        """
        Checks if the response provides exactly one synonym and one antonym
        for each of the four words: 'سريع', 'كبير', 'جميل', 'قوي'.
        It checks for the presence of all four target words and verifies that
        the text following each target word contains exactly two other distinct Arabic words.
        This checks the structural constraint of providing a pair of words for each target word.

        Args:
            value: A string representing the student's response.

        Returns:
            True if the response follows the instruction's structural/counting constraints
            (presence of all target words and exactly two words provided per target word),
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        target_words = ['سريع', 'كبير', 'جميل', 'قوي']
        word_indices = []
        for word in target_words:
            try:
                idx = value.index(word)
                word_indices.append((idx, word))
            except ValueError:
                return False
        word_indices.sort()
        segments = []
        for i in range(len(word_indices)):
            start_idx = word_indices[i][0] + len(word_indices[i][1])
            end_idx = word_indices[i + 1][0] if i + 1 < len(word_indices) else len(value)
            segment_text = value[start_idx:end_idx]
            segments.append(segment_text)
        for i, segment in enumerate(segments):
            segment_arabic_words = self._extract_arabic_words(segment)
            current_target_word = word_indices[i][1]
            segment_arabic_words.discard(current_target_word)
            if len(segment_arabic_words) != 2:
                return False
        return True



class DataIdx872InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_872')

    def check_following(self, value):
        """
        Checks if the response is a description around 170 words
        and uses at least one simile (مثل, كأن, كما).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        words = value.split()
        word_count = len(words)
        length_ok = 150 <= word_count <= 190
        simile_words_to_check = ['مثل', 'كأن', 'كما']
        simile_present = any((sw in value for sw in simile_words_to_check))
        return length_ok and simile_present



class DataIdx873InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_873')

    def check_following(self, value):
        """Checks if the response lists exactly five numbered points from 1 to 5.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction, False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().splitlines()
        cleaned_lines = [line.strip() for line in lines if line.strip()]
        if len(cleaned_lines) != 5:
            return False
        for i, line in enumerate(cleaned_lines):
            expected_start = f'{i + 1}.'
            if not line.startswith(expected_start):
                return False
        return True



class DataIdx874InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_874')

    def check_following(self, value):
        """Checks if the response is a conditional sentence about studying hard results,
        includes 'إذا', and includes 'النجاح'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        includes_conditional_particle = 'إذا' in value
        includes_success_word = 'النجاح' in value
        return includes_conditional_particle and includes_success_word



class DataIdx875InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_875')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 875.

        Instructions:
        1. Describe in two short sentences your feeling when hearing good news.
        2. The two sentences must not exceed 25 words in total.
        3. Must use the word 'سعادة' (sa'ada - happiness) at least once.
        4. Answer is in Arabic. (Implicit)

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instructions or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        keyword_present = 'سعادة' in cleaned_value
        words = cleaned_value.split()
        word_count = len(words)
        is_word_count_ok = word_count <= 25
        segments = re.split('[.?!؟]', cleaned_value)
        sentence_segments = [s for s in segments if s.strip()]
        sentence_count = len(sentence_segments)
        is_two_sentences = sentence_count == 2
        return keyword_present and is_two_sentences and is_word_count_ok



class DataIdx876InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_876')

    def check_following(self, value):
        """Checks if the response is a short name starting with 'م'.

        Args:
            value: A string representing the proposed name.

        Returns:
            True if the response starts with 'م' and is reasonably short,
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        starts_with_meem = value.startswith('م')
        is_short = len(value.strip()) <= 8 and len(value.strip()) > 0
        return starts_with_meem and is_short



class DataIdx877InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_877')

    def check_following(self, value):
        """Checks if the response is a simple salad recipe with at least 4 ingredients and a preparation method.
        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value:
            return False
        processed_value = value.replace('،', ',')
        if processed_value.find('سلطة') == -1:
            return False
        ingredients_keyword = 'المكونات'
        method_keyword = 'طريقة التحضير'
        idx_ingredients = processed_value.find(ingredients_keyword)
        idx_method = processed_value.find(method_keyword)
        if idx_ingredients == -1 or idx_method == -1 or idx_method < idx_ingredients:
            return False
        start_idx = idx_ingredients + len(ingredients_keyword)
        end_idx = idx_method
        if start_idx > end_idx:
            return False
        ingredients_text = processed_value[start_idx:end_idx]
        ingredient_list = [item.strip() for item in ingredients_text.split(',') if item.strip()]
        return len(ingredient_list) >= 4



class DataIdx878InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_878')

    def check_following(self, value: str) -> bool:
        """Checks if the response follows the instruction for IDX 878.
        The instructions require:
        1. Solving the arithmetic problem (5 * 7 = 35).
        2. Providing the solution step by step.
        3. Steps must be numbered.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        value_str = value.lower()
        contains_5 = re.search('\\b5\\b', value_str) is not None
        contains_7 = re.search('\\b7\\b', value_str) is not None
        contains_35 = re.search('\\b35\\b', value_str) is not None
        numbered_step_pattern = re.compile('^\\s*\\d+[\\.\\)]')
        numbered_steps_count = sum((1 for line in lines if numbered_step_pattern.match(line)))
        follows_numbering_constraint = numbered_steps_count >= 2
        follows_content_hint_constraint = contains_5 and contains_7 and contains_35
        return follows_numbering_constraint and follows_content_hint_constraint



class DataIdx879InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_879')

    def check_following(self, value):
        """Checks if the response is a single Arabic sentence about the importance of education
           containing the word 'ضروري'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        response = value.strip()
        required_word = 'ضروري'
        if required_word not in response:
            return False
        sentence_enders = ['.', '?', '!']
        ends_with_punctuation = False
        for end in sentence_enders:
            if response.endswith(end):
                ends_with_punctuation = True
                content_before_end = response[:-1]
                if any((other_end in content_before_end for other_end in sentence_enders)):
                    return False
                break
        if not ends_with_punctuation:
            return False
        return True



class DataIdx880InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_880')

    def check_following(self, value):
        """Checks if the response is a book review mentioning author, genre, and 5-star rating.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        author_mentioned = 'المؤلف' in value
        genre_mentioned = 'النوع' in value
        rating_digit_mentioned = any((str(i) in value for i in range(1, 6)))
        rating_scale_mentioned = 'نجوم' in value or 'من 5' in value or 'من أصل 5' in value
        rating_mentioned = rating_digit_mentioned and rating_scale_mentioned
        return author_mentioned and genre_mentioned and rating_mentioned



class DataIdx881InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_881')

    def check_following(self, value):
        """Checks if the response follows the constraints for IDX 881.
        Constraints:
        1. Not exceed 100 words.
        2. Use exclamation mark (!) at least twice.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        word_count = len(words)
        word_count_ok = word_count <= 100
        exclamation_count = value.count('!')
        exclamation_count_ok = exclamation_count >= 2
        return word_count_ok and exclamation_count_ok



class DataIdx882InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_882')

    def check_following(self, value):
        """Checks if the response mentions two famous Arab rivers and ends with 'يجريان بسلام'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        value = value.strip()
        ending_phrase = 'يجريان بسلام'
        if not value.endswith(ending_phrase):
            return False
        part_before_ending = value[:-len(ending_phrase)].strip()
        famous_rivers = ['النيل', 'دجلة', 'الفرات']
        found_rivers = set()
        for river in famous_rivers:
            if river in part_before_ending:
                found_rivers.add(river)
        if len(found_rivers) != 2:
            return False
        return True



class DataIdx883InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_883')

    def check_following(self, value):
        """Checks if the response avoids using plural forms in words by checking against a list of common plural words.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response appears to avoid plural forms based on the check logic, False otherwise.
        """
        if not isinstance(value, str):
            return False
        common_plurals = {'الناس', 'الآخرين', 'بالآخرين', 'للآخرين', 'الفقراء', 'للفقراء', 'بالفقراء', 'المساكين', 'بالمساكين', 'مساكين', 'بمساكين', 'الأيتام', 'المرضى', 'الضعفاء', 'المحتاجين', 'بالمحتاجين', 'المنكوبين', 'المتألمين', 'شعوب', 'قلوب', 'عيون', 'أيدي', 'أيام', 'بيوت', 'كتب', 'رجال', 'نساء', 'أطفال', 'معلمون', 'المعلمون', 'معلمين', 'المعلمين', 'مهندسون', 'المهندسون', 'مهندسين', 'المهندسين', 'مؤمنون', 'المؤمنون', 'مؤمنين', 'المؤمنين', 'سيارات', 'السيارات', 'بنات', 'البنات', 'معلمات', 'المعلمات', 'مؤمنات', 'المؤمنات', 'مشاعر', 'ظروف', 'مصاعب', 'هموم', 'آلام', 'دموع', 'أشخاص', 'مواقف', 'أنفس', 'أفراد', 'جوانب'}
        arabic_words = re.findall('[ا-ي]+', value)
        for word in arabic_words:
            if word in common_plurals:
                return False
        return True



class DataIdx884InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_884')

    def check_following(self, value):
        """Checks if the response follows the constraints: no more than 150 words and no commas.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if ',' in value:
            return False
        words = value.split()
        word_count = len(words)
        if word_count > 150:
            return False
        return True



class DataIdx885InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_885')

    def check_following(self, value):
        """Checks if the response appears to contain an explanation and a counter-argument based on keywords.

        Args:
            value: A string representing the response.

        Returns:
            True if the response likely follows the instruction (contains markers of explanation and counter-argument),
            False otherwise.
        """
        response = value
        explanation_indicators = ['التفسير هو', 'يفسر ذلك', 'بسبب', 'يعود إلى', 'نتيجة لـ', 'يؤدي إلى', 'الظاهرة تحدث لأن']
        counter_argument_indicators = ['حجة مضادة', 'من ناحية أخرى', 'في المقابل', 'مع ذلك', 'ولكن', 'إلا أن', 'رغم أن', 'بينما قد يجادل البعض', 'يعترض على ذلك']
        has_explanation = any((indicator in response for indicator in explanation_indicators))
        has_counter_argument = any((indicator in response for indicator in counter_argument_indicators))
        return has_explanation and has_counter_argument



class DataIdx886InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_886')

    def check_following(self, value):
        """Checks if the response is structured as two paragraphs.
        
        Args:
            value: A string representing the response.

        Returns:
            True if the response appears to be structured as exactly two paragraphs
            (separated by at least one blank line), False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        paragraphs = value.split('\n\n')
        non_empty_paragraphs = [p.strip() for p in paragraphs if p.strip()]
        return len(non_empty_paragraphs) == 2



class DataIdx887InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_887')

    def check_following(self, value):
        """Checks if the response (an email recommending a book) does not contain exclamation marks.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (no exclamation marks), False otherwise.
        """
        return '!' not in value



class DataIdx888InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_888')

    def check_following(self, value):
        """Checks if the response is a news report that includes a quote from an eyewitness.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        contains_quotes = '"' in value or "'" in value
        contains_eyewitness = 'شاهد عيان' in value
        return contains_quotes and contains_eyewitness



class DataIdx889InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_889')

    def check_following(self, value):
        """Checks if the response lists three items of a category and three items
        of another category, separated by semicolons, and uses 'و' between the
        last two items within each group of three.

        Expected format: Item1;Item2 و Item3;Item4;Item5 و Item6
        Where Items 1-3 belong to one category and Items 4-6 to the other.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        normalized_value = value.strip()
        if normalized_value.count(';') != 3:
            return False
        parts = normalized_value.split(';')
        if len(parts) != 4:
            return False
        waaw_separator = ' و '
        part1 = parts[0].strip()
        if waaw_separator in part1 or not part1:
            return False
        part2 = parts[1].strip()
        if waaw_separator not in part2:
            return False
        sub_parts2 = part2.split(waaw_separator)
        if len(sub_parts2) != 2:
            return False
        sub_part2_a = sub_parts2[0].strip()
        sub_part2_b = sub_parts2[1].strip()
        if not sub_part2_a or not sub_part2_b:
            return False
        part3 = parts[2].strip()
        if waaw_separator in part3 or not part3:
            return False
        part4 = parts[3].strip()
        if waaw_separator not in part4:
            return False
        sub_parts4 = part4.split(waaw_separator)
        if len(sub_parts4) != 2:
            return False
        sub_part4_a = sub_parts4[0].strip()
        sub_part4_b = sub_parts4[1].strip()
        if not sub_part4_a or not sub_part4_b:
            return False
        return True



class DataIdx890InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_890')

    def check_following(self, value):
        """Checks if the response follows the instructions for question IDX 890.

        The constraints are:
        1. The response must not exceed nine lines.
        2. The response must end with the exact phrase '... وكانت القطة سعيدة.'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows all instructions or False otherwise.
        """
        lines = value.split('\n')
        if len(lines) > 9:
            return False
        required_ending = '... وكانت القطة سعيدة.'
        if not value.strip().endswith(required_ending):
            return False
        return True



class DataIdx891InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_891')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        word_count_ok = 90 <= word_count <= 130
        ingredients_keywords = ['المكونات', 'الأدوات', 'المواد']
        ingredients_check = any((keyword in value for keyword in ingredients_keywords))
        digits = '0123456789٠١٢٣٤٥٦٧٨٩'
        separators = '.:'
        step_pattern_count = 0
        for i in range(len(value) - 1):
            if value[i] in digits and value[i + 1] in separators:
                step_pattern_count += 1
        numbered_steps_check = step_pattern_count >= 3
        return word_count_ok and ingredients_check and numbered_steps_check



class DataIdx892InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_892')

    def check_following(self, value):
        """Checks if the response is a valid Arabic news headline according to the constraints.

        Args:
            value: A string representing the response (the news headline).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        arabic_chars_present = any(('\u0600' <= char <= 'ۿ' for char in value))
        if not arabic_chars_present:
            return False
        words = value.split()
        word_count = len(words)
        if word_count > 15:
            return False
        return True



class DataIdx893InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_893')

    def check_following(self, value):
        """Checks if the response is a dialogue between A and B including at least
        one question and one answer for each character.

        Args:
            value: A string representing the response (the dialogue).

        Returns:
            True if the response follows the instruction, False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        normalized_value = value.replace('A:', 'أ:').replace('B:', 'ب:')
        normalized_value = normalized_value.replace('أ:', 'أ: ').replace('ب:', 'ب: ')
        lines = normalized_value.strip().split('\n')
        a_turns = []
        b_turns = []
        for line in lines:
            line = line.strip()
            if line.startswith('أ:'):
                turn_content = line[3:].strip()
                if turn_content:
                    a_turns.append(turn_content)
            elif line.startswith('ب:'):
                turn_content = line[3:].strip()
                if turn_content:
                    b_turns.append(turn_content)
        if not a_turns or not b_turns:
            return False
        a_has_question = any((turn.endswith('?') for turn in a_turns))
        a_has_answer = any((not turn.endswith('?') for turn in a_turns))
        if not a_has_question or not a_has_answer:
            return False
        b_has_question = any((turn.endswith('?') for turn in b_turns))
        b_has_answer = any((not turn.endswith('?') for turn in b_turns))
        if not b_has_question or not b_has_answer:
            return False
        return True



class DataIdx894InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_894')

    def check_following(self, value):
        """Checks if the response defines 'الاجتهاد' in no more than 15 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response has 15 words or less, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        return len(words) <= 15



class DataIdx895InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_895')

    def check_following(self, value):
        """Checks if the response is a short riddle not exceeding 25 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (word count <= 25) or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        return len(words) <= 25



class DataIdx896InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_896')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        words = stripped_value.split()
        if len(words) != 1:
            return False
        the_word = words[0]
        adjectives_to_exclude = ['جميلة', 'كبيرة', 'صغيرة', 'قديمة', 'جديدة', 'رائعة', 'مشهورة', 'عظيمة', 'تاريخية', 'عريق']
        if the_word in adjectives_to_exclude:
            return False
        return True



class DataIdx897InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_897')

    def check_following(self, value):
        """Checks if the response is an Arabic interrogative sentence asking about the time and includes 'الساعة'.
        
        Constraints:
        1. Must be an interrogative sentence (ends with '?').
        2. Must include the word 'الساعة'.
        3. Implicitly, it should be in Arabic asking about time, which is strongly implied by the other two constraints and the required word.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        contains_saah = 'الساعة' in value
        ends_with_question_mark = value.strip().endswith('?')
        return contains_saah and ends_with_question_mark



class DataIdx898InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_898')

    def check_following(self, value):
        """
        Checks if the response is a report in Arabic with three paragraphs,
        meeting minimum word counts per paragraph.
        Paragraph 1: >= 30 words
        Paragraph 2: >= 20 words
        Paragraph 3: >= 10 words
        Assumes paragraphs are separated by two or more newline characters (

).
        """
        if not isinstance(value, str):
            return False
        paragraphs = [p.strip() for p in value.split('\n\n') if p.strip()]
        if len(paragraphs) != 3:
            return False
        min_word_counts = [30, 20, 10]
        for i in range(3):
            paragraph = paragraphs[i]
            words = paragraph.split()
            word_count = len([word for word in words if word])
            if word_count < min_word_counts[i]:
                return False
        return True



class DataIdx899InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_899')

    def check_following(self, value):
        """Checks if the response consists of exactly two words.

        Args:
            value: A string representing the response (the name of the river).

        Returns:
            True if the response consists of exactly two words, False otherwise.
        """
        words = value.split()
        return len(words) == 2



class DataIdx900InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_900')

    def check_following(self, value):
        """Checks if the response is one question about the weather, using both a question mark and an exclamation mark together.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        contains_arabic_question = value.count('؟') == 1
        contains_english_question = value.count('?') == 1
        contains_exclamation = value.count('!') == 1
        return contains_arabic_question ^ contains_english_question and contains_exclamation



class DataIdx901InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_901')

    def check_following(self, value):
        """Checks if the response is a short story (around 100 words)
        including a dialogue between two characters.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """

        def simple_word_count(text):
            words = text.split()
            count = 0
            punctuation = '.,!?;:"\'()[]{}<>/\\—'
            for word in words:
                cleaned_word = word.strip(punctuation)
                if cleaned_word:
                    count += 1
            return count
        word_count = simple_word_count(value)
        min_words = 80
        max_words = 120
        word_count_ok = min_words <= word_count <= max_words

        def has_dialogue_between_two(text):
            first_quote_idx = -1
            is_double_quote = False
            first_double_start = text.find('"')
            first_single_start = text.find("'")
            if first_double_start != -1 and (first_single_start == -1 or first_double_start < first_single_start):
                first_quote_idx = first_double_start
                is_double_quote = True
            elif first_single_start != -1:
                first_quote_idx = first_single_start
                is_double_quote = False
            if first_quote_idx != -1:
                closing_char = '"' if is_double_quote else "'"
                first_closing_idx = text.find(closing_char, first_quote_idx + 1)
                if first_closing_idx != -1:
                    second_double_after = text.find('"', first_closing_idx + 1)
                    second_single_after = text.find("'", first_closing_idx + 1)
                    if second_double_after != -1 or second_single_after != -1:
                        return True
            lines = text.split('\n')
            dash_dialogue_lines = 0
            for line in lines:
                if line.strip().startswith('—'):
                    dash_dialogue_lines += 1
            if dash_dialogue_lines >= 2:
                return True
            return False
        has_dialogue = has_dialogue_between_two(value)
        return word_count_ok and has_dialogue



class DataIdx902InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_902')

    def check_following(self, value):
        """Checks if the response defines 'الخوارزمية' with the bolded term at the start.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        required_start = '**الخوارزمية**'
        if not value.startswith(required_start):
            return False
        remaining_text = value[len(required_start):].strip()
        if len(remaining_text) == 0:
            return False
        return True



class DataIdx903InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_903')

    def check_following(self, value):
        """Checks if the response is a single sentence containing 'سعيد' and 'مسرور'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        contains_saeed = 'سعيد' in value
        contains_masroor = 'مسرور' in value
        sentence_terminators = ['.', '!', '?']
        terminator_count = sum((value.count(term) for term in sentence_terminators))
        is_single_sentence = terminator_count <= 1
        return contains_saeed and contains_masroor and is_single_sentence



class DataIdx904InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_904')

    def check_following(self, value):
        """Checks if the response has more than 100 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response has more than 100 words, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return word_count > 100



class DataIdx905InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_905')

    def check_following(self, value):
        """Checks if the response lists three personal goals, each starting with an Arabic present tense verb.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = [line.strip() for line in value.strip().splitlines() if line.strip()]
        if len(lines) != 3:
            return False
        present_tense_prefixes = {'أ', 'ن', 'ي', 'ت'}
        for line in lines:
            words = line.split()
            if not words:
                return False
            first_word = words[0]
            if not first_word or first_word[0] not in present_tense_prefixes:
                return False
        return True



class DataIdx906InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_906')

    def check_following(self, value):
        """Checks if the response describes the school in exactly three points.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains exactly three distinct points (lines), False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.split('\n')
        non_empty_lines = [line for line in lines if line.strip()]
        return len(non_empty_lines) == 3



class DataIdx907InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_907')

    def check_following(self, value):
        """Checks if the response describes a smartphone focusing on the advanced camera."""
        min_length = 100
        if not isinstance(value, str) or len(value.strip()) < min_length:
            return False
        text = value.strip().lower()
        general_keywords = ['شاشة', 'بطارية', 'أداء', 'معالج', 'تصميم', 'مساحة تخزين', 'ذاكرة', 'صوت', 'مكبرات', 'شبكة', 'اتصال']
        camera_keywords = ['كاميرا', 'ميجابكسل', 'عدسة', 'تصوير', 'صور', 'فيديو', 'جودة', 'لقطات', 'زوم', 'ليل', 'فتحة', 'تركيز', 'إضاءة', 'بورتريه', 'واسعة', 'زاوية', 'فلاتر', 'ذكاء اصطناعي', 'مثبت بصري', 'تقريب', 'سينمائي', 'احترافي']
        translator = str.maketrans('', '', string.punctuation + '«»،؛ـ')
        words = [word.translate(translator) for word in text.split()]
        words = [word for word in words if word]
        total_general_occurrences = sum((1 for word in words if word in general_keywords))
        total_camera_occurrences = sum((1 for word in words if word in camera_keywords))
        contains_general = total_general_occurrences > 0
        if not contains_general:
            return False
        contains_camera_word = 'كاميرا' in words
        contains_specific_camera_detail = any((word in words for word in camera_keywords if word != 'كاميرا'))
        contains_camera_features = contains_camera_word and contains_specific_camera_detail
        if not contains_camera_features:
            return False
        focus_on_camera = total_camera_occurrences > total_general_occurrences
        return focus_on_camera



class DataIdx908InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_908')

    def check_following(self, value):
        """Checks if the response is a single line and starts with 'اللهم'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is a single line and starts with 'اللهم', False otherwise.
        """
        is_single_line = '\n' not in value
        starts_with_allahumma = value.startswith('اللهم')
        return is_single_line and starts_with_allahumma



class DataIdx909InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_909')

    def check_following(self, value):
        """
        Checks if the response follows the constraints for riddle IDX 909.

        Constraints:
        1. A relatively difficult riddle about a mobile phone. (Subjective, not checked)
        2. Do not mention the name of the answer explicitly.
        3. Consists of exactly three poetic lines.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        lines = [line.strip() for line in value.split('\n') if line.strip()]
        if len(lines) != 3:
            return False
        forbidden_words = ['هاتف', 'جوال', 'موبايل', 'تلفون']
        punctuation_to_remove = '.,!?;:()[]{}«»<>،؛؟'
        translator = str.maketrans('', '', punctuation_to_remove)
        cleaned_value = value.translate(translator)
        words = ' '.join(cleaned_value.split()).split()
        for forbidden in forbidden_words:
            if forbidden in words:
                return False
        return True



class DataIdx910InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_910')

    def check_following(self, value):
        """Checks if the response is a numbered list of 5 items, starting with 1. to 5.,
        and each item has some content after the number.
        (Cannot reliably check if each item starts with a verb using basic string methods).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the structural and count constraints, False otherwise.
        """
        lines = value.strip().split('\n')
        found_count = 0
        expected_prefix = 1
        for line in lines:
            line = line.strip()
            if not line:
                continue
            prefix = f'{expected_prefix}.'
            if line.startswith(prefix):
                content_after_prefix = line[len(prefix):].strip()
                if content_after_prefix:
                    found_count += 1
                    expected_prefix += 1
                else:
                    return False
        found_numbers = set()
        for line in lines:
            line = line.strip()
            if not line:
                continue
            for i in range(1, 6):
                prefix = f'{i}.'
                if line.startswith(prefix):
                    content_after_prefix = line[len(prefix):].strip()
                    if content_after_prefix:
                        found_numbers.add(i)
                        break
                    else:
                        return False
        if len(found_numbers) != 5:
            return False
        if found_numbers != {1, 2, 3, 4, 5}:
            return False
        expected_number = 1
        for line in lines:
            line = line.strip()
            if not line:
                continue
            prefix = f'{expected_number}.'
            if line.startswith(prefix):
                content_after_prefix = line[len(prefix):].strip()
                if content_after_prefix:
                    expected_number += 1
                else:
                    return False
            elif line:
                return False
        return expected_number == 6



class DataIdx911InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_911')

    def check_following(self, value):
        """Checks if the response lists items using bullet points, implying ingredients are listed as points.
        Args:
            value: A string representing the response (the recipe).

        Returns:
            True if the response contains lines starting with common bullet point characters, False otherwise.
        """
        lines = value.splitlines()
        bullet_chars = ['-', '*', '•']
        for line in lines:
            stripped_line = line.strip()
            if any((stripped_line.startswith(char) for char in bullet_chars)):
                return True
        return False



class DataIdx912InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_912')

    def check_following(self, value):
        """Checks if the response is a single Arabic interrogative sentence,
           starting with 'ما' and ending with '؟'.
           Assumes a single sentence is indicated by a single question mark.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        starts_with_ma = cleaned_value.startswith('ما')
        ends_with_question_mark = cleaned_value.endswith('؟')
        single_question_mark = cleaned_value.count('؟') == 1
        return starts_with_ma and ends_with_question_mark and single_question_mark



class DataIdx913InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_913')

    def arabic_to_english_digits(self, text):
        """Converts Arabic digits in a string to English digits."""
        arabic_map = {'٠': '0', '١': '1', '٢': '2', '٣': '3', '٤': '4', '٥': '5', '٦': '6', '٧': '7', '٨': '8', '٩': '9'}
        return ''.join((arabic_map.get(char, char) for char in text))

    def check_following(self, value):
        """
        Checks if the response provides instructions in exactly 4 steps,
        numbered 1 through 4 using standard numbering formats (N. or N)).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        if not lines or (len(lines) == 1 and lines[0].strip() == ''):
            return False
        step_line_count = 0
        found_step_numbers = set()
        step_pattern = re.compile('^([1-9]|[١-٩])[.\\)]\\s*')
        for line in lines:
            stripped_line = line.strip()
            if not stripped_line:
                continue
            match = step_pattern.match(stripped_line)
            if match:
                step_line_count += 1
                number_str = match.group(1)
                english_number_str = self.arabic_to_english_digits(number_str)
                try:
                    step_number = int(english_number_str)
                    if 1 <= step_number <= 4:
                        found_step_numbers.add(step_number)
                except ValueError:
                    pass
        return step_line_count == 4 and found_step_numbers == {1, 2, 3, 4}



class DataIdx914InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_914')

    def check_following(self, value):
        """Checks if the response contains the word 'ظل' at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains 'ظل', False otherwise.
        """
        return 'ظل' in value



class DataIdx915InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_915')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 915.
        The response must be enclosed in square brackets, contain 'فوز' at least twice,
        and 'مباراة' at least twice.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or len(value) < 2:
            return False
        if not (value.startswith('[') and value.endswith(']')):
            return False
        content = value[1:-1]
        win_count = content.count('فوز')
        match_count = content.count('مباراة')
        if win_count < 2 or match_count < 2:
            return False
        return True



class DataIdx916InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_916')

    def check_following(self, value):
        """Checks if the response follows the instructions for question IDX 916.
        Constraints checked:
        1. Must not use semicolons.
        2. Must contain at least some Arabic characters (as a proxy for being in Arabic).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the checkable instructions, False otherwise.
        """
        if ';' in value:
            return False
        arabic_present = any(('\u0600' <= char <= 'ۿ' for char in value))
        if not arabic_present:
            return False
        return True



class DataIdx917InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_917')

    def check_following(self, value):
        """Checks if the response lists exactly three personal goals, each starting with a present tense verb."""
        lines = value.strip().split('\n')
        points = []
        for line in lines:
            cleaned_line = line.strip()
            if not cleaned_line:
                continue
            cleaned_line = re.sub('^[\\*\\-]\\s*', '', cleaned_line)
            cleaned_line = re.sub('^\\d+[\\.\\)]\\s*', '', cleaned_line)
            points.append(cleaned_line)
        if len(points) != 3:
            return False
        present_tense_prefixes = ('ي', 'ت', 'أ', 'ن')
        for point in points:
            words = point.split()
            if not words:
                return False
            first_word = words[0]
            is_present_verb_like = False
            for prefix in present_tense_prefixes:
                if first_word.startswith(prefix) and len(first_word) > len(prefix):
                    is_present_verb_like = True
                    break
                if prefix == 'أ':
                    if first_word.startswith(('أ', 'إ', 'آ')) and len(first_word) > 1:
                        if first_word.startswith('أ') and len(first_word) > 1:
                            is_present_verb_like = True
                            break
            if not is_present_verb_like:
                return False
        return True



class DataIdx918InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_918')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        forbidden_punctuation = set('!"#$%&\'()*+-/:;<=>?@[\\]^_`{|}~')
        for char in value:
            if char in forbidden_punctuation:
                return False
        return True



class DataIdx919InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('919')

    def check_following(self, value):
        """Checks if the response follows the constraints for question 919.
        Constraints:
        1. Mentions exactly three items.
        2. In an unordered list format (- or * followed by space).
        3. Not in a numbered list format (digit. followed by space).
        4. Order is not strictly checked as per the prompt's "approximately".

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.splitlines()
        processed_lines = [line.strip() for line in lines if line.strip()]
        if len(processed_lines) != 3:
            return False
        for line in processed_lines:
            stripped_line = line.lstrip()
            if re.match('^\\d+\\.\\s+', stripped_line):
                return False
            if not (stripped_line.startswith('- ') or stripped_line.startswith('* ')):
                return False
        return True



class DataIdx920InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_920')

    def check_following(self, value):
        """Checks if the response is a paragraph with at least 85 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (at least 85 words), 
            or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return word_count >= 85



class DataIdx921InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_921')

    def check_following(self, value):
        """Checks if the response contains three distinct questions starting with 'لماذا', assuming questions are on separate lines.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        found_questions = []
        start_word = 'لماذا'
        end_punct = '؟'
        for line in lines:
            clean_line = line.strip()
            if clean_line.startswith(start_word) and clean_line.endswith(end_punct):
                found_questions.append(clean_line)
        if len(found_questions) != 3:
            return False
        if len(set(found_questions)) != 3:
            return False
        return True



class DataIdx922InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_922')

    def check_following(self, value):
        """Checks if the response lists 5 items as bullet points and has a total word count under 30.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = [line.strip() for line in value.strip().split('\n') if line.strip()]
        if len(lines) != 5:
            return False
        bullet_markers = ('*', '-', '•')
        for line in lines:
            if not line.startswith(bullet_markers):
                return False
            marker_end_index = 0
            for i, char in enumerate(line):
                if char in bullet_markers:
                    marker_end_index = i + 1
                else:
                    break
            content_found = False
            for i in range(marker_end_index, len(line)):
                if not line[i].isspace():
                    content_found = True
                    break
            if not content_found:
                return False
        bullet_point_format_ok = True
        words = value.split()
        total_word_count = len(words)
        word_count_ok = total_word_count < 30
        return bullet_point_format_ok and word_count_ok



class DataIdx923InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_923')

    def check_following(self, value):
        """Checks if the response is three sentences about a favorite city without using commas.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if ',' in value:
            return False
        sentences = re.split('[.!?\\n]', value)
        non_empty_segments = [s.strip() for s in sentences if s.strip()]
        return len(non_empty_segments) == 3



class DataIdx924InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_924')

    def check_following(self, value):
        """Checks if the response avoids using the word 'جميلة'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain the word 'جميلة', False otherwise.
        """
        if 'جميلة' in value:
            return False
        return True



class DataIdx925InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_925')

    def check_following(self, value):
        """Checks if the response follows the instruction constraints.

        Args:
            value: A string representing the response (tweet).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        max_length = 280
        required_hashtag = '#تخفيضات_الموضة'
        length_constraint = len(value) <= max_length
        hashtag_constraint = required_hashtag in value
        return length_constraint and hashtag_constraint



class DataIdx926InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_926')

    def check_following(self, value):
        """
        Checks if the response is a single sentence ending in a rhetorical question about time importance in Arabic.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not value:
            return False
        trimmed_value = value.strip()
        if not trimmed_value:
            return False
        if not trimmed_value.endswith('?'):
            return False
        if 'الوقت' not in trimmed_value:
            return False
        if len(trimmed_value) < 2:
            return False
        for char in trimmed_value[:-1]:
            if char in ['.', '!', '?']:
                return False
        return True



class DataIdx927InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_927')

    def check_following(self, value):
        """Checks if the response string contains no repeated words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (no repeated words), False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        if not words:
            return True
        unique_words = set(words)
        return len(words) == len(unique_words)



class DataIdx928InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_928')

    def check_following(self, value):
        """Checks if the response is a short story in exactly two paragraphs
           and does not contain any Arabic commas (،).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        text = value.strip()
        lines = text.splitlines()
        paragraph_count = 0
        in_paragraph = False
        for line in lines:
            if line.strip():
                if not in_paragraph:
                    paragraph_count += 1
                    in_paragraph = True
            else:
                in_paragraph = False
        is_two_paragraphs = paragraph_count == 2
        no_arabic_comma = '،' not in value
        return is_two_paragraphs and no_arabic_comma



class DataIdx929InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_929')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 929.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not value or not isinstance(value, str) or (not value.strip()):
            return False
        lines = value.splitlines()
        suggestions = [line.strip() for line in lines if line.strip()]
        if len(suggestions) != 3:
            return False
        imperative_verbs = {'ازرعوا', 'قللوا', 'حافظوا', 'نظفوا', 'شاركوا', 'استخدموا', 'وفروا', 'أعيدوا', 'ابتعدوا', 'احموا', 'حسنوا', 'انشروا', 'قلّلوا', 'اهتموا', 'نظّموا', 'شجّعوا', 'امنعوا', 'قلّلوا'}
        required_word = 'البيئة'
        marker_pattern = re.compile('^\\s*[-*]?\\s*\\d*[.)]?\\s*')
        for suggestion in suggestions:
            if required_word not in suggestion:
                return False
            cleaned_suggestion = marker_pattern.sub('', suggestion)
            words = cleaned_suggestion.split()
            words = [word for word in words if word]
            if not words:
                return False
            first_word = words[0]
            if first_word not in imperative_verbs:
                return False
        return True



class DataIdx930InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_930')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 930.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if 'ثقة' not in value:
            return False
        points = value.split(';;;')
        if len(points) != 6:
            return False
        required_verbs = ['استعد', 'كن', 'ارتد', 'أجب', 'اطرح', 'اشكر']
        for i in range(6):
            point = points[i].strip()
            expected_start = f'{i + 1}.'
            if not point.startswith(expected_start):
                return False
            dot_pos = point.find('.')
            if dot_pos == -1:
                return False
            text_after_numbering = point[dot_pos + 1:].strip()
            required_verb = required_verbs[i]
            if not text_after_numbering.startswith(required_verb):
                return False
        return True



class DataIdx931InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_931')

    def check_following(self, value: str) -> bool:
        """
        Checks if the response correctly classifies Arabic words into nouns, verbs, and particles.

        Args:
            value: A string representing the student's response.

        Returns:
            True if the classification is correct, False otherwise.
        """
        correct_nouns = {'كتاب', 'قلم'}
        correct_verbs = {'يقرأ', 'كتب'}
        correct_particles = {'في', 'على'}
        category_pattern = re.compile('(ال?أسماء|ال?أفعال|ال?حروف)[\\s:]*(.*?)(?=ال?أسماء|ال?أفعال|ال?حروف|$)', re.S)
        matches = category_pattern.findall(value)
        extracted_nouns = set()
        extracted_verbs = set()
        extracted_particles = set()
        found_categories = set()
        for category_label, content in matches:
            normalized_label = category_label.replace('ال', '')
            found_categories.add(normalized_label)
            words = re.split('[,\\s.;]+', content)
            for word in words:
                cleaned_word = word.strip()
                if cleaned_word:
                    if normalized_label == 'أسماء':
                        extracted_nouns.add(cleaned_word)
                    elif normalized_label == 'أفعال':
                        extracted_verbs.add(cleaned_word)
                    elif normalized_label == 'حروف':
                        extracted_particles.add(cleaned_word)
        if not all((cat in found_categories for cat in ['أسماء', 'أفعال', 'حروف'])):
            return False
        is_nouns_correct = extracted_nouns == correct_nouns
        is_verbs_correct = extracted_verbs == correct_verbs
        is_particles_correct = extracted_particles == correct_particles
        return is_nouns_correct and is_verbs_correct and is_particles_correct



class DataIdx932InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_932')

    def check_following(self, value):
        """Checks if the response is a single sentence with exactly seven words.
        Only the structural constraint (exactly seven words) is programmatically checked,
        as checking if it's a 'single sentence' or 'about weather' reliably without
        advanced NLP or context is beyond the scope of simple string manipulation.

        Args:
            value: A string representing the response.

        Returns:
            True if the response has exactly 7 words, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        return len(words) == 7



class DataIdx933InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_933')

    def check_following(self, value):
        """Checks if the response is a formal email of at least 70 words
           to a university professor asking about office hours,
           with the subject including 'استفسار عن الساعات المكتبية'.

        Args:
            value: A string representing the response (the email text).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        lines = value.splitlines()
        subject = None
        required_subject_phrase = 'استفسار عن الساعات المكتبية'
        for line in lines:
            lower_line = line.lower()
            if lower_line.startswith('subject:'):
                subject = line[len('subject:'):].strip()
                break
            elif line.startswith('الموضوع:'):
                subject = line[len('الموضوع:'):].strip()
                break
        if subject is None:
            for line in lines:
                if line.strip():
                    subject = line.strip()
                    break
        subject_constraint_met = False
        if subject:
            subject_constraint_met = required_subject_phrase in subject
        words = value.split()
        word_count = len(words)
        word_count_constraint_met = word_count >= 70
        return subject_constraint_met and word_count_constraint_met



class DataIdx934InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_934')

    def check_following(self, value):
        """Checks if the response is a non-empty string containing Arabic characters and at least one space.
           This function serves as a basic check for an attempt at an Arabic sentence, but it does NOT
           programmatically verify if the sentence actually contains a metaphor, as that requires
           advanced semantic analysis beyond the scope of simple string checks.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is a non-empty string, contains Arabic characters, and has at least one space;
            False otherwise. This indicates a minimal valid attempt at an Arabic sentence.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        cleaned_value = value.strip()
        contains_arabic = any(('\u0600' <= c <= 'ۿ' for c in cleaned_value))
        if not contains_arabic:
            return False
        contains_space = ' ' in cleaned_value
        if not contains_space:
            return False
        return True



class DataIdx935InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_935')

    def check_following(self, value):
        """Checks if the response is a single sentence using the simple future tense (heuristically)."""
        stripped_value = value.strip()
        if not stripped_value:
            return False
        sentence_enders = ['.', '!', '?']
        punc_count = sum((stripped_value.count(end) for end in sentence_enders))
        if punc_count != 1:
            return False
        if stripped_value[-1] not in sentence_enders:
            return False
        future_indicator_present = 'س' in stripped_value or 'سوف' in stripped_value
        return future_indicator_present



class DataIdx936InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_936')

    def check_following(self, value):
        """Checks if the response (a proposed question) starts with 'لماذا' and has more than 10 words.
        Args:
            value: A string representing the response (the student's proposed question).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        starts_with_لماذا = value.strip().startswith('لماذا')
        words = value.split()
        word_count = len(words)
        more_than_ten_words = word_count > 10
        return starts_with_لماذا and more_than_ten_words



class DataIdx937InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_937')

    def check_following(self, value):
        """Checks if the response avoids using common Arabic abbreviations.
        The instruction is "تجنب استخدام الاختصارات" (avoid using abbreviations).
        This check looks for common written Arabic abbreviations,
        especially those involving dots (like titles) or well-known initialisms/shortenings.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (avoids common abbreviations) or False otherwise.
        """
        abbreviations_patterns = ['د\\.', 'م\\.', 'أ\\.', 'إلخ\\.', 'ق\\.م\\.', 'م\\.', 'و\\.م\\.ح\\.', 'صلعم', 'ﷺ']
        combined_pattern = '|'.join(abbreviations_patterns)
        if re.search(combined_pattern, value):
            return False
        else:
            return True



class DataIdx938InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_938')

    def check_following(self, value):
        """
        Checks if the response contains keywords related to common animals starting with 'أ'.
        This is a heuristic check for the constraint "animal starts with 'أ'".
        It does not verify if the response is actually a riddle or about the animal.
        Args:
            value: A string representing the response.

        Returns:
            True if the response likely relates to an 'أ' animal based on keywords, False otherwise.
        """
        if not isinstance(value, str):
            return False
        if not value.strip():
            return False
        target_animals = ['أسد', 'أرنب', 'أفعى', 'إبل', 'أخطبوط', 'إوز', 'أيّل']
        for animal in target_animals:
            if animal in value:
                return True
        return False



class DataIdx939InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_939')

    def check_following(self, value):
        """Checks if the response contains the required Arabic words.
        Args:
            value: A string representing the response.

        Returns:
            True if the response contains 'التسامح' and 'التفاهم', False otherwise.
        """
        required_word1 = 'التسامح'
        required_word2 = 'التفاهم'
        contains_word1 = required_word1 in value
        contains_word2 = required_word2 in value
        return contains_word1 and contains_word2



class DataIdx940InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_940')

    def check_following(self, value):
        """Checks if the response is exactly one word.

        Args:
            value: A string representing the response.

        Returns:
            True if the response consists of exactly one word, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.strip().split()
        return len(words) == 1



class DataIdx941InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_941')

    def check_following(self, value):
        """Checks if the response is a three-sentence advertisement starting with 'نقدم لكم بكل فخر'.
        Constraints:
        1. Consists of exactly three sentences.
        2. Starts with the phrase 'نقدم لكم بكل فخر'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instructions or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        starts_correctly = cleaned_value.startswith('نقدم لكم بكل فخر')
        if not starts_correctly:
            return False
        sentences = re.split('[.?!؟!]', cleaned_value)
        non_empty_sentences = [s for s in sentences if s.strip()]
        is_three_sentences = len(non_empty_sentences) == 3
        return is_three_sentences



class DataIdx942InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_942')

    def check_following(self, value):
        """Checks if the response about AI opinion is written in an informal style.
        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response appears informal or not overly formal, False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        formal_indicators = ['تعلم الآلة', 'شبكات عصبية', 'خوارزميات', 'تحليل البيانات', 'نماذج تعلم', 'أنظمة ذكاء اصطناعي', 'معالجة اللغات الطبيعية', 'بالإضافة إلى ذلك', 'علاوة على ذلك', 'وبالتالي', 'نتيجة لذلك', 'على الرغم من ذلك', 'من ناحية أخرى', 'بحث علمي', 'دراسة معمقة', 'منهجية البحث', 'تحليل معمق', 'تطوير أنظمة معقدة', 'نماذج إحصائية', 'بيانات ضخمة', 'محاكاة حاسوبية', 'نظام معقد', 'بصرف النظر عن', 'على صعيد آخر', 'في سياق متصل', 'يهدف إلى', 'يعتبر من أهم', 'يرتكز على', 'جانب نظري', 'جانب عملي', 'تحديات كبيرة', 'فرص واعدة', 'الجدير بالذكر', 'مما لا شك فيه', 'من وجهة نظر', 'في هذا الصدد', 'وفقا لـ', 'حسبما ذكر', 'العوامل المؤثرة', 'التداعيات السلبية', 'الآثار الإيجابية', 'حلول مبتكرة', 'رؤية مستقبلية', 'نطاق واسع', 'بشكل فعال', 'بشكل منهجي', 'تبعا لـ', 'فضلا عن', 'إلى جانب ذلك', 'بصفة عامة', 'بصفة خاصة', 'في المقام الأول', 'في المقام الثاني', 'على سبيل المثال لا الحصر', 'مما يؤدي إلى']
        formal_count = 0
        text_to_check = value.lower()
        for indicator in formal_indicators:
            formal_count += text_to_check.count(indicator.lower())
        formal_threshold = 2
        if formal_count > formal_threshold:
            return False
        return True



class DataIdx943InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_943')

    def check_following(self, value):
        """Checks if the response contains at least three potential indicators of metaphors.
        This is a heuristic check looking for specific words often used in metaphors about places.
        It is not a perfect metaphor detector and may misinterpret literal language or miss
        metaphors that do not use these specific words.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response contains at least three potential metaphor indicators, False otherwise.
        """
        metaphorical_indicators = ['قلب', 'القلب', 'روح', 'الروح', 'كنز', 'الكنز', 'كنوز', 'الكنوز', 'جوهرة', 'الجوهرة', 'جواهر', 'الجواهر', 'شاهد', 'الشاهد', 'شهود', 'الشهود', 'كتاب', 'الكتاب', 'كتب', 'الكتب', 'لسان', 'اللسان', 'ألسنة', 'الألسنة', 'عرق', 'العرق', 'عروق', 'العروق', 'نفس', 'النفس', 'أنفاس', 'الأنفاس', 'قصة', 'القصة', 'قصص', 'القصص', 'حكاية', 'الحكاية', 'حكايات', 'الحكايات', 'تروي', 'يروي', 'تتحدث', 'يتحدث', 'تشهد', 'يشهد', 'تتنفس', 'يتنفس', 'تحكي', 'يحكي']
        cleaned_value = value
        punctuation = '.,;!?:؟'
        for p in punctuation:
            cleaned_value = cleaned_value.replace(p, ' ')
        while '  ' in cleaned_value:
            cleaned_value = cleaned_value.replace('  ', ' ')
        cleaned_value = cleaned_value.strip()
        words = cleaned_value.split()
        metaphor_count = 0
        for word in words:
            if word in metaphorical_indicators:
                metaphor_count += 1
        return metaphor_count >= 3



class DataIdx944InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_944')

    def check_following(self, value):
        value = value.strip()
        if not value:
            return False
        sentence_terminators = '.؟!؟'
        sentence_end_pattern = re.compile(f'[{re.escape(sentence_terminators)}]')
        sentences = []
        last_end = 0
        for match in sentence_end_pattern.finditer(value):
            start, end = match.span()
            segment = value[last_end:end].strip()
            if segment:
                sentences.append(segment)
            last_end = end
        if last_end < len(value):
            return False
        if len(sentences) != 2:
            return False
        sentence1 = sentences[0]
        sentence2 = sentences[1]
        if not sentence1.endswith('؟') or not sentence2.endswith('؟'):
            return False
        weather_keywords = ['طقس', 'جو', 'عاملة إزاي', 'كيف', 'حالة', 'النهارده']
        found_keyword_s1 = any((keyword in sentence1 for keyword in weather_keywords))
        found_keyword_s2 = any((keyword in sentence2 for keyword in weather_keywords))
        if not found_keyword_s1 or not found_keyword_s2:
            return False
        return True



class DataIdx945InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_945')

    def check_following(self, value):
        """Checks if the response contains exactly 3 sentences by counting terminal punctuation.
        Args:
            value: A string representing the response.

        Returns:
            True if the response contains exactly 3 terminal punctuation marks (. ! ?), False otherwise.
        """
        terminator_count = value.count('.') + value.count('!') + value.count('?')
        return terminator_count == 3



class DataIdx946InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_946')

    def check_following(self, value):
        """
        Checks if the response follows the instructions for IDX 946.
        Instructions: Write one sentence that includes a number written in Arabic letters
        representing the number of days in the week.

        Constraints interpretation for automatic checking:
        1. The response must contain the Arabic word "سبعة" (seven).
        2. The response should appear to be a single sentence. This is approximated by
           checking the count of sentence-ending punctuation marks (., !, ?).
        3. The semantic constraint "representing the number of days in the week" is not
           automatically checkable without advanced NLP.

        Args:
            value: A string representing the response.

        Returns:
            True if the response meets the automatic checks (contains "سبعة" and
            appears to be a single sentence), False otherwise.
        """
        if not isinstance(value, str):
            return False
        normalized_value = value.strip()
        required_word = 'سبعة'
        word_present = required_word in normalized_value
        terminators = ['.', '!', '?']
        terminator_count = sum((normalized_value.count(term) for term in terminators))
        is_single_sentence = terminator_count <= 1
        if not normalized_value:
            return False
        return word_present and is_single_sentence



class DataIdx947InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_947')

    def check_following(self, value):
        """Checks if the response ends with exactly three question marks.
        Args:
            value: A string representing the response.

        Returns:
            True if the response ends with ???, False otherwise.
        """
        if not isinstance(value, str):
            return False
        return value.endswith('???')



class DataIdx948InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_948')

    def check_following(self, value):
        """Checks if the response follows the instruction not to use the word 'قط'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain the word 'قط', False otherwise.
        """
        forbidden_word = 'قط'
        return forbidden_word not in value



class DataIdx949InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_949')

    def check_following(self, value):
        """Checks if the response is a short congratulatory message in Arabic for a friend graduating,
           including the word 'مبروك' and not using any interrogative sentences.
           It skips the check for the friend's name as it is not reliably implementable without further context.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the constraints (includes 'مبروك' and no '?'),
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        contains_mabrouk = 'مبروك' in value
        contains_question_mark = '?' in value
        return contains_mabrouk and (not contains_question_mark)



class DataIdx950InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_950')

    def check_following(self, value):
        """Checks if the response defines "القصة القصيرة" in one paragraph and includes "مكثفة".

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        contains_mokathafa = 'مكثفة' in value
        is_single_paragraph = '\n\n' not in value.strip()
        return contains_mokathafa and is_single_paragraph



class DataIdx951InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_951')

    def check_following(self, value):
        """Checks if the response (a lullaby) uses the word 'نوم' at least four times.
        Args:
            value: A string representing the response.

        Returns:
            True if the word 'نوم' appears at least 4 times, False otherwise.
        """
        keyword = 'نوم'
        count = value.count(keyword)
        return count >= 4



class DataIdx952InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_952')

    def check_following(self, value):
        """Checks if the response is a list of 5 points, each starting with 'أنا أستطيع'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = [line.strip() for line in value.split('\n') if line.strip()]
        if len(lines) != 5:
            return False
        required_start = 'أنا أستطيع'
        for line in lines:
            if not line.startswith(required_start):
                return False
        return True



class DataIdx953InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_953')

    def check_following(self, value):
        """Checks if the response (Arabic message) follows the constraint of not exceeding 75 words.

        Args:
            value: A string representing the response (the Arabic message).

        Returns:
            True if the number of words in the response is 75 or less, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return word_count <= 75



class DataIdx954InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_954')

    def check_following(self, value):
        """Checks if the response describes a sunset scene in less than five words without using verbs (using a simple heuristic).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instructions, False otherwise.
        """
        if not isinstance(value, str):
            return False
        arabic_punctuation = '،؛:.!؟'
        all_punctuation = string.punctuation + arabic_punctuation
        cleaned_value = value
        for p in all_punctuation:
            cleaned_value = cleaned_value.replace(p, '')
        cleaned_value = re.sub('\\s+', ' ', cleaned_value).strip()
        if not cleaned_value:
            return False
        words = cleaned_value.split()
        if len(words) >= 5:
            return False
        forbidden_items = ['كان', 'يكون', 'صار', 'يصير', 'ليس', 'لم', 'لن', 'قد', 'سوف']
        for word in words:
            if word in forbidden_items:
                return False
        return True



class DataIdx955InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_955')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 955.
        Instructions:
        - Write a short response of two words.
        - Do not use the word 'بخير'.
        - Use the Damma (ُ) diacritic on the last word (interpreted as the response ending with 'ُ').

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        words = cleaned_value.split()
        if len(words) != 2:
            return False
        if 'بخير' in cleaned_value:
            return False
        damma_char = 'ُ'
        if not cleaned_value.endswith(damma_char):
            return False
        return True



class DataIdx956InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_956')

    def check_following(self, value):
        """Checks if the response is a single Arabic declarative sentence ending with a period.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not value.endswith('.'):
            return False
        has_arabic_chars = False
        for char in value:
            if '\u0600' <= char <= 'ۿ':
                has_arabic_chars = True
                break
        if not has_arabic_chars:
            return False
        text_without_last_char = value[:-1]
        for char in text_without_last_char:
            if char in ['.', '?', '!']:
                return False
        return True



class DataIdx957InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_957')

    def check_following(self, value):
        """Checks if the response is a single paragraph.

        A single paragraph is defined as text not containing a blank line
        (two or more consecutive newline characters).

        Args:
            value: A string representing the response.

        Returns:
            True if the response is a single paragraph, False otherwise.
        """
        cleaned_value = value.strip()
        if '\n\n' in cleaned_value:
            return False
        normalized_value = cleaned_value.replace('\r\n', '\n')
        if '\n\n' in normalized_value:
            return False
        if not cleaned_value:
            return False
        return '\n\n' not in normalized_value



class DataIdx958InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_958')

    def check_following(self, value):
        """Checks if the response is a short dialogue between two people about weekend plans in Arabic."""
        if not isinstance(value, str):
            return False
        text = value.strip()
        arabic_pattern = re.compile('[\\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF\\uFB50-\\uFDFF\\uFE70-\\uFEFF]')
        if not arabic_pattern.search(text):
            return False
        lines = text.split('\n')
        non_empty_lines = [line.strip() for line in lines if line.strip()]
        if len(non_empty_lines) < 4:
            return False
        words = text.split()
        word_count = len(words)
        if not 50 <= word_count <= 200:
            return False
        keywords = ['نهاية الأسبوع', 'عطلة', 'خطط', 'ماذا ستفعل', 'نذهب', 'نزور', 'سنقوم بـ', 'الجمعة', 'السبت', 'الأحد', 'عطلة نهاية الأسبوع']
        text_lower = text.lower()
        found_keyword = False
        for keyword in keywords:
            if keyword in text_lower:
                found_keyword = True
                break
        if not found_keyword:
            return False
        return True



class DataIdx959InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_959')

    def check_following(self, value):
        """Checks if the response is a sentence with exactly seven words in Arabic.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        return len(words) == 7



class DataIdx960InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_960')

    def check_following(self, value):
        """Checks if the response contains a list of exactly five items.
        Assumes list items are separated by newlines.

        Args:
            value: A string representing the response.

        Returns:
            True if the response consists of exactly 5 non-empty lines, False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.split('\n')
        non_empty_lines = [line for line in lines if line.strip()]
        return len(non_empty_lines) == 5



class DataIdx961InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_961')

    def check_following(self, value):
        """Checks if the response is a paragraph of at least six sentences and contains 'الثقافات' at least twice.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentence_parts = re.split('[.!?]+', value)
        sentences = [part.strip() for part in sentence_parts if part.strip()]
        num_sentences = len(sentences)
        sentence_condition_met = num_sentences >= 6
        word_count = value.count('الثقافات')
        word_condition_met = word_count >= 2
        return sentence_condition_met and word_condition_met



class DataIdx962InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_962')

    def check_following(self, value):
        """Checks if the response mentions the word 'النيل' exactly three times.

        Args:
            value: A string representing the response (paragraph about Cairo).

        Returns:
            True if the word 'النيل' appears exactly 3 times, False otherwise.
        """
        nile_count = value.count('النيل')
        return nile_count == 3



class DataIdx963InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_963')

    def check_following(self, value):
        """Checks if the response lists exactly 7 unique items in a numbered list format.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        pattern = '^\\s*\\d+[\\.\\)]?\\s*(.*)$'
        matches = re.findall(pattern, value, re.MULTILINE)
        items = [item.strip() for item in matches if item.strip()]
        if len(items) != 7:
            return False
        if len(set(items)) != 7:
            return False
        return True



class DataIdx964InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_964')

    def check_following(self, value):
        """Checks if the response describes the favorite day in fewer than five words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response has fewer than five words, False otherwise.
        """
        words = value.split()
        return len(words) < 5



class DataIdx965InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_965')

    def check_following(self, value):
        """Checks if the response is a numbered list of three reasons in Arabic
        using numbers 1, 2, 3 (١, ٢, ٣), where each point is a sentence,
        and the second point includes the word 'المعرفة'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        points = {}
        lines = value.strip().split('\n')
        found_numbers = set()
        arabic_numerals = {'١', '٢', '٣'}
        punctuation = '.?!'
        for line in lines:
            line = line.strip()
            if line.startswith('١.'):
                points['١'] = line[len('١.'):].strip()
                found_numbers.add('١')
            elif line.startswith('٢.'):
                points['٢'] = line[len('٢.'):].strip()
                found_numbers.add('٢')
            elif line.startswith('٣.'):
                points['٣'] = line[len('٣.'):].strip()
                found_numbers.add('٣')
        if found_numbers != arabic_numerals:
            return False
        if 'المعرفة' not in points['٢']:
            return False
        for num in ['١', '٢', '٣']:
            if num not in points or not points[num] or (not points[num].endswith(tuple(punctuation))):
                return False
        return True



class DataIdx966InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_966')

    def check_following(self, value):
        """Checks if the response lists three items with bold titles using markdown **.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.strip().splitlines()
        list_items = [line for line in lines if line.strip()]
        if len(list_items) != 3:
            return False
        bold_pattern = re.compile('\\*\\*(.+?)\\*\\*')
        for item in list_items:
            if not bold_pattern.search(item):
                return False
        return True



class DataIdx967InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_967')

    def check_following(self, value):
        """Checks if the response is a list of tips for maintaining mental health
        that includes specific words and has at least five points.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        required_words = ['صحة نفسية', 'نصائح', 'توازن', 'تواصل', 'رياضة']
        words_present = all((word in value for word in required_words))
        if not words_present:
            return False
        points = value.strip().split('\n')
        valid_points = [p for p in points if p.strip()]
        if len(valid_points) < 5:
            return False
        return True



class DataIdx968InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_968')

    def check_following(self, value):
        """Checks if the response is a single Arabic sentence containing a preposition
           followed by a definite noun using 'ال'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        value = value.strip()
        terminal_punc = {'.', '!', '?'}
        punc_count = sum((value.count(p) for p in terminal_punc))
        if punc_count != 1:
            return False
        last_char_index = len(value) - 1
        while last_char_index >= 0 and value[last_char_index].isspace():
            last_char_index -= 1
        if last_char_index < 0 or value[last_char_index] not in terminal_punc:
            return False
        if punc_count == 1:
            found_first = False
            for i in range(len(value)):
                if value[i] in terminal_punc:
                    if not found_first:
                        found_first = True
                        if i != last_char_index:
                            return False
                    elif i != last_char_index:
                        return False
        standalone_preps = {'من', 'إلى', 'عن', 'على', 'في', 'رب', 'مذ', 'منذ', 'حتى', 'خلا', 'عدا', 'حاشا'}
        attached_prefixes = {'ب', 'ك', 'ل'}
        words = value.split()
        found_pattern = False
        for i in range(len(words)):
            current_word_clean = words[i].rstrip('.,!?"\'')
            if current_word_clean in standalone_preps and i + 1 < len(words):
                next_word_clean = words[i + 1].rstrip('.,!?"\'')
                if next_word_clean.startswith('ال'):
                    found_pattern = True
                    break
            if any((current_word_clean.startswith(p + 'ال') for p in attached_prefixes)):
                found_pattern = True
                break
        if not found_pattern:
            return False
        return True



class DataIdx969InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_969')

    def check_following(self, value):
        """Checks if the response is a formal letter in Arabic with appropriate opening and closing greetings."""
        if not isinstance(value, str) or not value.strip():
            return False
        opening_keywords = ['تحية طيبة وبعد', 'السادة الكرام', 'إلى من يهمه الأمر', 'السلام عليكم ورحمة الله وبركاته', 'المحترمين', 'بسم الله الرحمن الرحيم', 'إلى السيد المحترم', 'السيد الفاضل', 'سعادة المدير المحترم', 'حضرة', 'إلى السيد المحترم / السيدة المحترمة']
        closing_keywords = ['وتفضلوا بقبول فائق الاحترام', 'مع خالص الشكر والتقدير', 'خالص التحيات', 'والسلام عليكم ورحمة الله وبركاته', 'مع فائق الاحترام', 'شاكرين ومقدرين', 'المرسل', 'التوقيع', 'الاسم:', 'التاريخ:', 'تفضلوا بقبول وافر الشكر والتقدير', 'لكم جزيل الشكر', 'تفضلوا بقبول الاحترام', 'مع خالص الاحترام والتقدير', 'المرفقات', 'نسخة إلى:']

        def normalize_whitespace(text):
            text = re.sub('\\s+', ' ', text).strip()
            return text
        normalized_value = normalize_whitespace(value)
        has_opening = any((re.search(re.escape(normalize_whitespace(keyword)), normalized_value, re.IGNORECASE) for keyword in opening_keywords))
        has_closing = any((re.search(re.escape(normalize_whitespace(keyword)), normalized_value, re.IGNORECASE) for keyword in closing_keywords))
        return has_opening and has_closing



class DataIdx970InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_970')

    def check_following(self, value):
        """Checks if the response ends with the exact phrase 'وهكذا بدأت الحكاية.'.
        Args:
            value: A string representing the response (the story).

        Returns:
            True if the response ends with the specified phrase, False otherwise.
        """
        required_ending = 'وهكذا بدأت الحكاية.'
        return value.strip().endswith(required_ending)



class DataIdx971InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_971')

    def check_following(self, value):
        """
        Checks if the response is a single Arabic sentence containing a mudaf vocative introduced by 'يا'.
        Heuristic check: presence of 'يا' followed by at least two non-empty, space-separated parts,
        representing the mudaf noun and the mudaf ilaih.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        terminal_punctuation_count = value.count('.') + value.count('!') + value.count('?')
        if terminal_punctuation_count > 1:
            return False
        ya_index = value.find('يا')
        if ya_index == -1:
            return False
        search_start_idx_word1 = ya_index + len('يا')
        if search_start_idx_word1 >= len(value):
            return False
        idx_word1_start = -1
        for i in range(search_start_idx_word1, len(value)):
            if not value[i].isspace():
                idx_word1_start = i
                break
        if idx_word1_start == -1:
            return False
        search_start_idx_space1 = idx_word1_start + 1
        if search_start_idx_space1 >= len(value):
            return False
        idx_word1_end = value.find(' ', search_start_idx_space1)
        if idx_word1_end == -1:
            return False
        search_start_idx_word2 = idx_word1_end + 1
        if search_start_idx_word2 >= len(value):
            return False
        idx_word2_start = -1
        for i in range(search_start_idx_word2, len(value)):
            if not value[i].isspace():
                idx_word2_start = i
                break
        if idx_word2_start != -1:
            return True
        return False



class DataIdx972InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_972')

    def check_following(self, value):
        """Checks if the response is an exclamation sentence starting with 'يا له من',
           describes a natural landscape (not strictly checked programmatically beyond structure),
           and contains the word 'جميل'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        starts_with_ya_lahu_min = stripped_value.startswith('يا له من')
        contains_jameel = ' جميل' in stripped_value or stripped_value.startswith('جميل') or stripped_value.endswith('جميل') or (stripped_value == 'جميل')
        ends_with_exclamation = stripped_value.endswith('!')
        return starts_with_ya_lahu_min and contains_jameel and ends_with_exclamation



class DataIdx973InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_973')

    def check_following(self, value):
        """Checks if the response avoids using first-person pronouns (أنا, نحن, لي, لنا).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (avoids forbidden pronouns),
            False otherwise.
        """
        forbidden_pronouns = ['أنا', 'نحن', 'لي', 'لنا']
        for pronoun in forbidden_pronouns:
            if pronoun in value:
                return False
        return True



class DataIdx974InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_974')

    def check_following(self, value):
        """Checks if the response is a paragraph between 50 and 60 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the word count constraint (50-60 words),
            False otherwise. Note: This checker only verifies the word count,
            not the content or language style.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        words = [word for word in words if word]
        word_count = len(words)
        return 50 <= word_count <= 60



class DataIdx975InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_975')

    def check_following(self, value):
        """Checks if the response is a single two-line verse about friendship
           without rhyming words (specifically, checks if the last characters
           of the two lines after cleaning are different).
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = [line.strip() for line in value.split('\n')]
        lines = [line for line in lines if line]
        if len(lines) != 2:
            return False
        l1, l2 = lines

        def clean_ending(line):
            line = line.rstrip()
            punctuation_to_remove = '.,!؟،؛:()'
            while line and line[-1] in punctuation_to_remove:
                line = line[:-1].rstrip()
            return line
        cleaned_l1 = clean_ending(l1)
        cleaned_l2 = clean_ending(l2)
        if not cleaned_l1 or not cleaned_l2:
            return False
        last_char_l1 = cleaned_l1[-1]
        last_char_l2 = cleaned_l2[-1]
        if last_char_l1 == last_char_l2:
            return False
        return True



class DataIdx976InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_976')

    def check_following(self, value):
        """Checks if the response is a numbered list containing exactly five items.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is a numbered list with five items, False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        numbered_item_pattern = re.compile('^\\s*\\d+[\\.\\)]\\s*')
        numbered_items_count = 0
        for line in lines:
            cleaned_line = line.strip()
            if numbered_item_pattern.match(cleaned_line):
                numbered_items_count += 1
        return numbered_items_count == 5



class DataIdx977InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_977')

    def check_following(self, value):
        """Checks if the response is a single sentence, has exactly 7 words, and starts with 'ب'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value.startswith('ب'):
            return False
        words = cleaned_value.split()
        if len(words) != 7:
            return False
        return True



class DataIdx978InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_978')

    def check_following(self, value):
        """
        Checks if the response is a single line of Arabic text containing 'ليل' and 'قمر'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction, False otherwise.
        """
        if not isinstance(value, str):
            return False
        has_layl = 'ليل' in value
        has_qamar = 'قمر' in value
        is_single_line = '\n' not in value.rstrip()
        return has_layl and has_qamar and is_single_line



class DataIdx979InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_979')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        if len(words) <= 40:
            return False
        direct_phrases = ['نجحت في', 'حصلت على', 'تم قبولي في', 'فزت ب', 'زواجي', 'خطوبتي', 'مولودي', 'ترقيتي', 'الخبر هو', 'كانت النتيجة', 'أنا نجحت', 'أنا حصلت على', 'أنا قبلت', 'خبر نجاحي', 'خبر قبولي', 'خبر حصولي', 'قبولي في', 'حصولي على', 'نجاحي في', 'نتيجة امتحاني', 'عرض عمل', 'موافقة على', 'أني نجحت', 'أني حصلت', 'خبر حمل', 'خبر ولادة', 'شفائي من', 'فوز فريقي', 'ترقيت في']
        for phrase in direct_phrases:
            if phrase in value:
                return False
        return True



class DataIdx980InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_980')

    def check_following(self, value):
        """Checks if the response is a paragraph about exercise benefits, has at least 4 sentences, and contains 'صحة' and 'نشاط'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        contains_sahha = 'صحة' in value
        contains_nashat = 'نشاط' in value
        sentence_delimiters = ['.', '?', '!', '؟']
        sentence_count = 0
        current_sentence_fragment = ''
        for char in value:
            if char in sentence_delimiters:
                if current_sentence_fragment.strip():
                    sentence_count += 1
                current_sentence_fragment = ''
            else:
                current_sentence_fragment += char
        if current_sentence_fragment.strip():
            sentence_count += 1
        at_least_four_sentences = sentence_count >= 4
        return contains_sahha and contains_nashat and at_least_four_sentences



class DataIdx981InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_981')

    def check_following(self, value):
        """Checks if the response is a non-empty string with at least a minimum number of words,
           as a basic requirement for being considered a riddle.
           Note: This check cannot verify the constraint that the answer to the riddle must be an animal name,
           as only the riddle text is provided.

        Args:
            value: A string representing the riddle written by the student.

        Returns:
            True if the value is a string containing at least 3 words, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        return len(words) >= 3



class DataIdx982InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('982')

    def check_following(self, value):
        """Checks if the response explains "tolerance" in one paragraph,
        not exceeding 60 words, and includes the word "احترام" at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count > 60:
            return False
        if 'احترام' not in value:
            return False
        return True



class DataIdx983InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_983')

    def check_following(self, value):
        """Checks if the response starts with the phrase 'بكل تأكيد'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response starts with 'بكل تأكيد', False otherwise.
        """
        required_start = 'بكل تأكيد'
        if not isinstance(value, str):
            return False
        return value.strip().startswith(required_start)



class DataIdx984InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_984')

    def check_following(self, value):
        """
        Checks if the response lists exactly four items, using common separators
        like comma, newline, and the Arabic conjunction ' و '.
        The check primarily verifies the count of distinct items listed.
        It does NOT verify if the listed items are actually water sports,
        as this requires external knowledge not provided in the question text.

        Args:
            value: A string representing the response.

        Returns:
            True if the response structurally lists exactly four items, False otherwise.
        """
        if not isinstance(value, str):
            return False
        processed_value = value.replace(' و ', '###')
        processed_value = processed_value.replace('\n', '###')
        processed_value = processed_value.replace(',', '###')
        parts = processed_value.split('###')
        items = [item.strip() for item in parts if item.strip()]
        return len(items) == 4



class DataIdx985InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_985')

    def check_following(self, value):
        """Checks if the response lists five names starting with 'م',
        separated by commas.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        items = value.split(',')
        if len(items) != 5:
            return False
        for item in items:
            stripped_item = item.strip()
            if not stripped_item:
                return False
            if not stripped_item.startswith('م'):
                return False
        return True



class DataIdx986InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_986')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 986.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if '\n\n' in value.strip():
            return False
        text = re.sub('\\s+', ' ', value).strip()
        words = re.findall('\\b\\w+\\b', text)
        word_count = len(words)
        if not 90 <= word_count <= 110:
            return False
        ideal_count = len(re.findall('\\b(مثالي|مثالية)\\b', text))
        if ideal_count < 4:
            return False
        pronoun_suffixes = ['ها', 'ك', 'كِ', 'كما', 'كم', 'كن', 'نا', 'هما', 'هم', 'هن', 'تُ', 'تَ', 'تِ', 'تما', 'تم', 'تن', 'وا', 'ون', 'ين', 'نَ', 'ني']
        suffix_pattern = '(' + '|'.join((re.escape(s) for s in pronoun_suffixes)) + ')'
        if re.search('\\b\\w+' + suffix_pattern + '\\b', text):
            return False
        return True



class DataIdx987InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_987')

    def check_following(self, value):
        """Checks if the response contains a numbered list (1-7) of the seven ancient wonders.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        wonders_key_phrases = ['هرم الجيزة', 'حدائق بابل', 'تمثال زيوس', 'معبد أرتميس', 'ضريح موسولوس', 'تمثال رودس', 'منارة الإسكندرية']
        all_wonders_present = all((phrase in value for phrase in wonders_key_phrases))
        if not all_wonders_present:
            return False
        specific_numbered_patterns = [re.compile('^\\s*' + str(i) + '[\\.\\)\\s]', re.M) for i in range(1, 8)]
        all_specific_numbering_present = all((pattern.search(value) for pattern in specific_numbered_patterns))
        return all_wonders_present and all_specific_numbering_present



class DataIdx988InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_988')

    def check_following(self, value):
        """Checks if the response consists of exactly two sentences, and the second sentence starts with 'ولكن'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentences = []
        current_sentence = ''
        for char in value.strip():
            current_sentence += char
            if char in ['.', '!']:
                sentences.append(current_sentence.strip())
                current_sentence = ''
        if current_sentence.strip():
            sentences.append(current_sentence.strip())
        sentences = [s for s in sentences if s]
        if len(sentences) != 2:
            return False
        second_sentence = sentences[1]
        second_sentence_stripped = second_sentence.lstrip()
        if not second_sentence_stripped.startswith('ولكن'):
            return False
        if len(second_sentence_stripped) > len('ولكن') and second_sentence_stripped[len('ولكن')].isspace():
            return True
        elif len(second_sentence_stripped) == len('ولكن'):
            return True
        else:
            return False
        return True







class DataIdx990InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_990')

    def check_following(self, value):
        """Checks if the response is a single sentence containing two antonyms in Arabic.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        response = value.strip()
        sentence_enders = ['.', '!', '؟']
        if not response or response[-1] not in sentence_enders:
            return False
        if any((char in sentence_enders for char in response[:-1])):
            return False
        words = response[:-1].split()
        cleaned_words = [w.strip('.,!؟"\'«»()[]{}') for w in words if w.strip('.,!؟"\'«»()[]{}')]
        if len(cleaned_words) < 2:
            return False
        antonym_pairs = [('كبير', 'صغير'), ('ليل', 'نهار'), ('فوق', 'تحت'), ('سعيد', 'حزين'), ('جميل', 'قبيح'), ('طويل', 'قصير'), ('قريب', 'بعيد'), ('سريع', 'بطيء'), ('صادق', 'كاذب'), ('غني', 'فقير'), ('قوي', 'ضعيف'), ('حار', 'بارد'), ('جائع', 'شبعان'), ('شجاع', 'جبان'), ('مشرق', 'مظلم'), ('جديد', 'قديم'), ('يضحك', 'يبكي'), ('يصعد', 'يهبط'), ('بداية', 'نهاية'), ('نجاح', 'فشل')]
        cleaned_words_set = set(cleaned_words)
        found_antonyms = False
        for word1, word2 in antonym_pairs:
            if word1 in cleaned_words_set and word2 in cleaned_words_set:
                found_antonyms = True
                break
        return found_antonyms



class DataIdx991InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_991')

    def check_following(self, value):
        """Check if the response does not contain exclamation marks.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain any exclamation marks, False otherwise.
        """
        return '!' not in value



class DataIdx992InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_992')

    def check_following(self, value):
        """Checks if the response mentions the capital of Saudi Arabia at least twice.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        target_phrase = 'عاصمة المملكة العربية السعودية'
        count = value.count(target_phrase)
        return count >= 2



class DataIdx993InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_993')

    def check_following(self, value):
        """Checks if the response is a short answer not exceeding 30 words.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (<= 30 words) or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return word_count <= 30



class DataIdx994InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_994')

    def check_following(self, value):
        """Checks if the response meets the criteria:
        - Contains the word "العقل" at least twice.
        - Is at least 60 words long.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instructions or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        min_word_count = 60
        if word_count < min_word_count:
            return False
        keyword_count = value.count('العقل')
        min_keyword_count = 2
        if keyword_count < min_keyword_count:
            return False
        return True



class DataIdx995InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_995')

    def check_following(self, value):
        """Checks if the response has more than 50 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response has more than 50 words, False otherwise.
        """
        words = value.split()
        word_count = len(words)
        return word_count > 50



class DataIdx996InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_996')

    def check_following(self, value):
        """Checks if the response is a list of three items, where each item is a sentence
        starting with "أنا ممتن لـ...".

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        required_start = 'أنا ممتن لـ'
        items = [line.strip() for line in value.strip().splitlines() if line.strip()]
        if len(items) != 3:
            return False
        for item in items:
            if not item.startswith(required_start):
                return False
        return True



class DataIdx997InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_997')

    def check_following(self, value):
        """Checks if the response is a brief description (around 40 words)
           of a historical figure, starting with their name, based on structural constraints.
        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        cleaned_value = re.sub('\\s+', ' ', cleaned_value)
        if not cleaned_value:
            return False
        words = cleaned_value.split()
        word_count = len(words)
        if not 30 <= word_count <= 50:
            return False
        tokens = words
        if not tokens:
            return False
        found_beginning_pattern = False
        check_window_size = min(len(tokens), 6)
        for i in range(check_window_size):
            token = tokens[i]
            if token.endswith('،') or token.endswith(':') or token.endswith('.'):
                if i < len(tokens) - 1:
                    found_beginning_pattern = True
                    break
            if token in ['كان', 'كانت', 'هو', 'هي', 'يعتبر', 'تعتبر', 'يُعتبر', 'تُعتبر']:
                if i < len(tokens) - 1:
                    found_beginning_pattern = True
                    break
            if i + 1 < len(tokens):
                next_token = tokens[i + 1]
                if next_token in ['كان', 'كانت', 'هو', 'هي', 'يعتبر', 'تعتبر', 'يُعتبر', 'تُعتبر']:
                    if i + 2 < len(tokens):
                        found_beginning_pattern = True
                        break
        if not found_beginning_pattern:
            return False
        return True



class DataIdx998InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_998')

    def check_following(self, value):
        """Checks if the response is a single word containing Arabic characters.
        This serves as a basic structural check for providing 'one example'
        in Arabic, as verifying the tense programmatically without an NLP
        library is not feasible.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is a single word containing Arabic characters,
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        if not stripped_value:
            return False
        parts = stripped_value.split()
        if len(parts) != 1:
            return False
        word = parts[0]
        has_arabic_chars = any(('\u0600' <= char <= 'ۿ' for char in word))
        return has_arabic_chars



class DataIdx999InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_999')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.strip().split('\n')
        non_empty_lines = [line.strip() for line in lines if line.strip()]
        if len(non_empty_lines) != 3:
            return False
        forbidden_word = 'البيئة'
        if forbidden_word in value:
            return False
        return True



class DataIdx1000InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1000')

    def check_following(self, value):
        """Checks if the response is a non-empty string containing Arabic characters.
           This serves as a basic check to see if the response is an attempt
           at translating into Arabic script.
           It does NOT check for translation correctness or adherence to
           the specific Egyptian colloquial dialect, as that requires
           advanced NLP capabilities beyond simple string checks.
        Args:
            value: A string representing the response.

        Returns:
            True if the response is a non-empty string with Arabic characters, False otherwise.
        """
        if not isinstance(value, str):
            return False
        trimmed_value = value.strip()
        if not trimmed_value:
            return False
        arabic_char_pattern = re.compile('[\\u0600-\\u06FF]')
        if not arabic_char_pattern.search(trimmed_value):
            return False
        return True



class DataIdx1001InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1001')

    def check_following(self, value):
        """Checks if the response contains the word 'مفتاح' exactly once.

        Args:
            value: A string representing the response (the title).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        occurrences = re.findall('\\bمفتاح\\b', value)
        return len(occurrences) == 1



class DataIdx1002InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1002')

    def check_following(self, value):
        """
        Checks if the response follows the constraints for question 1002.
        Question: من هو أول رائد فضاء عربي صعد إلى الفضاء؟ اذكر اسم الرائد وتاريخ الرحلة بالتحديد. يجب أن تكون الإجابة في أقل من 100 كلمة.
        Constraints:
        1. Mentions the name of the first Arab astronaut (Sultan bin Salman Al Saud or similar).
        2. Mentions the exact date of the trip (June 17, 1985).
        3. Is less than 100 words.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        name_present = 'سلطان بن سلمان' in value or 'سلطان بن سلمان آل سعود' in value
        date_present = '17 يونيو 1985' in value or '١٧ يونيو ١٩٨٥' in value
        words = value.split()
        word_count = len(words)
        word_count_ok = word_count < 100
        return name_present and date_present and word_count_ok



class DataIdx1003InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1003')

    def check_following(self, value):
        """Checks if the response is a short congratulatory message containing 'مبروك' and not exceeding 30 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        contains_mabrouk = 'مبروك' in value
        words = value.split()
        word_count = len(words)
        word_count_limit = 30
        is_within_word_limit = word_count <= word_count_limit
        return contains_mabrouk and is_within_word_limit



class DataIdx1004InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1004')

    def check_following(self, value):
        """Checks if the response follows the constraint of not exceeding 230 words.

        Args:
            value: A string representing the response (the email text).

        Returns:
            True if the response is a string and does not exceed 230 words,
            False otherwise. Semantic constraints like content and detail inclusion
            are not programmatically verified here.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count > 230:
            return False
        return True



class DataIdx1005InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1005')

    def check_following(self, value):
        """Checks if the response explains the difference between 'الكتاب' and 'المجلة'
        in exactly two sentences, using each word at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        has_ketab = 'الكتاب' in value
        has_majalla = 'المجلة' in value
        sentences = [s.strip() for s in value.split('.') if s.strip()]
        has_two_sentences = len(sentences) == 2
        return has_ketab and has_majalla and has_two_sentences



class DataIdx1006InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1006')

    def check_following(self, value):
        """Checks if the response mentions an Arab country at least twice."""
        arab_countries = ['مصر', 'السودان', 'الجزائر', 'المغرب', 'تونس', 'ليبيا', 'موريتانيا', 'جيبوتي', 'الصومال', 'جزر القمر', 'السعودية', 'المملكة العربية السعودية', 'الإمارات', 'الإمارات العربية المتحدة', 'قطر', 'الكويت', 'البحرين', 'عمان', 'اليمن', 'الأردن', 'فلسطين', 'دولة فلسطين', 'سوريا', 'لبنان', 'العراق']
        text = value
        for country in arab_countries:
            pattern = '\\b' + re.escape(country) + '\\b'
            matches = re.findall(pattern, text)
            count = len(matches)
            if count >= 2:
                return True
        return False



class DataIdx1007InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1007')

    def check_following(self, value):
        """Checks if the response is a sentence that does not contain the Arabic letter 'ص'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain 'ص', False otherwise.
        """
        forbidden_char = 'ص'
        return forbidden_char not in value



class DataIdx1008InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1008')

    def check_following(self, value):
        """Checks if the description does not contain common adjectives.

        WARNING: This check is a highly simplified and imperfect approximation
        of identifying Arabic adjectives. It relies on a small blacklist
        of common adjectives and simple word matching. It will likely produce
        incorrect results for many inputs due to complex Arabic morphology
        (plurals, feminization, different forms) and the need for proper NLP
        tools (tokenization, stemming, POS tagging) for accurate adjective
        identification. A correct check requires advanced Arabic NLP libraries.
        """
        adjectives_blacklist = {'جميل', 'جميلة', 'كبير', 'كبيرة', 'صغير', 'صغيرة', 'واسع', 'واسعة', 'نظيف', 'نظيفة', 'مزدحم', 'مزدحمة', 'هادئ', 'هادئة', 'أخضر', 'خضراء', 'ملون', 'ملونة', 'نقي', 'نقية', 'مشمس', 'مشمسة', 'بارد', 'باردة', 'حار', 'حارة', 'كثير', 'كثيرة', 'قليل', 'قليلة', 'لطيف', 'لطيفة', 'قوي', 'قوية', 'ضعيف', 'ضعيفة', 'قديم', 'قديمة', 'جديد', 'جديدة', 'سريع', 'سريعة', 'بطيء', 'بطيئة', 'طويل', 'طويلة', 'قصير', 'قصيرة', 'مميز', 'مميزة'}
        tokens = re.findall('\\b\\w+\\b', value)
        for token in tokens:
            if token in adjectives_blacklist:
                return False
        return True



class DataIdx1009InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1009')

    def check_following(self, value):
        """Checks if the Arabic review follows the constraints:
        - Between 60 and 80 words (inclusive).
        - Contains the word 'ممتع' at least once.
        (Does not check for presence of book/film name or personal opinion programmatically).
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        is_word_count_correct = 60 <= word_count <= 80
        contains_enjoyable_word = 'ممتع' in value
        return is_word_count_correct and contains_enjoyable_word



class DataIdx1010InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1010')

    def check_following(self, value):
        """Checks if the response follows the instruction for IDX 1010.

        Constraints:
        1. Single sentence (programmatically checked by ending with one terminator).
        2. Express opinion on importance of teamwork (not programmatically checked).
        3. Positive (not programmatically checked).
        4. Contains the word 'النجاح'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the programmatically checkable constraints, False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if 'النجاح' not in cleaned_value:
            return False
        sentence_terminators = ['.', '!', '?']
        if not cleaned_value or cleaned_value[-1] not in sentence_terminators:
            return False
        if any((char in sentence_terminators for char in cleaned_value[:-1])):
            return False
        return True



class DataIdx1011InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1011')

    def check_following(self, value):
        """Checks if the response lists three things using Arabic numerals and contains 'قمر' at least twice.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        has_numeral_1 = '١' in value
        has_numeral_2 = '٢' in value
        has_numeral_3 = '٣' in value
        qamar_count = value.count('قمر')
        has_qamar_twice = qamar_count >= 2
        return has_numeral_1 and has_numeral_2 and has_numeral_3 and has_qamar_twice



class DataIdx1012InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1012')

    def check_following(self, value):
        """Checks if the response is a motivational letter between 150 and 200 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response has between 150 and 200 words (inclusive), False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return 150 <= word_count <= 200



class DataIdx1013InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1013')

    def check_following(self, value):
        """Checks if the response follows the instruction.
        The dialogue must be at least 60 words long.

        Args:
            value: A string representing the response (the dialogue).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return word_count >= 60



class DataIdx1014InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1014')

    def check_following(self, value):
        """Checks if the response is a single Arabic question about weather starting with 'هل' and ending with '?'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if len(cleaned_value) < 2:
            return False
        if not cleaned_value.startswith('هل'):
            return False
        if not cleaned_value.endswith('?'):
            return False
        return True



class DataIdx1015InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1015')

    def check_following(self, value):
        """Checks if the response is a list of five items, each starting with 'أحب'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = [line.strip() for line in value.splitlines() if line.strip()]
        if len(lines) != 5:
            return False
        for line in lines:
            if not line.startswith('أحب'):
                return False
        return True



class DataIdx1016InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1016')

    def check_following(self, value):
        """Checks if the response contains a table comparing physical and e-books
           with the required columns ('وجه المقارنة', 'الكتاب الورقي', 'الكتاب الإلكتروني')
           and at least three comparison aspects (rows).
        """
        if not isinstance(value, str):
            return False
        header_cols = ['وجه المقارنة', 'الكتاب الورقي', 'الكتاب الإلكتروني']
        if not all((col in value for col in header_cols)):
            return False
        lines = value.strip().split('\n')
        first_header_line_index = -1
        last_header_line_index = -1
        for i, line in enumerate(lines):
            if any((col in line for col in header_cols)):
                if first_header_line_index == -1:
                    first_header_line_index = i
                last_header_line_index = i
        if first_header_line_index == -1 or last_header_line_index == -1:
            return False
        header_block_text = '\n'.join(lines[first_header_line_index:last_header_line_index + 1])
        if not all((col in header_block_text for col in header_cols)):
            return False
        data_row_candidates = []
        start_checking_index = last_header_line_index + 1
        if start_checking_index < len(lines):
            potential_separator_line = lines[start_checking_index].strip()
            if potential_separator_line and all((c in '-=|+#: ' for c in potential_separator_line)):
                start_checking_index += 1
        for i in range(start_checking_index, len(lines)):
            line = lines[i].strip()
            if not line:
                continue
            if line.count('|') >= 2:
                data_row_candidates.append(line)
                continue
            segments = re.split('\\s{2,}|\\t+', line)
            segments = [s.strip() for s in segments if s.strip()]
            if len(segments) >= 3:
                data_row_candidates.append(line)
                continue
        data_row_count = len(data_row_candidates)
        return data_row_count >= 3



class DataIdx1017InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1017')

    def check_following(self, value):
        """Checks if the response follows the instruction not to use any past tense verbs in Arabic.

        This check uses a very limited list of common Arabic past tense forms
        and may not be accurate due to the complexity of Arabic morphology
        and the constraint of not using external libraries.

        Args:
            value: A string representing the response (the short story).

        Returns:
            True if no words from the predefined list of common past tense forms are found,
            False otherwise.
        """
        common_past_tenses = {'قال', 'قالت', 'قالوا', 'كان', 'كانت', 'كانوا', 'فعل', 'فعلت', 'فعلوا', 'ذهب', 'ذهبت', 'ذهبوا', 'جاء', 'جاءت', 'جاءوا', 'رأى', 'رأت', 'رأوا', 'أخذ', 'أخذت', 'أخذوا', 'بدأ', 'بدأت', 'بدأوا', 'انتهى', 'انتهت', 'انتهوا', 'كتب', 'كتبت', 'كتبوا', 'شرب', 'شربت', 'شربوا', 'أكل', 'أكلت', 'أكلوا', 'لعب', 'لعبت', 'لعبوا', 'نام', 'نامت', 'ناموا', 'قام', 'قامت', 'قاموا', 'رأيت', 'رأيت', 'رأيتما', 'رأيتم', 'رأيتن', 'رأينا', 'كتبت', 'كتبت', 'كتبت', 'كتبتما', 'كتبتم', 'كتبتن', 'كتبنا', 'قلت', 'قلت', 'قلت', 'قلتما', 'قلتم', 'قلتن', 'قلنا', 'كنت', 'كنت', 'كنت', 'كنتما', 'كنتم', 'كنتن', 'كنا'}
        punctuation_to_remove = string.punctuation + '«»،؛؟'
        translator = str.maketrans('', '', punctuation_to_remove)
        cleaned_value = value.translate(translator)
        words = cleaned_value.split()
        for word in words:
            word_cleaned = word.replace('ـ', '')
            if word_cleaned in common_past_tenses:
                return False
        return True



class DataIdx1018InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1018')

    def check_following(self, value):
        """Checks if the response includes date, time, and location placeholders in square brackets.

        Args:
            value: A string representing the response (the announcement).

        Returns:
            True if the response contains '[التاريخ]', '[الوقت]', and '[الموقع]', False otherwise.
        """
        has_date_placeholder = '[التاريخ]' in value
        has_time_placeholder = '[الوقت]' in value
        has_location_placeholder = '[الموقع]' in value
        return has_date_placeholder and has_time_placeholder and has_location_placeholder



class DataIdx1019InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1019')

    def check_following(self, value):
        """Checks if the response is a comparison paragraph between two types of coffee and uses the word 'رائحة' at least twice.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        smell_count = value.count('رائحة')
        return smell_count >= 2



class DataIdx1020InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1020')

    def check_following(self, value):
        """Checks if the response is a product review in Arabic between 150 and 200 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (word count constraint) or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return 150 <= word_count <= 200



class DataIdx1021InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1021')

    def check_following(self, value):
        """
        Checks if the response is formatted as a text table.

        A text table is generally indicated by:
        1. Multiple lines (at least 3 for header, separator, and data).
        2. Use of characters like '|' for vertical separation or '-' and '+' for horizontal rules.

        Args:
            value: A string representing the response.

        Returns:
            True if the response appears to be formatted as a text table, False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        lines = value.strip().split('\n')
        if len(lines) < 3:
            return False
        has_pipes_on_multiple_lines = sum((1 for line in lines if '|' in line)) >= 2
        has_horizontal_rule = any((line.strip() and all((c in '-+| \t' for c in line.strip())) and any((c in '-+' for c in line.strip())) for line in lines))
        return has_pipes_on_multiple_lines or has_horizontal_rule



class DataIdx1022InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1022')

    def check_following(self, value):
        """Checks if the response uses only imperative verbs (based on a simple heuristic looking for present tense prefixes).
        Args:
            value: A string representing the response in Arabic.

        Returns:
            False if a word strongly indicative of a non-imperative (present tense) verb is found based on the heuristic,
            or if the response is empty/contains no words.
            True otherwise.
        """
        present_prefixes = ['أ', 'ن', 'ي', 'ت']
        arabic_chars = '\\u0600-\\u06FF'
        cleaned_text = re.sub(f'[^{arabic_chars}\\s]', '', value)
        words = [word for word in cleaned_text.split() if word]
        if not words:
            return False
        for word in words:
            if len(word) >= 3 and word[0] in present_prefixes:
                return False
        return True



class DataIdx1023InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1023')

    def check_following(self, value):
        """Checks if the response follows the constraints: no periods and ends each sentence with an exclamation mark.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if '.' in value:
            return False
        if not value.strip().endswith('!'):
            return False
        return True



class DataIdx1024InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1024')

    def check_following(self, value):
        """Checks if the response explains 'الديمقراطية' in less than 30 words and avoids 'حكومة'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        word_count = len(words)
        if word_count >= 30:
            return False
        forbidden_word = 'حكومة'
        if forbidden_word in value:
            return False
        return True



class DataIdx1025InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1025')

    def check_following(self, value: str) -> bool:
        """Checks if the response is a dialogue between exactly two people,
        with each person having at least four dialogue lines, using string methods.
        Assumes each dialogue line starts with a speaker name followed by
        a separator (:, -, or —).

        Args:
            value: A string representing the response (the dialogue).

        Returns:
            True if the response follows the structural constraints (2 speakers, >= 4 lines each),
            False otherwise. Content constraints (topic, clarity) are not checked.
        """
        lines = value.strip().splitlines()
        speaker_counts = {}
        separators = [':', '-', '—']
        for line in lines:
            line = line.strip()
            if not line:
                continue
            speaker_name = None
            separator_index = -1
            for sep in separators:
                idx = line.find(sep)
                if idx != -1 and (separator_index == -1 or idx < separator_index):
                    separator_index = idx
            if separator_index > 0:
                potential_speaker_part = line[:separator_index]
                speaker_name = potential_speaker_part.strip()
                if speaker_name:
                    speaker_counts[speaker_name] = speaker_counts.get(speaker_name, 0) + 1
        if len(speaker_counts) != 2:
            return False
        for count in speaker_counts.values():
            if count < 4:
                return False
        return True



class DataIdx1026InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1026')

    def check_following(self, value):
        """Checks if the response is a single word starting with the Arabic letter 'أ'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        if len(words) != 1:
            return False
        word = words[0]
        if not word.startswith('أ'):
            return False
        return True



class DataIdx1027InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1027')

    def check_following(self, value):
        """Checks if the response contains at least 50 words.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response has 50 words or more, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        return len(words) >= 50



class DataIdx1028InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1028')

    def check_following(self, value):
        """Checks if the response follows the instruction not to use exclamation marks.
        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain any exclamation marks, False otherwise.
        """
        return '!' not in value



class DataIdx1029InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1029')

    def check_following(self, value):
        """Checks if the response matches one of the two expected strings.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is one of the two expected strings, False otherwise.
        """
        expected_sunday = 'اليوم هو بداية الأسبوع.'
        expected_not_sunday = 'اليوم ليس بداية الأسبوع.'
        return value == expected_sunday or value == expected_not_sunday



class DataIdx1030InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1030')

    def check_following(self, value):
        """Checks if the response is text proposing a camping trip this weekend
           and lists exactly three activities using a bulleted list.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        text = value.lower()
        has_camping = 'تخييم' in text
        has_weekend = 'نهاية الأسبوع' in text
        if not has_camping or not has_weekend:
            return False
        lines = value.splitlines()
        activity_count = 0
        bullet_point_pattern = re.compile('^\\s*[-*+\\u2022]\\s+')
        for line in lines:
            stripped_line = line.lstrip()
            match = bullet_point_pattern.match(stripped_line)
            if match:
                content_after_bullet = stripped_line[match.end():].strip()
                if content_after_bullet:
                    activity_count += 1
        if activity_count != 3:
            return False
        return True



class DataIdx1031InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1031')

    def check_following(self, value):
        """Checks if the response is an Arabic poem of 4 lines,
        with each line having less than 10 words.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = [line.strip() for line in value.strip().splitlines() if line.strip()]
        if len(lines) != 4:
            return False
        for line in lines:
            words = [word for word in line.split() if word]
            if len(words) >= 10:
                return False
        return True



class DataIdx1032InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1032')

    def check_following(self, value):
        """Checks if the response follows the constraints for IDX 1032.

        Args:
            value: A string representing the response (news report).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        title_constraint_met = False
        start_idx = value.find('<<')
        if start_idx != -1:
            end_idx = value.find('>>', start_idx + 2)
            if end_idx != -1:
                if end_idx > start_idx + 2:
                    title_constraint_met = True
        if not title_constraint_met:
            return False
        words = value.split()
        word_count = len(words)
        if word_count < 350:
            return False
        telescope_mentioned = 'تلسكوب' in value
        scientists_mentioned = 'علماء' in value
        if not telescope_mentioned or not scientists_mentioned:
            return False
        return True



class DataIdx1033InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1033')

    def check_following(self, value):
        """Checks if every sentence in the Arabic dialogue ends with a question mark (؟).

        Args:
            value: A string representing the response (dialogue).

        Returns:
            True if the response follows the instruction, False otherwise.
        """
        if not value or value.isspace():
            return True
        sentence_terminator_pattern = '(?<=[.!?؟])\\s*'
        potential_sentences = re.split(sentence_terminator_pattern, value)
        processed_sentences = [s.rstrip() for s in potential_sentences if s.strip()]
        if not processed_sentences:
            return True
        for sentence in processed_sentences:
            if not sentence.endswith('؟'):
                return False
        return True



class DataIdx1034InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1034')

    def check_following(self, value):
        """Checks if the response is a plausible colloquial rewrite
           by looking for key entities and avoiding certain highly formal words from the original sentence.
           Precisely checking colloquial style programmatically for Arabic is inherently difficult
           without advanced linguistic tools, so this uses a heuristic.
        """
        if not isinstance(value, str):
            return False
        if len(value.strip()) < 15:
            return False
        key_entities = ['الفلسطينيين', 'شاول', 'داود']
        entities_present = all((entity in value for entity in key_entities))
        if not entities_present:
            return False
        formal_markers_to_avoid = ['عندما', 'انصرفوا', 'أهل الأرض أن', 'قد هربوا']
        formal_markers_absent = all((marker not in value for marker in formal_markers_to_avoid))
        return entities_present and formal_markers_absent



class DataIdx1035InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1035')

    def check_following(self, value):
        """Checks if the response follows the constraints for question 1035.

        Constraints:
        1. Description must be between 60 and 80 words (inclusive).
        2. Must contain at least one double quotation mark (").

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        word_count_check = 60 <= word_count <= 80
        quotation_check = '"' in value
        return word_count_check and quotation_check



class DataIdx1036InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1036')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        correct_sentence = 'الكتاب هو مفتاح العلم'
        return value == correct_sentence



class DataIdx1037InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1037')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 1037.
        Constraints:
        - Max 60 words.
        - Contains 'حصري' exactly once (checked as substring due to no-import rule).
        - Contains 'مميزات' exactly once (checked as substring due to no-import rule).
        - Text is in Arabic and Markdown (these are difficult to check reliably without libraries and specific criteria, so focusing on quantifiable constraints).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the specified constraints, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count > 60:
            return False
        exclusive_count = value.count('حصري')
        if exclusive_count != 1:
            return False
        features_count = value.count('مميزات')
        if features_count != 1:
            return False
        return True



class DataIdx1038InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1038')

    def check_following(self, value):
        """Checks if the response adheres to the constraints: exactly two sentences
        and contains the word 'الكون' at least once.
        (Note: The 'no abbreviations' and 'defines astronomy' constraints are not
        checked programmatically due to complexity/subjectivity based on the input constraints).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the checked constraints, False otherwise.
        """
        contains_al_kawn = 'الكون' in value
        sentence_terminators = ['.', '؟', '!']
        temp_delimiter = '###SENTENCE_END###'
        processed_value = ''
        last_was_terminator_seq = False
        for char in value:
            if char in sentence_terminators:
                if not last_was_terminator_seq:
                    processed_value += temp_delimiter
                last_was_terminator_seq = True
            else:
                processed_value += char
                last_was_terminator_seq = False
        sentence_parts = processed_value.split(temp_delimiter)
        non_empty_parts = [part.strip() for part in sentence_parts if part.strip()]
        sentence_count = len(non_empty_parts)
        is_exactly_two_sentences = sentence_count == 2
        return contains_al_kawn and is_exactly_two_sentences



class DataIdx1039InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1039')

    def check_following(self, value):
        """Checks if the response is an Arabic sentence expressing regret,
        contains 'آسف' at least once, and is short and direct.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        contains_asif = 'آسف' in value
        word_count = len(value.split())
        is_short = word_count > 0 and word_count <= 10
        contains_arabic = any(('\u0600' <= c <= 'ۿ' for c in value))
        return contains_asif and is_short and contains_arabic



class DataIdx1040InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1040')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1040.

        Instructions:
        - Post is very short (less than 15 words).
        - Must contain the words 'جمال', 'حصري', and 'الآن'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        length_constraint_met = word_count < 15
        keyword_beauty = 'جمال'
        keyword_exclusive = 'حصري'
        keyword_now = 'الآن'
        keywords_constraint_met = keyword_beauty in value and keyword_exclusive in value and (keyword_now in value)
        return length_constraint_met and keywords_constraint_met



class DataIdx1041InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1041')

    def check_following(self, value):
        """Checks if the response is a valid Arabic name of a Hijri month.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is one of the valid Hijri month names in Arabic,
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        valid_hijri_months = ['محرم', 'صفر', 'ربيع الأول', 'ربيع الثاني', 'جمادى الأولى', 'جمادى الثانية', 'رجب', 'شعبان', 'رمضان', 'شوال', 'ذو القعدة', 'ذو الحجة', 'ربيع الآخر', 'جمادى الآخرة']
        return value.strip() in valid_hijri_months



class DataIdx1042InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        self.instruction_id = 'idx_1042'

    def check_following(self, value):
        """Checks if the response is the correct passive voice transformation of 'يقرأ الطالب الكتاب في المكتبة.'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is a plausible correct passive transformation, False otherwise.
        """
        if not isinstance(value, str):
            return False
        value_cleaned = value.strip()
        value_cleaned = re.sub('\\s+', ' ', value_cleaned).strip()
        value_cleaned = re.sub('[\\.\\u06D4]$', '', value_cleaned)
        value_cleaned = value_cleaned.strip()
        idx_passive_verb = value_cleaned.find('يُقرأ')
        idx_book = value_cleaned.find('الكتاب')
        idx_library = value_cleaned.find('في المكتبة')
        if idx_passive_verb != -1 and idx_book != -1 and (idx_library != -1) and (idx_passive_verb < idx_book < idx_library):
            relevant_part = value_cleaned[idx_passive_verb:]
            expected_forms_cleaned = {'يُقرأ الكتاب في المكتبة', 'يُقرَأُ الكتابُ في المكتبةِ', 'يُقرأ الكتاب في المكتبةِ', 'يُقرأ الكتابُ في المكتبة', 'يُقرأ الكتابُ في المكتبةِ', 'يُقرَأُ الكتاب في المكتبة', 'يُقرَأُ الكتاب في المكتبةِ', 'يُقرَأُ الكتابُ في المكتبة', 'يُقرأُ الكتاب في المكتبة', 'يُقرأُ الكتابُ في المكتبة', 'يُقرأُ الكتابُ في المكتبةِ', 'يُقرأُ الكتاب في المكتبةِ'}
            if relevant_part in expected_forms_cleaned:
                return True
        return False



class DataIdx1043InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1043')

    def check_following(self, value):
        """Checks if the response consists of exactly two words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is a string consisting of exactly two words,
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.strip().split()
        return len(words) == 2



class DataIdx1044InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1044')

    def check_following(self, value):
        """Checks if the response (comment) follows the instructions.

        The instructions are:
        1. The comment does not exceed 30 words.
        2. The comment contains at least one exclamation mark (!).

        Args:
            value: A string representing the response (the comment).

        Returns:
            True if the response follows the instructions, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        word_count_ok = word_count <= 30
        exclamation_mark_ok = '!' in value
        return word_count_ok and exclamation_mark_ok



class DataIdx1045InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1045')

    def check_following(self, value):
        """Checks if the response contains the Arabic word "صحة" at least three times.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        word_to_count = 'صحة'
        count = value.count(word_to_count)
        return count >= 3



class DataIdx1046InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1046')

    def check_following(self, value):
        """
        Checks if the response is a numbered list with exactly three points,
        and if the word 'المعرفة' is present in each point.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.strip().split('\n')
        valid_points = []
        keyword = 'المعرفة'
        numbered_pattern = re.compile('^\\s*\\d+[\\.\\)]\\s+')
        for line in lines:
            stripped_line = line.strip()
            if not stripped_line:
                continue
            if numbered_pattern.match(stripped_line):
                if keyword in stripped_line:
                    valid_points.append(stripped_line)
                else:
                    return False
        return len(valid_points) == 3



class DataIdx1047InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1047')

    def check_following(self, value):
        """Checks if the response meets the constraints:
        1. Contains the word 'استراتيجيات' exactly once.
        2. Contains exactly 48 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = re.findall('\\S+', value)
        word_count = len(words)
        word_count_ok = word_count == 48
        target_word = 'استراتيجيات'
        target_word_count = words.count(target_word)
        target_word_ok = target_word_count == 1
        return word_count_ok and target_word_ok



class DataIdx1048InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1048')

    def check_following(self, value):
        """
        Checks if the Arabic story follows the constraints for IDX 1048:
        1. Exactly two paragraphs.
        2. Mentions 'قمر' at least 3 times.
        3. Contains (heuristically checked) exactly two main characters.
        """
        if not isinstance(value, str):
            return False
        paragraphs = re.split('\\n\\s*\\n+', value.strip())
        non_empty_paragraphs = [p.strip() for p in paragraphs if p.strip()]
        if len(non_empty_paragraphs) != 2:
            return False
        arabic_punctuation = '،؛؟!:«»()[]{}<>٫٬ـ'
        all_punctuation = string.punctuation + arabic_punctuation
        text_without_punct = value
        for char in all_punctuation:
            text_without_punct = text_without_punct.replace(char, ' ')
        words = [w.strip() for w in text_without_punct.split() if w.strip()]
        qamar_count = words.count('قمر')
        if qamar_count < 3:
            return False
        stopwords = set(['و', 'ف', 'ب', 'ك', 'ل', 'ال', 'كال', 'بال', 'فلل', 'ولل', 'في', 'على', 'من', 'إلى', 'عن', 'حتى', 'مذ', 'منذ', 'عدا', 'خلا', 'حاشا', 'مثل', 'كان', 'يكون', 'صار', 'يصير', 'ظل', 'يظل', 'بات', 'يبيت', 'أضحى', 'يضحي', 'أمسى', 'يمسي', 'ليس', 'ليست', 'ليسوا', 'لسن', 'قال', 'قالت', 'يقول', 'تقول', 'قالوا', 'قلت', 'قلنا', 'قلتم', 'قلتن', 'قيلا', 'هو', 'هي', 'هما', 'هم', 'هن', 'أنا', 'نحن', 'أنت', 'أنتِ', 'أنتما', 'أنتم', 'أنتن', 'إياه', 'إياها', 'إياهم', 'إياهن', 'إياي', 'إيانا', 'إياك', 'إياكِ', 'إياكما', 'إياكم', 'إياكن', 'ه', 'ها', 'هما', 'هم', 'هن', 'ي', 'نا', 'ك', 'كِ', 'كما', 'كم', 'كن', 'هذا', 'هذه', 'هذان', 'هاتان', 'هؤلاء', 'ذلك', 'تلك', 'أولئك', 'الذي', 'التي', 'الذان', 'اللتان', 'الذين', 'اللاتي', 'من', 'ما', 'أي', 'أية', 'إن', 'أن', 'كأن', 'لكن', 'ليت', 'لعل', 'لا', 'لم', 'لن', 'كي', 'لكي', 'قد', 'سوف', 'ربما', 'هلا', 'إذا', 'إذ', 'لو', 'لولا', 'ألا', 'أما', 'حيث', 'كيف', 'متى', 'أين', 'أي', 'كم', 'أيان', 'أنى', 'حيثما', 'كيفما', 'أينما', 'كل', 'بعض', 'غير', 'سوى', 'نفس', 'عين', 'جميع', 'عامة', 'خاصة', 'يا', 'أيها', 'أيتها', 'فقط', 'أيضا', 'هنا', 'هناك', 'ثم', 'إذن', 'الآن', 'أمس', 'غدا', 'فجر', 'ظهر', 'عصر', 'مغرب', 'عشاء', 'فوق', 'تحت', 'يمين', 'شمال', 'شرق', 'غرب', 'أمام', 'خلف', 'حول', 'بين', 'إلا', 'ذات', 'أول', 'آخر', 'ذو', 'ذوي', 'مرّة', 'مرات', 'مرة', 'شيء', 'أشياء', 'هكذا', 'و', 'ف', 'ب', 'ل', 'ك', 'ثم', 'أتى', 'يأتي', 'بقي', 'يبقى', 'أخذ', 'يأخذ', 'جعل', 'يجعل', 'بدأ', 'يبدأ', 'انتهى', 'ينتهي', 'استمر', 'يستمر', 'أمر', 'يأمر', 'حدث', 'يحدث', 'حصل', 'يحصل', 'ظهر', 'يظهر', 'اختفى', 'يختفي', 'ذهب', 'يذهب', 'جاء', 'يجيء', 'رأى', 'يرى', 'سمع', 'يسمع', 'تكلم', 'يتكلم', 'نظر', 'ينظر', 'مشى', 'يمشي', 'جرى', 'يجري', 'يوم', 'أيام', 'ليلة', 'ليالي', 'وقت', 'زمان', 'مكان', 'ماء', 'نور', 'ظل', 'شمس', 'سماء', 'أرض', 'بحر', 'نهر', 'جبل', 'بيت', 'باب', 'نافذة', 'شجر', 'ورد', 'صوت', 'كلام', 'فرح', 'حزن', 'خوف', 'أمل', 'كبير', 'صغير', 'جميل', 'قبيح', 'طويل', 'قصير', 'جديد', 'قديم'])
        filtered_words = [word for word in words if word not in stopwords and len(word) > 2]
        word_counts = Counter(filtered_words)
        potential_characters = [word for word, count in word_counts.items() if count >= 3]
        if len(potential_characters) != 2:
            return False
        return True



class DataIdx1049InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1049')

    def check_following(self, value):
        """
        Checks if the response contains exactly two distinct acceptable synonyms
        for "مهم" (excluding forms of "ضروري") from a predefined list.
        """
        if not isinstance(value, str):
            return False
        acceptable_synonyms_excluding_dorori = {'مهم', 'المهم', 'مهمة', 'المهمة', 'حيوي', 'الحيوي', 'حيوية', 'الحيوية', 'أساسي', 'الأساسي', 'أساسية', 'الأساسية', 'لازم', 'اللازم', 'لازمة', 'اللازمة', 'هام', 'الهام', 'هامة', 'الهامة', 'جوهري', 'الجوهري', 'جوهرية', 'الجوهرية'}
        cleaned_value = value
        cleaned_value = re.sub('[،؛؟.]', ' ', cleaned_value)
        cleaned_value = re.sub('و(\\S)', 'و \\1', cleaned_value)
        words = cleaned_value.split()
        input_words_set = set((word.strip() for word in words if word.strip()))
        found_synonyms = set()
        for word in input_words_set:
            if word in acceptable_synonyms_excluding_dorori:
                found_synonyms.add(word)
        return len(found_synonyms) == 2



class DataIdx1050InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1050')

    def check_following(self, value):
        """Checks if the response is an Arabic paragraph about the importance of reading,
        has at least four sentences, and uses the word 'القراءة' in each sentence.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not value or not value.strip():
            return False
        sentences = re.split('[.!?\\n]+', value)
        valid_sentences = [s.strip() for s in sentences if s.strip()]
        if len(valid_sentences) < 4:
            return False
        keyword = 'القراءة'
        for sentence in valid_sentences:
            if keyword not in sentence:
                return False
        return True



class DataIdx1051InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1051')

    def check_following(self, value):
        """Checks if the response is a short paragraph explaining AI without complex technical terms.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the programmable constraints or False otherwise.
        """
        if '\n\n' in value or '\n' * 3 in value:
            return False
        words = value.split()
        word_count = len(words)
        MAX_WORD_COUNT = 150
        if word_count > MAX_WORD_COUNT:
            return False
        forbidden_terms = ['تعلم الآلة', 'الشبكات العصبية', 'الخوارزميات', 'الخوارزمية', 'البيانات الضخمة', 'المعالجة اللغوية الطبيعية', 'الرؤية الحاسوبية', 'التعلم العميق']
        cleaned_value = value
        punctuation_and_space = ' .,!?;:()"\n\r\t'
        for p in '.,!?;:()"\n\r\t':
            cleaned_value = cleaned_value.replace(p, ' ')
        cleaned_value = ' '.join(cleaned_value.split())
        cleaned_value = f' {cleaned_value} '
        for term in forbidden_terms:
            if f' {term} ' in cleaned_value:
                return False
        return True



class DataIdx1052InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1052')

    def check_following(self, value):
        """Checks if the response is likely a single Lebanese colloquial Arabic sentence asking about today's weather.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        value = value.strip()
        question_indicators = ['؟', 'كيف', 'شو']
        has_question_indicator = any((indicator in value for indicator in question_indicators))
        if not has_question_indicator:
            return False
        has_today = 'اليوم' in value
        if not has_today:
            return False
        weather_terms = ['طقس', 'شوب', 'برد', 'شتي', 'حرارة', 'غيوم', 'شمس', 'هوا', 'دني', 'منيح', 'مش منيح', 'كيف الجو', 'مشمس', 'غائم', 'مثلج', 'عاصف', 'صقعة', 'سيول']
        has_weather_term = any((term in value for term in weather_terms))
        if not has_weather_term:
            return False
        if value.count('؟') > 1 or '.' in value:
            return False
        return True



class DataIdx1053InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1053')

    def check_following(self, value):
        """Checks if the response does not contain the word 'كان'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain the word 'كان' (as a standalone word),
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        if re.search('\\bكان\\b', value):
            return False
        return True



class DataIdx1054InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1054')

    def check_following(self, value):
        """Checks if the response is a brief, inspiring advice starting with 'تذكر'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        words = stripped_value.split(maxsplit=1)
        if not words:
            return False
        first_word = words[0]
        if first_word != 'تذكر':
            return False
        max_length = 150
        if len(stripped_value) > max_length:
            return False
        return True



class DataIdx1055InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1055')

    def check_following(self, value):
        """Checks if the response describes a dream without using the word 'حلم'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain the word 'حلم', False otherwise.
        """
        return 'حلم' not in value



class DataIdx1056InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1056')

    def check_following(self, value):
        """Checks if the response follows the instructions for question idx_1056.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or len(value) < 5:
            return False
        if value[0] != "'" or value[-1] != "'":
            return False
        content = value[1:-1]
        if 'إيجاز' not in content:
            return False
        if "'الجملة الأصلية'" not in content:
            return False
        if "'الجملة الموجزة'" not in content:
            return False
        return True



class DataIdx1057InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1057')

    def check_following(self, value):
        """Checks if the response defines 'الاجتهاد' in two complete sentences,
           starting with 'الاجتهاد هو' and 'وهو أيضاً' respectively.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentences = [s.strip() for s in value.split('.') if s.strip()]
        if len(sentences) != 2:
            return False
        first_sentence = sentences[0]
        second_sentence = sentences[1]
        if not first_sentence.startswith('الاجتهاد هو'):
            return False
        if not second_sentence.startswith('وهو أيضاً'):
            return False
        return True



class DataIdx1058InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1058')

    def check_following(self, value):
        """Checks if the response is a short Arabic dialogue about reading,
        enclosed in curly braces, containing a question mark and the word 'المعرفة'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not (value.startswith('{') and value.endswith('}')):
            return False
        if len(value) < 2:
            return False
        content = value[1:-1]
        if not content:
            return False
        if '?' not in content:
            return False
        if 'المعرفة' not in content:
            return False
        return True



class DataIdx1059InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1059')

    def check_following(self, value):
        """Checks if the response contains at least one rhetorical question,
           approximated by checking for the presence of an Arabic question mark '؟'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response contains '؟', False otherwise.
        """
        arabic_question_mark = '؟'
        return arabic_question_mark in value



class DataIdx1060InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1060')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1060.
        Constraints:
        1. Less than 130 words.
        2. Does not contain semicolon (;).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if ';' in value:
            return False
        words = value.split()
        word_count = len(words)
        if word_count >= 130:
            return False
        return True



class DataIdx1061InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1061')

    def check_following(self, value):
        """Checks if the response string has 60 words or less.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (<= 60 words), False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return word_count <= 60



class DataIdx1062InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1062')

    def check_following(self, value):
        """Checks if the response lists steps using a numbered list format.

        Args:
            value: A string representing the response.

        Returns:
            True if the response appears to be a numbered list with at least two items,
            False otherwise.
        """
        lines = value.strip().split('\n')
        numbered_item_pattern = re.compile('^\\s*\\d+[\\.\\)-]\\s*.+')
        numbered_item_count = 0
        for line in lines:
            if numbered_item_pattern.match(line):
                numbered_item_count += 1
        return numbered_item_count >= 2



class DataIdx1063InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1063')

    def check_following(self, value):
        """Checks if the response describes a favorite toy in a simple, informal style,
           in a maximum of three sentences. Focuses specifically on the sentence count constraint.
        Args:
            value: A string representing the response.

        Returns:
            True if the response has at most 3 sentences (based on punctuation), False otherwise.
        """
        cleaned_value = value.strip()
        if not cleaned_value:
            return True
        sentences = re.split('[.!?]+', cleaned_value)
        valid_sentences = [s for s in sentences if s.strip()]
        sentence_count = len(valid_sentences)
        return sentence_count <= 3



class DataIdx1064InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1064')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        return len(value) == 2



class DataIdx1065InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1065')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if ',' in value:
            return False
        terminators = ['.', '?', '!']
        has_terminator = False
        for terminator in terminators:
            if terminator in value:
                has_terminator = True
                break
        if not has_terminator:
            return False
        return True



class DataIdx1066InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1066')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1066.

        The response must:
        1. Mention some activities.
        2. Mention the target age group.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        text = value.lower()
        activity_keywords = ['أنشطة', 'فعاليات', 'رياضة', 'فن', 'حرف', 'سباحة', 'رحلات', 'ورش', 'تعلم', 'لعب', 'مرح', 'مسابقات', 'ترفيه']
        activities_found = any((keyword in text for keyword in activity_keywords))
        age_patterns = ['الفئة العمرية', 'الأعمار', '\\d+\\s*سنوات', 'من\\s*عمر\\s*\\d+', 'إلى\\s*عمر\\s*\\d+', 'من\\s*سن\\s*\\d+', 'إلى\\s*سن\\s*\\d+', 'بين\\s*\\d+\\s*و\\s*\\d+\\s*سنة', 'لأطفال\\s+من\\s+\\d+', 'الأطفال\\s+بعمر\\s+\\d+']
        age_found = False
        for pattern in age_patterns:
            if re.search(pattern, text):
                age_found = True
                break
        return activities_found and age_found



class DataIdx1067InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1067')

    def check_following(self, value):
        """Checks if the response contains the Arabic words 'book' and 'pen'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains both 'كتاب' and 'قلم', False otherwise.
        """
        if not isinstance(value, str):
            return False
        has_book = 'كتاب' in value
        has_pen = 'قلم' in value
        return has_book and has_pen



class DataIdx1068InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1068')

    def check_following(self, value):
        """Checks if the response is a paragraph about the importance of water and is more than 40 words.
        
        Args:
            value: A string representing the response (in Arabic).

        Returns:
            True if the response follows the instruction (more than 40 words), or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return word_count > 40



class DataIdx1069InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1069')

    def check_following(self, value):
        """Checks if the response is a short dialogue that meets the specified criteria.
           Constraints checked: includes 'فين' and 'السوق', and is at least four lines long.
           The dialect and specific content beyond keywords are not strictly checked programmatically.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the measurable instructions, False otherwise.
        """
        if not isinstance(value, str):
            return False
        has_fin = 'فين' in value
        has_souq = 'السوق' in value
        lines = value.strip().split('\n')
        non_empty_lines = [line for line in lines if line.strip()]
        min_lines_met = len(non_empty_lines) >= 4
        return has_fin and has_souq and min_lines_met



class DataIdx1070InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1070')

    def check_following(self, value):
        """Checks if the response describes a villain focusing on motivations and methods
           in a fantasy context, based on the presence of related keywords.

        Args:
            value: A string representing the response (Arabic description).

        Returns:
            True if the response contains keywords related to villainy, motivations, and methods.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        villain_keywords = {'شرير', 'شر', 'مظلم', 'شريرة', 'خبيث', 'شنيع', 'خطر', 'عدو', 'أعداء', 'خصم', 'خصوم', 'قوي', 'ظالم', 'بغيض', 'مرعب', 'طاغية', 'سيء'}
        motivation_keywords = {'دوافع', 'دافع', 'سبب', 'أسباب', 'هدف', 'أهداف', 'غاية', 'غايات', 'طموح', 'رغبة', 'يريد', 'يسعى', 'يسعى_ل', 'يرغب_في', 'يدفعه', 'محرك', 'لأنه', 'كي', 'لكي'}
        methods_keywords = {'أساليب', 'أسلوب', 'طريقة', 'طرق', 'خطة', 'خطط', 'كيفية', 'وسيلة', 'وسائل', 'يستخدم', 'يعتمد', 'من_خلال', 'عبر', 'يقوم_ب', 'يتحايل', 'يتلاعب', 'يفرض', 'يخطط', 'يستغل', 'بواسطة'}
        cleaned_value = re.sub('[.,!?;:"\\\'«»]', ' ', value).lower()
        words = set(cleaned_value.split())
        has_villain_indicator = any((word in words for word in villain_keywords))
        has_motivation_indicator = any((word in words for word in motivation_keywords))
        has_methods_indicator = any((word in words for word in methods_keywords))
        return has_villain_indicator and has_motivation_indicator and has_methods_indicator



class DataIdx1071InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1071')

    def check_following(self, value):
        """Check if the response contains no punctuation except for a period at the end.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not value:
            return False
        if value[-1] != '.':
            return False
        for char in value[:-1]:
            if char == '.' or (not char.isalpha() and (not char.isdigit()) and (not char.isspace())):
                return False
        return True



class DataIdx1072InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1072')

    def check_following(self, value):
        """Checks if the response is a list of at least five items with no punctuation.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        punctuation = set('!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~؟،؛')
        for char in value:
            if char in punctuation:
                return False
        items = [line for line in value.splitlines() if line.strip()]
        if len(items) < 5:
            return False
        return True



class DataIdx1073InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1073')

    def check_following(self, value):
        """Checks if the response follows the constraints for IDX 1073.

        Constraints:
        1. Word count between 120 and 150.
        2. Includes the word 'موضوع'.
        3. Includes the word 'رئيسي'.
        4. Contains exactly one interrogative sentence (ends with '?').

        Args:
            value: A string representing the response (summary).

        Returns:
            True if the response follows all instructions, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if not 120 <= word_count <= 150:
            return False
        if 'موضوع' not in value:
            return False
        if 'رئيسي' not in value:
            return False
        question_mark_count = value.count('?')
        if question_mark_count != 1:
            return False
        return True



class DataIdx1074InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1074')

    def check_following(self, value):
        """Checks if the response compares 'القلم' and 'الكمبيوتر' in exactly two sentences,
           mentions a feature for each (implicitly checked via structure and keywords),
           and uses the word 'لكن'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentences = [s.strip() for s in value.replace('؟', '.').replace('!', '.').split('.') if s.strip()]
        sentence_count = len(sentences)
        contains_pen = 'القلم' in value
        contains_computer = 'الكمبيوتر' in value
        contains_but = 'لكن' in value
        return sentence_count == 2 and contains_pen and contains_computer and contains_but



class DataIdx1075InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1075')

    def check_following(self, value):
        """Checks if the value is a numbered list with three items, where the second item is bold."""
        lines = value.strip().split('\n')
        numbered_items = []
        pattern = re.compile('^\\s*(\\d+)[\\.\\)\\-]\\s*(.+)')
        for line in lines:
            match = pattern.match(line)
            if match:
                try:
                    num = int(match.group(1))
                    text = match.group(2).strip()
                    numbered_items.append((num, text, line))
                except ValueError:
                    continue
        if len(numbered_items) != 3:
            return False
        numbered_items.sort()
        nums = [item[0] for item in numbered_items]
        if nums != [1, 2, 3]:
            return False
        second_item_original_line = numbered_items[1][2]
        match = pattern.match(second_item_original_line)
        if not match:
            return False
        second_item_text = match.group(2).strip()
        bold_pattern = re.compile('(\\*\\*|__)(?!\\1).+\\1')
        if bold_pattern.search(second_item_text):
            return True
        else:
            return False



class DataIdx1076InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1076')

    def check_following(self, value):
        """Checks if the response contains exactly 5 bullet points and no commas within those bullet points.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.strip().split('\n')
        bullet_chars = ['*', '-', '+', '•']
        list_item_count = 0
        for line in lines:
            stripped_line = line.strip()
            if not stripped_line:
                continue
            is_bullet_line = False
            for bullet in bullet_chars:
                if stripped_line.startswith(bullet):
                    content_start_index = len(bullet)
                    while content_start_index < len(stripped_line) and stripped_line[content_start_index].isspace():
                        content_start_index += 1
                    item_content = stripped_line[content_start_index:]
                    if ',' in item_content:
                        return False
                    list_item_count += 1
                    is_bullet_line = True
                    break
        return list_item_count == 5



class DataIdx1077InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1077')

    def check_following(self, value):
        """Check if the response follows the instructions for IDX 1077.

        Constraints:
        1. At least 4 sentences long.
        2. Uses parentheses () to provide examples.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        sentence_terminators = ['.', '!', '؟']
        sentences = []
        current_sentence = ''
        for char in value:
            current_sentence += char
            if char in sentence_terminators:
                sentences.append(current_sentence.strip())
                current_sentence = ''
        if current_sentence.strip():
            sentences.append(current_sentence.strip())
        valid_sentences = [s for s in sentences if s]
        sentence_count = len(valid_sentences)
        if sentence_count < 4:
            return False
        has_opening_paren = '(' in value
        has_closing_paren = ')' in value
        if not (has_opening_paren and has_closing_paren):
            return False
        return True



class DataIdx1078InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1078')

    def check_following(self, value):
        """Checks if the response is a Markdown table with specific constraints.
        Constraints:
        1. Is a Markdown table structure identifiable by header and separator.
        2. Has header row containing "الدولة" and "العاصمة".
        3. Header is followed immediately by a Markdown separator line (|---|---|...).
        4. Contains exactly 3 data rows after the separator.
        5. Data rows should not be empty (contain some content between pipes).
        """
        lines = [line.strip() for line in value.strip().split('\n') if line.strip()]
        header_index = -1
        separator_index = -1
        for i, line in enumerate(lines):
            if 'الدولة' in line and 'العاصمة' in line:
                header_index = i
                break
        if header_index == -1:
            return False
        if header_index + 1 < len(lines):
            separator_line = lines[header_index + 1]
            if all((c in '| -:' for c in separator_line)) and '-' in separator_line and ('|' in separator_line):
                separator_index = header_index + 1
        if separator_index == -1:
            return False
        data_rows_count = 0
        for i in range(separator_index + 1, len(lines)):
            line = lines[i]
            trimmed_line = line.strip()
            if trimmed_line.startswith('|') and trimmed_line.endswith('|'):
                columns = trimmed_line.split('|')
                if len(columns) >= 3 and any((col.strip() for col in columns[1:-1])):
                    data_rows_count += 1
                else:
                    break
            else:
                break
        return data_rows_count == 3



class DataIdx1079InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1079')

    def check_following(self, value):
        """
        Checks if the response follows the instruction for IDX 1079.
        Instruction: Write a news report about the fictional event 'discovery of a lost golden city in the Sahara Desert',
        including quotes from fictional eyewitnesses and authorities.

        This function performs a heuristic check by verifying the presence of
        key phrases related to the topic, the presence of quotation marks,
        and the mention of terms related to eyewitnesses and authorities.
        """
        if not isinstance(value, str):
            return False
        text = value
        topic_keywords = ['اكتشاف', 'مدينة ذهبية', 'مفقودة', 'الصحراء الكبرى']
        topic_present = all((kw in text for kw in topic_keywords))
        quotes_present = '"' in text or "'" in text
        eyewitness_keywords = ['شهود عيان', 'شاهد عيان', 'مستكشف', 'مستكشفون', 'عالم آثار', 'علماء آثار', 'أحد السكان', 'من السكان']
        eyewitness_mentioned = any((kw in text for kw in eyewitness_keywords))
        authority_keywords = ['سلطات', 'مسؤول', 'مسؤولون', 'جهة رسمية', 'وزارة', 'هيئة', 'فريق التنقيب', 'رئيس الفريق', 'الحكومة', 'الجهات الرسمية', 'وزير']
        authority_mentioned = any((kw in text for kw in authority_keywords))
        return topic_present and quotes_present and eyewitness_mentioned and authority_mentioned



class DataIdx1080InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1080')

    def check_following(self, value):
        """Checks if the response (Arabic paragraph) has more than 55 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (more than 55 words) or False otherwise.
        """
        words = value.split()
        return len(words) > 55



class DataIdx1081InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1081')

    def check_following(self, value):
        """Checks if the response adheres to the instruction constraints, primarily focusing on the 'one sentence' constraint due to programmatic limitations.
        It checks for empty/whitespace input, newline characters, and the count of sentence-ending punctuation marks.
        It does NOT programmatically verify imperative form, group address, or specific content about cooperation, as these require advanced linguistic analysis.

        Args:
            value: A string representing the response.

        Returns:
            True if the response appears to be a single sentence based on basic checks (not empty, no newlines, at most one sentence terminator),
            False otherwise.
        """
        if not value or not isinstance(value, str) or value.strip() == '':
            return False
        stripped_value = value.strip()
        if '\n' in stripped_value:
            return False
        sentence_terminators = ['.', '!', '?']
        terminator_count = 0
        for char in stripped_value:
            if char in sentence_terminators:
                terminator_count += 1
        if terminator_count > 1:
            return False
        return True



class DataIdx1082InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1082')

    def check_following(self, value):
        """Checks if the response consists of exactly two paragraphs.
        
        Note: This checker specifically verifies the paragraph count constraint
        (exactly two paragraphs separated by one or more blank lines).
        It does not programmatically verify other constraints like descriptive
        style, specific city mentioned, or the presence of sensory details (sight, sound, smell)
        as these require complex NLP or manual review which is beyond the scope of this
        simple automated checker function based on text structure.

        Args:
            value: A string representing the response.

        Returns:
            True if the response has exactly two paragraphs, False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        lines = value.splitlines()
        paragraph_count = 0
        in_paragraph = False
        for line in lines:
            stripped_line = line.strip()
            if stripped_line:
                if not in_paragraph:
                    paragraph_count += 1
                    in_paragraph = True
            else:
                in_paragraph = False
        return paragraph_count == 2



class DataIdx1083InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1083')
        correct_forms_raw = ['ذهبوا الأولادُ إلى الحديقةِ ولعبوا بالكراتِ', 'ذهب الأولادُ إلى الحديقةِ ولعبوا بالكراتِ', 'ذهبوا الأولاد إلى الحديقة ولعبوا بالكرات', 'ذهب الأولاد إلى الحديقة ولعبوا بالكرات']
        self.correct_answers_normalized = {self._normalize_and_strip(form) for form in correct_forms_raw}

    def _strip_arabic_diacritics(self, text):
        """Manually remove Arabic diacritic characters from the text."""
        stripped_text = ''
        diacritic_start = 'ً'
        diacritic_end = 'ْ'
        for char in text:
            if not diacritic_start <= char <= diacritic_end:
                stripped_text += char
        return stripped_text

    def _normalize_spaces(self, text):
        """Normalize multiple spaces to single space and strip leading/trailing spaces."""
        words = text.split()
        return ' '.join((word for word in words if word)).strip()

    def _normalize_and_strip(self, text):
        """Apply diacritic stripping and space normalization."""
        return self._normalize_spaces(self._strip_arabic_diacritics(text))

    def check_following(self, value):
        """Checks if the response is a correct correction of the Arabic sentence based on normalization.

        Args:
            value: A string representing the response (the corrected sentence).

        Returns:
            True if the response is a recognized correct form after normalization,
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        normalized_value = self._normalize_and_strip(value)
        return normalized_value in self.correct_answers_normalized



class DataIdx1084InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1084')

    def check_following(self, value):
        """Checks if the response is a single sentence summarizing the difference between descriptive and analytical articles,
        containing 'التحليل' and 'الوصف', and ending with sentence punctuation.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        contains_tahlil = 'التحليل' in value
        contains_wasf = 'الوصف' in value
        if not (contains_tahlil and contains_wasf):
            return False
        stripped_value = value.strip()
        terminators = ['.', '!', '?']
        terminator_count = 0
        last_terminator_index = -1
        for i in range(len(stripped_value)):
            if stripped_value[i] in terminators:
                terminator_count += 1
                last_terminator_index = i
        is_single_sentence = terminator_count == 1 and last_terminator_index == len(stripped_value) - 1
        return is_single_sentence



class DataIdx1085InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1085')

    def check_following(self, value):
        """Checks if the response follows the instructions:
        - Brief definition of 'الكتاب'.
        - Less than 25 words.
        - Does not use the word 'قراءة'.
        - Starts with 'الكتاب هو'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if not value.strip().startswith('الكتاب هو'):
            return False
        definition_part = value.strip()[len('الكتاب هو'):].strip()
        words = definition_part.split()
        if len(words) >= 25:
            return False
        if 'قراءة' in value:
            return False
        return True



class DataIdx1086InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1086')

    def check_following(self, value):
        """Checks if the response describes the experience in one paragraph.
        A single paragraph is assumed to not contain multiple consecutive newlines
        after stripping leading/trailing whitespace.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response appears to be a single paragraph, False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if '\n\n' in cleaned_value:
            return False
        return True



class DataIdx1087InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1087')

    def check_following(self, value):
        """Checks if the response follows the constraints for question 1087.
        Constraints:
        1. Must contain the word 'الشمس' exactly once.
        2. Must be a single sentence (heuristic: contains exactly one terminal punctuation mark '.', '!', or '?').
        (The requirement to describe sunny weather and use an appropriate adjective is not programmatically checked here).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        count_shams = cleaned_value.count('الشمس')
        if count_shams != 1:
            return False
        terminal_punctuation_count = cleaned_value.count('.') + cleaned_value.count('!') + cleaned_value.count('?')
        if terminal_punctuation_count != 1:
            return False
        return True



class DataIdx1088InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1088')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 1088.

        Instructions:
        - One sentence expressing opinion on education importance.
        - Must be emphasized using one of the emphasis tools (أدوات التوكيد).
        - Must not exceed fifteen words.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        word_count = len(words)
        if word_count > 15:
            return False
        emphasis_tools = ['إنّ', 'أنّ', 'قد', 'حقاً', 'فعلاً']
        has_emphasis = any((tool in value for tool in emphasis_tools))
        if not has_emphasis:
            return False
        return True



class DataIdx1089InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1089')

    def check_following(self, value):
        """Checks if the response includes 'adventure' and ends exactly with the specified Arabic phrase.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        includes_adventure = 'adventure' in value.lower()
        required_ending = 'هل هناك أي شيء آخر يمكنني مساعدتك به؟'
        ends_correctly = value.endswith(required_ending)
        return includes_adventure and ends_correctly



class DataIdx1090InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1090')

    def check_following(self, value):
        """Checks if the response includes the words 'شفاء' and 'عافية'.

        Args:
            value: A string representing the response (the prayer).

        Returns:
            True if the response contains both 'شفاء' and 'عافية', False otherwise.
        """
        if not isinstance(value, str):
            return False
        has_shifaa = 'شفاء' in value
        has_aafiya = 'عافية' in value
        return has_shifaa and has_aafiya



class DataIdx1091InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1091')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 1091.
        Instructions: Make the sentence "الطعام لذيذ" more descriptive and detailed. Do not use the word "لذيذ".

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if 'لذيذ' in value:
            return False
        original_sentence = 'الطعام لذيذ'
        if value.strip() == original_sentence:
            return False
        return True



class DataIdx1092InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1092')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        is_long_enough = len(words) >= 100
        phone_pattern = '\\d{7,}|(?:\\+\\d{1,3}[-\\.\\s]?)?\\d{2,}[-\\.\\s]?\\d{3,}[-\\.\\s]?\\d{4,}'
        has_phone_number = bool(re.search(phone_pattern, value))
        arabic_char_pattern = '[\\u0600-\\u06FF]'
        has_arabic_chars = bool(re.search(arabic_char_pattern, value))
        return is_long_enough and has_phone_number and has_arabic_chars



class DataIdx1093InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1093')

    def check_following(self, value):
        """Checks if the response is a correct verbal transformation of the given nominal sentence.

        The question asks to transform "الطلاب مجتهدون في دراستهم" (nominal) into a verbal sentence.
        Correct transformations should start with a verb derived from "اجتهد" and maintain the meaning.
        The most common and grammatically correct verbal forms are using the past or present tense.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is one of the expected correct verbal sentences, False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        correct_forms = ['اجتهد الطلاب في دراستهم', 'يجتهد الطلاب في دراستهم']
        return cleaned_value in correct_forms



class DataIdx1094InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1094')

    def check_following(self, value):
        """Checks if the response contains the word 'برج' exactly once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        return value.count('برج') == 1



class DataIdx1095InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1095')

    def check_following(self, value):
        """Checks if the response follows the instruction constraints."""
        if not isinstance(value, str):
            return False
        match = re.search('\\s*(\\d+)$', value)
        if not match:
            return False
        count_str = match.group(1)
        sentence_part = value[:match.start()]
        try:
            expected_count = int(count_str)
        except ValueError:
            return False
        has_underline = '<u>' in sentence_part or '_' in sentence_part
        if not has_underline:
            return False
        words = sentence_part.split()
        actual_count = len(words)
        if actual_count != expected_count:
            return False
        return True



class DataIdx1096InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1096')

    def check_following(self, value):
        """Checks if the response is in German.
        Args:
            value: A string representing the response.

        Returns:
            True if the response is in German, False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        try:
            detected_language = detect(value)
            return detected_language == 'de'
        except:
            return False



class DataIdx1097InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1097')

    def check_following(self, value):
        """Checks if the response is primarily in Arabic.
        This is a proxy check as verifying 'headline', 'paragraph', and 'scientific discovery'
        semantically is not feasible with simple string checks.
        The primary constraint check focuses on the language.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is primarily in Arabic (based on character count),
            False otherwise.
        """
        if not value or not value.strip():
            return False
        arabic_char_count = 0
        total_relevant_chars = 0
        arabic_range_start = 1536
        arabic_range_end = 1791
        for char in value:
            if not char.isspace():
                total_relevant_chars += 1
                char_ord = ord(char)
                if arabic_range_start <= char_ord <= arabic_range_end:
                    arabic_char_count += 1
        if total_relevant_chars == 0:
            return False
        threshold = 0.7
        arabic_percentage = arabic_char_count / total_relevant_chars
        return arabic_percentage >= threshold



class DataIdx1098InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1098')

    def check_following(self, value):
        """Checks if the response is a short paragraph about extracurricular activities and mentions 'القيادة' at least once.
        The primary check is for the required word.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains the word 'القيادة', False otherwise.
        """
        required_word = 'القيادة'
        if required_word in value:
            return True
        else:
            return False



class DataIdx1099InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1099')

    def check_following(self, value):
        """Checks if the response describes a favorite hobby in 3 sections separated by '---',
           with each section containing at least 3 sentences.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        sections = value.split('---')
        if len(sections) != 3:
            return False
        for section in sections:
            section_cleaned = section.strip()
            if not section_cleaned:
                sentence_count = 0
            else:
                sentences = re.split('[.!?]', section_cleaned)
                sentence_count = sum((1 for sent in sentences if sent.strip()))
            if sentence_count < 3:
                return False
        return True



class DataIdx1100InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1100')

    def check_following(self, value):
        """Checks if the response is a two-sentence summary containing 'العمل الجماعي' and 'حل المشكلات'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        has_teamwork = 'العمل الجماعي' in value
        has_problem_solving = 'حل المشكلات' in value
        sentence_terminators = ['.', '!', '?']
        sentence_count = 0
        for char in value:
            if char in sentence_terminators:
                sentence_count += 1
        return has_teamwork and has_problem_solving and (sentence_count == 2)



class DataIdx1101InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1101')

    def check_following(self, value):
        """Checks if the response is a sentence about the weather without using any commas.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        return ',' not in value



class DataIdx1102InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1102')

    def check_following(self, value):
        """Checks if the response follows the instruction: do not use commas.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain commas, False otherwise.
        """
        if ',' in value:
            return False
        return True



class DataIdx1103InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1103')

    def check_following(self, value):
        """Checks if the response is a short thank you message (max 3 sentences)
           to someone who helped, includes 'شكرًا' at least once, is sincere and expressive.
           (Sincerity/expressiveness is subjective and cannot be checked programmatically;
           we focus on the objective constraints).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the objective constraints (max 3 sentences, includes 'شكرًا'),
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        temp_value = value.strip()
        if not temp_value:
            return False
        temp_value = temp_value.replace('!', '.').replace('؟', '.')
        sentences = [s.strip() for s in temp_value.split('.') if s.strip()]
        sentence_count = len(sentences)
        max_sentences = 3
        if sentence_count > max_sentences:
            return False
        if 'شكرًا' not in value:
            return False
        return True



class DataIdx1104InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1104')

    def check_following(self, value):
        """Checks if the response contains the correctly completed sentence with the specified words in order, enclosed in quotation marks.

        The expected sentence is "زرقاء السماء صافية في فصل الصيف".
        The response must be exactly this sentence enclosed in double quotes.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is exactly '"زرقاء السماء صافية في فصل الصيف"', False otherwise.
        """
        expected_sentence = 'زرقاء السماء صافية في فصل الصيف'
        expected_response = f'"{expected_sentence}"'
        return value == expected_response



class DataIdx1105InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1105')

    def check_following(self, value):
        """Checks if the response follows the constraints for IDX 1105.

        Args:
            value: A string representing the response (tweet).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        length_ok = len(value) <= 280
        arabic_count_ok = value.count('العربية') >= 2
        no_links = not ('http' in value or 'https' in value or 'www.' in value)
        return length_ok and arabic_count_ok and no_links



class DataIdx1106InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1106')

    def check_following(self, value):
        """Checks if the response is a single sentence definition of 'الاستدامة'.

        Args:
            value: A string representing the response (Arabic definition of Sustainability).

        Returns:
            True if the response consists of a single sentence, False otherwise.
        """
        sentences = re.split('[.!?]', value)
        cleaned_sentences = [s.strip() for s in sentences]
        non_empty_sentences = [s for s in cleaned_sentences if s]
        return len(non_empty_sentences) <= 1



class DataIdx1107InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1107')

    def check_following(self, value):
        """
        Checks if the response is a numbered list of exactly 5 items (1 to 5).
        The list must be numbered sequentially from 1 to 5.
        Each numbered item must have some content after the number/punctuation.
        """
        lines = value.strip().split('\n')
        content_lines = [line for line in lines if line.strip()]
        if len(content_lines) != 5:
            return False
        expected_prefixes = {}
        for i in range(1, 6):
            expected_prefixes[i] = [f'{i}.', f'{i})']
        for i in range(5):
            line = content_lines[i]
            expected_number = i + 1
            is_matched = False
            line_to_check = line.strip()
            for prefix in expected_prefixes[expected_number]:
                if line_to_check.startswith(prefix):
                    after_prefix_content = line_to_check[len(prefix):].strip()
                    if after_prefix_content:
                        is_matched = True
                        break
            if not is_matched:
                return False
        return True



class DataIdx1108InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1108')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 1108.
        The instruction requires mentioning the word 'عكسية' (inverse) at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains the word 'عكسية', False otherwise.
        """
        required_word = 'عكسية'
        return required_word in value



class DataIdx1109InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1109')

    def check_following(self, value):
        """Checks if the response contains the word "ابتكار" at least 5 times.

        Args:
            value: A string representing the response (job advertisement).

        Returns:
            True if the word "ابتكار" appears 5 or more times, False otherwise.
        """
        if not isinstance(value, str):
            return False
        count = value.count('ابتكار')
        return count >= 5



class DataIdx1110InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1110')

    def check_following(self, value):
        """Checks if the response is a single interrogative sentence asking for an opinion
           on the importance of continuous learning, starting with 'ما رأيك في...' and ending with '?'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        start_phrase = 'ما رأيك في'
        if not cleaned_value.startswith(start_phrase):
            return False
        topic_phrase = 'أهمية التعليم المستمر'
        if topic_phrase not in cleaned_value:
            return False
        if not cleaned_value.endswith('؟'):
            return False
        start_idx = cleaned_value.find(start_phrase)
        topic_idx = cleaned_value.find(topic_phrase)
        end_idx = cleaned_value.rfind('؟')
        if not start_idx < topic_idx < end_idx:
            return False
        if cleaned_value[:-1].count('؟') > 0:
            return False
        return True



class DataIdx1111InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1111')

    def check_following(self, value):
        """Checks if the response is a short dialogue (2 lines) asking/answering about the time,
        containing the words 'كم' and 'الساعة'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        actual_lines = [line for line in lines if line.strip()]
        if len(actual_lines) != 2:
            return False
        if 'كم' not in value or 'الساعة' not in value:
            return False
        return True



class DataIdx1112InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1112')

    def check_following(self, value):
        """Checks if the response is a paragraph with at least 50 words.
        Args:
            value: A string representing the response (the paragraph in Arabic).

        Returns:
            True if the paragraph has 50 words or more, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return word_count >= 50



class DataIdx1113InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1113')

    def check_following(self, value):
        """
        Checks if the response is a single sentence comparing life in the past and present
        using appropriate comparison style.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        terminal_punctuations = '.!?'
        ends_with_terminal = False
        if cleaned_value:
            ends_with_terminal = cleaned_value[-1] in terminal_punctuations
        if not ends_with_terminal:
            return False
        for char in cleaned_value[:-1]:
            if char in terminal_punctuations:
                return False
        if 'الحياة' not in value:
            return False
        past_keywords = ['الماضي', 'قديماً', 'قديما']
        present_keywords = ['الحاضر', 'اليوم', 'الآن']
        has_past_keyword = any((pk in value for pk in past_keywords))
        has_present_keyword = any((prk in value for prk in present_keywords))
        if not (has_past_keyword and has_present_keyword):
            return False
        comparative_adjectives = ['أكبر', 'أصغر', 'أسرع', 'أبطأ', 'أسهل', 'أصعب', 'أجمل', 'أقبح', 'أطول', 'أقصر', 'أغنى', 'أفقر', 'أسعد', 'أشقى', 'أذكى', 'أغبى', 'ألذ', 'أمر', 'أفضل', 'أسوأ', 'أقرب', 'أبعد', 'أعلى', 'أدنى', 'أشد']
        comparative_keywords = ['أكثر', 'أقل', 'بينما', 'في حين', 'على عكس', 'بخلاف', 'مقارنة', 'بالمقارنة', 'كثيراً', 'قليلاً', 'نسبياً', 'أكثر ب', 'أقل ب'] + comparative_adjectives
        has_comparative_indicator = any((ck in value for ck in comparative_keywords))
        if not has_comparative_indicator:
            return False
        return True



class DataIdx1114InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1114')

    def check_following(self, value):
        """Checks if the response is a formal letter requesting one-day leave,
        is concise, and does not exceed 100 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        word_count = len(words)
        if word_count > 100:
            return False
        if 'إجازة' not in value:
            return False
        return True



class DataIdx1115InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1115')

    def check_following(self, value):
        """Checks if the response is a short paragraph summarizing reading benefits.
        This checker primarily focuses on structural constraints:
        - Is it a string?
        - Does it meet minimum/maximum word count?
        - Does it meet minimum/maximum sentence count?
        (Checking actual content relevance/summarization is beyond simple string checks)

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the structural constraints, False otherwise.
        """
        if not isinstance(value, str):
            return False
        text = value.strip()
        if not text:
            return False
        words = text.split()
        word_count = len(words)
        min_word_count = 20
        max_word_count = 150
        min_sentence_count = 2
        max_sentence_count = 7
        if not min_word_count <= word_count <= max_word_count:
            return False
        sentences = re.split('[.!?]+\\s*', text)
        sentences = [s for s in sentences if s.strip()]
        sentence_count = len(sentences)
        if not min_sentence_count <= sentence_count <= max_sentence_count:
            return False
        return True



class DataIdx1116InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1116')

    def check_following(self, value):
        """Checks if the response is a single sentence containing 'أعتذر' and 'خطأي'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        has_required_words = 'أعتذر' in value and 'خطأي' in value
        no_newlines = '\n' not in value
        if not cleaned_value:
            ends_with_terminal = False
            punctuation_count_before_end = -1
        else:
            ends_with_terminal = cleaned_value.endswith(('.', '!', '?'))
            content_before_end = cleaned_value[:-1]
            punctuation_count_before_end = content_before_end.count('.') + content_before_end.count('!') + content_before_end.count('?')
        is_single_sentence = no_newlines and ends_with_terminal and (punctuation_count_before_end == 0)
        return has_required_words and is_single_sentence



class DataIdx1117InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1117')

    def check_following(self, value):
        """Checks if the response is a single sentence containing a proper noun and an indefinite common noun (اسم نكرة).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        terminal_punctuation = ['.', '!', '?']
        ends_with_punctuation = False
        if cleaned_value and cleaned_value[-1] in terminal_punctuation:
            ends_with_punctuation = True
            if any((char in terminal_punctuation for char in cleaned_value[:-1])):
                return False
        if not ends_with_punctuation:
            return False
        proper_nouns = set(['محمد', 'أحمد', 'علي', 'فاطمة', 'مريم', 'القاهرة', 'مكة', 'سوريا', 'مصر'])
        has_proper_noun = False
        words = cleaned_value.replace('.', '').replace('!', '').replace('?', '').split()
        for word in words:
            if word in proper_nouns:
                has_proper_noun = True
                break
        if not has_proper_noun:
            return False
        tanween_chars = ['ً', 'ٌ', 'ٍ']
        has_indefinite_noun = False
        for word in words:
            if any((char in word for char in tanween_chars)):
                has_indefinite_noun = True
                break
        if not has_indefinite_noun:
            pass
        return has_proper_noun and has_indefinite_noun



class DataIdx1118InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1118')

    def check_following(self, value):
        """Checks if the response contains a semicolon.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains a semicolon, False otherwise.
        """
        return ';' in value



class DataIdx1119InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1119')

    def check_following(self, value):
        """Checks if the response is a thank you letter to a teacher that follows the constraints.

        Args:
            value: A string representing the response (the letter).

        Returns:
            True if the response follows the instructions (less than 80 words and starts with 'إلى معلمي العزيز'),
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        if not value.strip().startswith('إلى معلمي العزيز'):
            return False
        words = value.split()
        word_count = len(words)
        if word_count >= 80:
            return False
        return True



class DataIdx1120InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1120')

    def check_following(self, value):
        """Checks if the response is a single question starting with 'لماذا'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response is a single question starting with 'لماذا', False otherwise.
        """
        value = value.strip()
        if value.startswith('لماذا') and value.count('?') == 1:
            return True
        else:
            return False



class DataIdx1121InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1121')
        self.conditional_particles = ['إن', 'اذا', 'إذا', 'لو', 'من', 'ما', 'مهما', 'متى', 'أين', 'حيثما', 'كيفما', 'أيان', 'أنّى']
        self.present_prefixes = ('أ', 'ن', 'ي', 'ت')

    def check_following(self, value):
        """Checks if the response is an Arabic conditional sentence with past condition verb and present result verb.
        This check uses basic heuristics based on particle presence and word prefixes/lengths, and is not a full NLP parse.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction based on heuristics, False otherwise.
        """
        if not isinstance(value, str):
            return False
        text = value.strip()
        if not text:
            return False
        found_particle_match = None
        for particle in self.conditional_particles:
            match = re.search('(?:^|\\s)' + re.escape(particle) + '\\b', text)
            if match:
                found_particle_match = match
                break
        if not found_particle_match:
            return False
        after_particle = text[found_particle_match.end():].strip()
        words = re.findall('[\\u0600-\\u06FF]+', after_particle)
        verb1_found = False
        verb1_idx = -1
        for i, word in enumerate(words):
            if len(word) < 2:
                continue
            if not word.startswith(self.present_prefixes):
                verb1_found = True
                verb1_idx = i
                break
        if not verb1_found:
            return False
        verb2_found = False
        for i in range(verb1_idx + 1, len(words)):
            word = words[i]
            if len(word) < 2:
                continue
            if word.startswith(self.present_prefixes):
                verb2_found = True
                break
        return verb2_found



class DataIdx1122InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1122')

    def check_following(self, value):
        """Checks if the response does not contain the word 'لكن'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain 'لكن', False otherwise.
        """
        forbidden_word = 'لكن'
        return forbidden_word not in value



class DataIdx1123InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1123')

    def check_following(self, value):
        """Checks if the response describes Riyadh in three lines, each starting with 'الرياض' and ending with '!'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.splitlines()
        if len(lines) != 3:
            return False
        for line in lines:
            stripped_line = line.strip()
            if not stripped_line.startswith('الرياض'):
                return False
            if not stripped_line.endswith('!'):
                return False
            if len(stripped_line) <= len('الرياض!'):
                return False
        return True



class DataIdx1124InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1124')

    def check_following(self, value):
        """Checks if the response is three separate sentences, each starting with 'ن'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.strip().split('\n')
        if len(lines) != 3:
            return False
        for line in lines:
            stripped_line = line.strip()
            if not stripped_line or stripped_line[0] != 'ن':
                return False
        return True



class DataIdx1125InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1125')

    def check_following(self, value):
        """Checks if the response contains at least two paragraphs.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains at least one double newline (indicating at least two paragraphs), False otherwise.
        """
        return '\n\n' in value



class DataIdx1126InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1126')

    def check_following(self, value):
        """Checks if the response is a single sentence and contains no past tense verbs.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        sentence_enders = ['.', '!', '?']
        if not cleaned_value:
            return False
        if not cleaned_value[-1] in sentence_enders:
            return False
        ender_count = sum((value.count(end) for end in sentence_enders))
        if ender_count > 1:
            return False
        past_tense_suffixes_heuristic = ['وا', 'تا', 'تما', 'تم', 'تن', 'نا']
        words = re.findall('\\b[\\u0600-\\u06FF]+\\b', cleaned_value)
        for word in words:
            for suffix in past_tense_suffixes_heuristic:
                if word.endswith(suffix):
                    return False
        return True



class DataIdx1127InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1127')

    def check_following(self, value):
        """Checks if the response addresses the required controversial issue 'organ transplantation'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response contains the phrase 'زراعة الأعضاء', False otherwise.
        """
        required_topic = 'زراعة الأعضاء'
        return required_topic in value



class DataIdx1128InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1128')

    def check_following(self, value):
        """Checks if the response ends exactly with the required phrase.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (ends exactly with the phrase) or False otherwise.
        """
        required_ending = 'هل هناك أي شيء آخر يمكنني مساعدتك به؟'
        return value.endswith(required_ending)



class DataIdx1129InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1129')

    def check_following(self, value):
        """Checks if the response is a string representing three items,
           each starting with 'm' and having a length less than six.
           It attempts to parse the string assuming it's a comma-separated
           list or a Python-like list string.
        Args:
            value: A string representing the response (e.g., "mango, mora, melón" or "['mango', 'mora', 'melón']").

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        processed_value = value.strip()
        if processed_value.startswith('[') and processed_value.endswith(']'):
            processed_value = processed_value[1:-1].strip()
        items = []
        if processed_value:
            items_raw = processed_value.split(',')
            items = [item.strip(' \'"') for item in items_raw]
        if len(items) != 3:
            return False
        for item in items:
            if not item:
                return False
            if not item.startswith('m'):
                return False
            if len(item) >= 6:
                return False
        return True



class DataIdx1130InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1130')

    def check_following(self, value):
        """Checks if the response contains exactly two Arabic vegetable names starting with 'ب'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        valid_vegetables_ba = {'بصل', 'بطاطس', 'باذنجان', 'بامية', 'بروكلي', 'بنجر', 'بازلاء'}
        words = value.strip().split()
        if len(words) != 2:
            return False
        word1 = words[0]
        word2 = words[1]
        if not word1.startswith('ب') or not word2.startswith('ب'):
            return False
        if word1 not in valid_vegetables_ba or word2 not in valid_vegetables_ba:
            return False
        return True



class DataIdx1131InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1131')

    def check_following(self, value):
        """Checks if the response is a single Arabic exclamatory sentence
           starting with 'ما أجمل', containing 'طبيعة', and ending with '!'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        starts_with_ma_ajmal = stripped_value.startswith('ما أجمل')
        contains_tabi3a = 'طبيعة' in stripped_value
        ends_with_exclamation = stripped_value.endswith('!')
        single_exclamation = stripped_value.count('!') == 1
        return starts_with_ma_ajmal and contains_tabi3a and ends_with_exclamation and single_exclamation



class DataIdx1132InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1132')
        self.forbidden_punctuation = string.punctuation.replace('.', '')

    def check_following(self, value):
        """Checks if the response contains any punctuation marks other than a period.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (contains only periods as punctuation, or no punctuation), False otherwise.
        """
        if not isinstance(value, str):
            return False
        for char in value:
            if char in self.forbidden_punctuation:
                return False
        return True



class DataIdx1133InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1133')

    def check_following(self, value):
        """
        Checks if the response is a single sentence with fewer words than the original sentence.
        Original sentence word count is 17.
        Original sentence: "على الرغم من الصعوبات الكبيرة التي واجهتنا في المشروع، إلا أننا تمكنا من إنجازه في الوقت المحدد."
        """
        original_word_count_threshold = 17
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        response_words = re.findall('\\b\\w+\\b', cleaned_value)
        response_word_count = len(response_words)
        if response_word_count == 0 or response_word_count >= original_word_count_threshold:
            return False
        terminators = ['.', '!', '?']
        terminator_count_total = sum((cleaned_value.count(term) for term in terminators))
        if terminator_count_total > 1:
            return False
        if terminator_count_total == 1:
            if cleaned_value[-1] not in terminators:
                return False
        return True



class DataIdx1134InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1134')

    def check_following(self, value):
        """Checks if the response mentions the word 'قطة' at least twice.
        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the word 'قطة' appears 2 or more times, False otherwise.
        """
        word_to_find = 'قطة'
        count = value.count(word_to_find)
        return count >= 2



class DataIdx1135InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1135')

    def check_following(self, value):
        """Checks if the response is a complaint letter mentioning product name, order number, purchase date, and requesting a solution,
           using polite but firm language (heuristic check).

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        mentions_product = 'المنتج' in value or 'السلعة' in value
        mentions_order_number = 'رقم الطلب' in value
        mentions_purchase_date = 'تاريخ الشراء' in value or 'بتاريخ' in value
        request_solution_keywords = ['حل', 'استبدال', 'استرداد', 'تعويض', 'إصلاح', 'يرجى', 'أرجو', 'أطلب', 'نتطلع']
        mentions_solution_request = any((keyword in value for keyword in request_solution_keywords))
        if not (mentions_product and mentions_order_number and mentions_purchase_date and mentions_solution_request):
            return False
        return True



class DataIdx1136InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1136')

    def check_following(self, value):
        """Checks if the response is a single sentence expressing an opinion on
        the importance of education, using the word 'ضروري' exactly once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        trimmed_value = value.strip()
        if not trimmed_value:
            return False
        sentence_enders = '.!?'
        enders_count = sum((1 for char in trimmed_value if char in sentence_enders))
        is_single_sentence = enders_count == 1 and trimmed_value.endswith(tuple(sentence_enders)) and (len(trimmed_value.rstrip(sentence_enders).strip()) > 0)
        target_word = 'ضروري'
        padded_value = f' {trimmed_value} '
        target_word_padded = f' {target_word} '
        dorori_count = padded_value.count(target_word_padded)
        has_one_dorori = dorori_count == 1
        return is_single_sentence and has_one_dorori



class DataIdx1137InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1137')

    def check_following(self, value):
        """Checks if the response is a summary with at least 50 words.

        Args:
            value: A string representing the response (the book summary).

        Returns:
            True if the response has at least 50 words, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.strip().split()
        word_count = len(words)
        return word_count >= 50



class DataIdx1138InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1138')

    def check_following(self, value):
        """Checks if the response correctly corrects the grammatical error in the sentence 'إن الطالبان مجتهدين.'.

        Args:
            value: A string representing the response (the corrected sentence).

        Returns:
            True if the response is the correct sentence, False otherwise.
        """
        correct_sentence = 'إن الطالبين مجتهدان.'
        normalized_value = value.strip()
        return normalized_value == correct_sentence



class DataIdx1139InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1139')

    def check_following(self, value):
        """Checks if the response follows the constraints for IDX 1139.
        Constraints:
        - Dialogue in Standard Arabic (checked by content, assumed OK for this checker)
        - Between two people about reading (checked by content, assumed OK for this checker)
        - At least six lines.
        - Use question mark at the end of every question.

        Args:
            value: A string representing the response (Arabic dialogue).

        Returns:
            True if the response follows the quantifiable instructions, False otherwise.
        """
        lines = value.split('\n')
        content_lines = [line for line in lines if line.strip()]
        if len(content_lines) < 6:
            return False
        has_qm_line_end = any((line.strip().endswith('?') for line in content_lines))
        if not has_qm_line_end:
            return False
        question_words = ['هل', 'ماذا', 'لماذا', 'كيف', 'متى', 'أين', 'من', 'أي']
        question_word_pattern = re.compile('\\b(' + '|'.join((re.escape(word) for word in question_words)) + ')\\b', re.UNICODE)
        for line in content_lines:
            stripped_line = line.strip()
            dialogue_part = stripped_line
            if ':' in stripped_line:
                parts = stripped_line.split(':', 1)
                if len(parts) > 1:
                    dialogue_part = parts[1].strip()
            if question_word_pattern.search(dialogue_part):
                if not stripped_line.endswith('?'):
                    return False
        return True



class DataIdx1140InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1140')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        year_pattern = re.compile('\\[\\d+\\]')
        year_match = year_pattern.search(stripped_value)
        if not year_match:
            return False
        sentence_terminators = ['.', '!', '?']
        terminator_indices = [i for i, char in enumerate(stripped_value) if char in sentence_terminators]
        if len(terminator_indices) != 1:
            return False
        if terminator_indices[0] != len(stripped_value) - 1:
            return False
        return True



class DataIdx1141InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1141')

    def check_following(self, value):
        """Checks if the response starts with 'تذكير:'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response starts with 'تذكير:', False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        return cleaned_value.startswith('تذكير:')



class DataIdx1142InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1142')

    def check_following(self, value):
        """Checks if the response does not contain question marks.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain the character '?', False otherwise.
        """
        return '?' not in value



class DataIdx1143InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1143')

    def check_following(self, value):
        """Checks if the response is a single sentence ending with ., !, or ?."""
        trimmed_value = value.strip()
        if not trimmed_value:
            return False
        terminal_punctuation = {'.', '!', '?'}
        if trimmed_value[-1] not in terminal_punctuation:
            return False
        for char in trimmed_value[:-1]:
            if char in terminal_punctuation:
                return False
        return True



class DataIdx1144InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1144')

    def check_following(self, value):
        """Checks if the response is a paragraph of at least 50 words
           using only periods and semicolons for punctuation."""
        text_for_word_count = value.replace('.', '').replace(';', '')
        words = text_for_word_count.split()
        word_count = len(words)
        if word_count < 50:
            return False
        allowed_punctuation = {'.', ';'}
        all_punctuation_set = set(string.punctuation)
        forbidden_punctuation_set = all_punctuation_set - allowed_punctuation
        for char in value:
            if char in forbidden_punctuation_set:
                return False
        return True



class DataIdx1145InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1145')

    def check_following(self, value):
        """Checks if the response is a string enclosed in single quotes with at least 150 words inside.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if not (value.startswith("'") and value.endswith("'")):
            return False
        if len(value) < 2:
            return False
        inner_text = value[1:-1]
        if not inner_text:
            return False
        words = inner_text.split()
        word_count = len(words)
        return word_count >= 150



class DataIdx1146InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1146')

    def check_following(self, value):
        """Checks if the response contains exactly three sentences.
        Sentences are assumed to end with '.', '!', or '?'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains exactly three sentences, False otherwise.
        """
        sentences = re.split('[.!?]+', value)
        valid_sentences = [sentence for sentence in sentences if sentence.strip()]
        return len(valid_sentences) == 3



class DataIdx1147InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1147')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1147.

        Constraints:
        - Exactly 6 steps.
        - Each step should ideally start with an imperative verb (difficult to check programmatically without NLP).
        - The starting verbs (or at least the first words) of each step should be different.

        Args:
            value: A string representing the response (Arabic instructions).

        Returns:
            True if the response follows the instruction, False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = [line.strip() for line in value.splitlines() if line.strip()]
        if len(lines) != 6:
            return False
        first_words = []
        for line in lines:
            words = line.split(maxsplit=1)
            if not words:
                return False
            first_word = words[0]
            first_words.append(first_word)
        if len(set(first_words)) != 6:
            return False
        return True



class DataIdx1148InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1148')

    def check_following(self, value):
        """Checks if the response consists of exactly five sentences.

        Args:
            value: A string representing the response.

        Returns:
            True if the response has exactly five sentences, False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentence_endings = re.findall('[.!?؟](?=\\s*|$)', value)
        return len(sentence_endings) == 5



class DataIdx1149InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1149')

    def check_following(self, value):
        """Checks if the response starts with 'نعم' or 'لا' followed by
        an explanation of no more than 15 words.
        """
        if not isinstance(value, str):
            return False
        trimmed_value = value.strip()
        prefix = None
        if trimmed_value.startswith('نعم'):
            prefix = 'نعم'
        elif trimmed_value.startswith('لا'):
            prefix = 'لا'
        else:
            return False
        prefix_len = len(prefix)
        explanation_start_idx = prefix_len
        separators = ',.:;!?"\'`'
        while explanation_start_idx < len(trimmed_value) and (trimmed_value[explanation_start_idx].isspace() or trimmed_value[explanation_start_idx] in separators):
            explanation_start_idx += 1
        explanation = trimmed_value[explanation_start_idx:]
        trimmed_explanation = explanation.strip()
        if not trimmed_explanation:
            return False
        words = trimmed_explanation.split()
        if len(words) > 15:
            return False
        return True



class DataIdx1150InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1150')

    def check_following(self, value):
        """Checks if the response follows the constraints for question 1150.
        Constraints:
        - At least 7 words underlined with underscores (_word_).
        - No exclamation marks (!).
        - Short, rhyming, silly (not programmatically checked).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the detectable instructions, False otherwise.
        """
        if '!' in value:
            return False
        underlined_words = re.findall('_[^\\s_]+_', value)
        if len(underlined_words) < 7:
            return False
        return True



class DataIdx1151InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1151')

    def check_following(self, value):
        """Checks if the response (an Arabic paragraph) contains the word 'القراءة' at least three times.

        Args:
            value: A string representing the response (the Arabic paragraph).

        Returns:
            True if the word 'القراءة' appears at least 3 times, False otherwise.
        """
        target_word = 'القراءة'
        count = value.count(target_word)
        return count >= 3



class DataIdx1152InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1152')

    def check_following(self, value):
        """Checks if the response is a single sentence expressing gratitude using 'شكراً'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        if 'شكراً' not in value:
            return False
        sentence_enders = ['.', '!', '؟']
        terminator_count = sum((value.count(end) for end in sentence_enders))
        if terminator_count > 1:
            return False
        return True



class DataIdx1153InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1153')

    def check_following(self, value):
        """Checks if the response contains at least five gaps represented by '???'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains 5 or more occurrences of '???', False otherwise.
        """
        gap_marker = '???'
        gap_count = value.count(gap_marker)
        return gap_count >= 5



class DataIdx1154InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1154')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        ends_correctly = cleaned_value.endswith('مع خالص الاحترام.')
        contains_training = 'تدريب' in value
        uses_brackets = '[' in value and ']' in value
        return ends_correctly and contains_training and uses_brackets



class DataIdx1155InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1155')

    def check_following(self, value):
        """Checks if the response follows the instruction for IDX 1155.
        Constraints:
        1. Single sentence in imperative mood.
        2. Directed at a group (masculine plural).
        3. Encourage cooperation.
        4. Sentence must start with a plural masculine imperative verb.
        5. Must use the word 'معاً'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not value or not value.strip():
            return False
        cleaned_value = value.strip()
        if 'معاً' not in cleaned_value:
            return False
        terminators = ['.', '!', '?']
        if any((cleaned_value[i] in terminators for i in range(len(cleaned_value) - 1))):
            return False
        terminator_count = sum((cleaned_value.count(term) for term in terminators))
        if terminator_count > 1:
            return False
        words = cleaned_value.split(maxsplit=1)
        if not words:
            return False
        first_word = words[0]
        first_word = first_word.rstrip('.,!?;:،')
        if not first_word.endswith('وا'):
            return False
        return True



class DataIdx1156InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1156')

    def check_following(self, value):
        """
        Checks if the response is a short advice in Arabic, exactly two sentences, and not more than 20 words.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        arabic_char_pattern = re.compile('[\\u0600-\\u06FF]')
        if not arabic_char_pattern.search(cleaned_value):
            return False
        sentence_terminators_pattern = '[.!?]+'
        sentence_segments = [s.strip() for s in re.split(sentence_terminators_pattern, cleaned_value) if s.strip()]
        if len(sentence_segments) != 2:
            return False
        words = cleaned_value.split()
        word_count = len(words)
        if word_count > 20:
            return False
        return True



class DataIdx1157InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1157')

    def check_following(self, value):
        """Checks if the response summarizes the story in three lines without using proper nouns.

        Args:
            value: A string representing the response (summary).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.strip().split('\n')
        non_empty_lines = [line.strip() for line in lines if line.strip()]
        if len(non_empty_lines) != 3:
            return False
        forbidden_proper_nouns = ['شهريار', 'شهرزاد', 'علاء الدين', 'سندباد', 'علي بابا', 'هارون الرشيد', 'بغداد', 'فارس', 'الهند', 'الصين', 'قاسم', 'مرجانة', 'مصباح', 'الجن', 'العفريت']
        response_lower = value.lower()
        for noun in forbidden_proper_nouns:
            if noun.lower() in response_lower:
                return False
        return True



class DataIdx1158InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1158')

    def check_following(self, value):
        """Checks if the response mentions the word "الكتاب" at least three times.

        Args:
            value: A string representing the response.

        Returns:
            True if the word "الكتاب" appears 3 or more times, False otherwise.
        """
        count_kitab = value.count('الكتاب')
        return count_kitab >= 3



class DataIdx1159InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1159')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 1159.

        Constraints:
        1. The message must start with 'مرحباً'.
        2. The message must not exceed 50 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not value.strip().startswith('مرحباً'):
            return False
        words = value.split()
        word_count = len(words)
        if word_count > 50:
            return False
        return True



class DataIdx1160InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1160')

    def check_following(self, value):
        """Checks if the response contains three strings
           starting with 'ب', separated only by commas, with no spaces.
           Assumes the strings are intended to be Arab city names.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value:
            return False
        if any((c.isspace() for c in value)):
            return False
        parts = value.split(',')
        if len(parts) != 3:
            return False
        for part in parts:
            if not part:
                return False
            if not part.startswith('ب'):
                return False
        return True



class DataIdx1161InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1161')

    def check_following(self, value):
        """Checks if the response is a positive movie review with more than 70 words.

        Args:
            value: A string representing the response (the movie review).

        Returns:
            True if the review has more than 70 words, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return word_count > 70



class DataIdx1162InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1162')

    def check_following(self, value):
        """Checks if the response does not contain the word 'القراءة'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain the word 'القراءة', False otherwise.
        """
        forbidden_word = 'القراءة'
        return forbidden_word not in value



class DataIdx1163InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1163')

    def check_following(self, value):
        """Checks if the response is exactly 200 words.
        Args:
            value: A string representing the response.

        Returns:
            True if the response is exactly 200 words, False otherwise.
        """
        words = value.split()
        word_count = len(words)
        return word_count == 200



class DataIdx1164InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1164')

    def check_following(self, value):
        """Checks if the response includes both a book title and an author's name within a short paragraph.
        Uses a heuristic: checks for the presence of at least two distinct multi-word
        sequences that are not composed primarily of common Arabic stop words or punctuation.
        Also checks for a minimum response length (meaningful word count) to qualify as a "short paragraph".

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not value or not isinstance(value, str) or len(value.strip()) < 10:
            return False
        stop_words = set(['من', 'في', 'على', 'إلى', 'عن', 'ب', 'ل', 'ك', 'و', 'ف', 'ال', 'هو', 'هي', 'هم', 'هن', 'أنا', 'نحن', 'أنت', 'أنتم', 'أنتِ', 'أنتن', 'هذا', 'هذه', 'ذلك', 'تلك', 'هذان', 'هاتان', 'أولاء', 'أولئك', 'الذي', 'التي', 'الذين', 'اللاتي', 'اللائي', 'اللذان', 'اللتان', 'كان', 'يكون', 'كن', 'كانت', 'صار', 'يصير', 'أصبح', 'يصبح', 'أضحى', 'يضحي', 'أمسى', 'يمسي', 'ظل', 'يظل', 'بات', 'يبيت', 'مازال', 'مايزال', 'مابرح', 'مايبرح', 'ماانفك', 'ماينفك', 'مافتئ', 'مايفتأ', 'مادام', 'قد', 'سوف', 'لم', 'لن', 'لا', 'ما', 'كيف', 'أين', 'متى', 'هل', 'لماذا', 'ماذا', 'إذا', 'إذ', 'لو', 'لولا', 'لوما', 'أما', 'ألا', 'إن', 'أن', 'كأن', 'لكن', 'لعل', 'ليت', 'يا', 'أيا', 'هيا', 'أ', 'أي', 'غير', 'سوى', 'إلا', 'كل', 'بعض', 'نفس', 'عين', 'ذو', 'ذات', 'فقط', 'تم', 'يتم', 'يجب', 'ينبغي', 'يمكن', 'قد', 'ربما', 'عسى', 'حاشا', 'عدا', 'خلا', 'مذ', 'منذ', 'إلى', 'حتى', 'بما', 'مما', 'عما', 'فيما', 'إلام', 'علام', 'دون', 'فوق', 'تحت', 'أمام', 'خلف', 'يمين', 'شمال', 'داخل', 'خارج', 'حول', 'بين', 'لدى', 'عند', 'مثل', 'هيت', 'هلم', 'صه', 'مه', 'آمين', 'ليست', 'ليسوا', 'لست', 'لستن', 'لستم', 'لسنا'])
        punctuation_chars = set(string.punctuation + '،؛:.؟!«»()[]{}/\\')
        all_tokens = []
        current_word = ''
        for char in value:
            if char.isspace():
                if current_word:
                    all_tokens.append(current_word)
                current_word = ''
            elif char in punctuation_chars:
                if current_word:
                    all_tokens.append(current_word)
                current_word = ''
                all_tokens.append(char)
            else:
                current_word += char
        if current_word:
            all_tokens.append(current_word)
        candidate_sequences = []
        current_sequence_tokens = []
        for token in all_tokens:
            is_separator = token in punctuation_chars or token.lower() in stop_words
            if is_separator:
                if len(current_sequence_tokens) >= 2:
                    candidate_sequences.append(tuple((t.lower() for t in current_sequence_tokens)))
                current_sequence_tokens = []
            else:
                current_sequence_tokens.append(token)
        if len(current_sequence_tokens) >= 2:
            candidate_sequences.append(tuple((t.lower() for t in current_sequence_tokens)))
        distinct_sequences = set(candidate_sequences)
        has_two_distinct_sequences = len(distinct_sequences) >= 2
        words_for_count = value.split()
        non_stop_words_count = 0
        for word in words_for_count:
            cleaned_word = word.strip()
            if cleaned_word and cleaned_word.lower() not in stop_words:
                is_just_punctuation = all((char in punctuation_chars for char in cleaned_word))
                if not is_just_punctuation:
                    non_stop_words_count += 1
        min_meaningful_words = 12
        is_sufficient_length = non_stop_words_count >= min_meaningful_words
        return has_two_distinct_sequences and is_sufficient_length



class DataIdx1165InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1165')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        word_count = len([word for word in words if word])
        if word_count > 50:
            return False
        if 'قطة' in value:
            return False
        return True



class DataIdx1166InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1166')

    def check_following(self, value):
        """Checks if the response is a short dialogue about reading,
        titled 'حوار القراء', at most 8 lines long, using single quotes for dialogue.
        """
        if not isinstance(value, str):
            return False
        full_lines = value.split('\n')
        if len(full_lines) > 8:
            return False
        first_line_idx = -1
        for i, line in enumerate(full_lines):
            if line.strip():
                first_line_idx = i
                break
        if first_line_idx == -1:
            return False
        if full_lines[first_line_idx].strip() != 'حوار القراء':
            return False
        found_quoted_dialogue = False
        for i in range(first_line_idx + 1, len(full_lines)):
            line = full_lines[i]
            first_quote_idx = line.find("'")
            if first_quote_idx != -1:
                second_quote_idx = line.find("'", first_quote_idx + 1)
                if second_quote_idx != -1 and second_quote_idx > first_quote_idx + 1:
                    found_quoted_dialogue = True
                    break
        return found_quoted_dialogue



class DataIdx1167InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1167')

    def check_following(self, value):
        """Checks if the response is a non-empty Arabic string, different from the original sentence,
        and contains the word 'كريم' as a whole word, as a minimal check for attempting Tawriya
        based on the original sentence. A robust Tawriya check is complex and requires advanced NLP or human evaluation.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        if not any(('\u0600' <= c <= 'ۿ' for c in cleaned_value)):
            return False
        original_sentence = 'هو شخص كريم.'
        if cleaned_value == original_sentence:
            return False
        words_in_response = set(cleaned_value.replace('.', ' ').replace(',', ' ').replace('!', ' ').replace('?', ' ').replace(';', ' ').replace(':', ' ').split())
        if 'كريم' not in words_in_response:
            return False
        return True



class DataIdx1168InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1168')

    def check_following(self, value):
        """Checks if the response is a paragraph in Arabic about the importance of education,
           uses the word 'التعليم' at least twice, and exceeds 60 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        keyword_count = value.count('التعليم')
        if keyword_count < 2:
            return False
        words = value.split()
        word_count = len(words)
        if word_count <= 60:
            return False
        return True



class DataIdx1169InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1169')

    def check_following(self, value):
        """Checks if the response consists of exactly two paragraphs separated by double newlines.

        Args:
            value: A string representing the response.

        Returns:
            True if the response has exactly two paragraphs, False otherwise.
        """
        if not isinstance(value, str):
            return False
        paragraphs = value.strip().split('\n\n')
        valid_paragraphs = [para.strip() for para in paragraphs if para.strip()]
        return len(valid_paragraphs) == 2



class DataIdx1170InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1170')

    def check_following(self, value):
        """Checks if the response is a single sentence about respecting the elderly
           and contains at least one exclamation mark, based on structural heuristics.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if '!' not in value:
            return False
        if '\n' in value or ';' in value:
            return False
        terminal_punctuations = ['.', '!', '?']
        punctuation_count = sum((value.count(p) for p in terminal_punctuations))
        if punctuation_count != 1:
            return False
        trimmed_value = value.rstrip()
        if not trimmed_value.endswith(tuple(terminal_punctuations)):
            return False
        return True



class DataIdx1171InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1171')

    def check_following(self, value):
        """Checks if the response is a two-paragraph text where the second paragraph starts with 'ختامًا'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        paragraphs = value.split('\n\n')
        if len(paragraphs) != 2:
            return False
        second_paragraph = paragraphs[1]
        stripped_second_paragraph = second_paragraph.strip()
        required_start_word = 'ختامًا'
        if not stripped_second_paragraph:
            return False
        if stripped_second_paragraph.startswith(required_start_word):
            return True
        else:
            return False



class DataIdx1172InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1172')

    def check_following(self, value):
        """Checks if the response is a single question starting with 'لماذا' about environmental pollution.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        if not stripped_value.startswith('لماذا'):
            return False
        if not stripped_value.endswith('؟'):
            return False
        if stripped_value.count('؟') != 1:
            return False
        return True







class DataIdx1174InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1174')

    def check_following(self, value):
        """Checks if the response follows the constraints:
        - Contains 'شكراً'.
        - Contains 'ممتن'.
        - Is not more than 15 words.
        Assumes a single sentence if these conditions are met within the word limit.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        contains_shukran = 'شكراً' in value
        contains_mumtan = 'ممتن' in value
        words = value.strip().split()
        word_count = len(words)
        is_under_word_limit = word_count <= 15
        return contains_shukran and contains_mumtan and is_under_word_limit



class DataIdx1175InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1175')
        self.expected_normalized_answer = self._normalize_arabic_sentence('تُقرَأُ الكتبُ في المكتبةِ')

    def _remove_arabic_diacritics(self, text):
        """Removes Arabic diacritics (tashkeel) from a string."""
        diacritics_pattern = re.compile('[\\u064B-\\u0652]')
        return diacritics_pattern.sub('', text)

    def _normalize_whitespace(self, text):
        """Replaces multiple spaces with a single space and strips leading/trailing whitespace."""
        text = re.sub('\\s+', ' ', text)
        return text.strip()

    def _normalize_arabic_sentence(self, sentence):
        """Normalizes an Arabic sentence by removing diacritics and normalizing whitespace."""
        sentence = self._remove_arabic_diacritics(sentence)
        sentence = self._normalize_whitespace(sentence)
        return sentence

    def check_following(self, value):
        """Checks if the response is the correct passive voice transformation of the original sentence.

        Args:
            value: A string representing the student's response.

        Returns:
            True if the response is the correct passive transformation (after normalization),
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        normalized_value = self._normalize_arabic_sentence(value)
        return normalized_value == self.expected_normalized_answer



class DataIdx1176InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1176')

    def check_following(self, value):
        """Checks if the response is a single Arabic sentence prohibiting someone from lying,
        starting with 'لا' الناهية.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        starts_with_la = cleaned_value.startswith('لا')
        contains_lying_term = 'كذب' in cleaned_value
        return starts_with_la and contains_lying_term



class DataIdx1177InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1177')

    def check_following(self, value):
        """Checks if the response contains the word 'موافقة' at least twice.

        Args:
            value: A string representing the response (email content).

        Returns:
            True if 'موافقة' appears 2 or more times, False otherwise.
        """
        word_to_find = 'موافقة'
        count = value.count(word_to_find)
        return count >= 2



class DataIdx1178InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1178')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 1178.
        Constraints:
        1. Must contain the word 'مشروبات'.
        2. Must be a single sentence explanation (interpreted as ending with '.', '!', or '?'
           and containing exactly one such mark in total).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        required_word = 'مشروبات'
        if required_word not in value:
            return False
        terminal_punctuation = {'.', '!', '?'}
        stripped_value = value.rstrip()
        if not stripped_value:
            return False
        last_char = stripped_value[-1]
        if last_char not in terminal_punctuation:
            return False
        punctuation_count = sum((value.count(p) for p in terminal_punctuation))
        if punctuation_count != 1:
            return False
        return True



class DataIdx1179InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1179')

    def check_following(self, value):
        """Checks if the response is a single CSV line with three fields (Name, Age, City)
        and if the City field contains the word 'الرياض'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if '\n' in value:
            return False
        fields = value.split(',')
        if len(fields) != 3:
            return False
        city_field = fields[2].strip()
        if 'الرياض' not in city_field:
            return False
        return True



class DataIdx1180InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1180')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        value = value.strip()
        if not value:
            return False
        words = value.split()
        MAX_WORDS = 70
        if len(words) > MAX_WORDS:
            return False
        if not words:
            return False
        first_word = words[0]
        imperative_verbs = {'تعلم', 'ابدأ', 'اقرأ', 'اكتب', 'اسمع', 'تكلم', 'استمع', 'شاهد', 'مارس', 'استخدم', 'ركز', 'كرر', 'احفظ', 'تفاعل', 'شارك', 'واظب', 'داوم', 'ابحث', 'استشر', 'استمر', 'اذهب', 'زر', 'حاول', 'اجعل', 'تأكد', 'صحح', 'راجع', 'فكر', 'خطط', 'نظم', 'نوع', 'ثابر', 'تصفح', 'استعن', 'اسال', 'اجب', 'انتبه', 'احذر', 'اعرف', 'فهم', 'تتبع', 'ركز', 'احسن', 'اطبق', 'خذ', 'اعط', 'لاحظ', 'قارن', 'حلل'}

        def clean_arabic_word_manual(word):
            diacritics = ['َ', 'ُ', 'ِ', 'ْ', 'ّ', 'ً', 'ٌ', 'ٍ']
            cleaned_word = word
            for d in diacritics:
                cleaned_word = cleaned_word.replace(d, '')
            cleaned_word = cleaned_word.rstrip('.,!?;:')
            return cleaned_word
        cleaned_first_word = clean_arabic_word_manual(first_word)
        if cleaned_first_word not in imperative_verbs:
            return False
        return True



class DataIdx1181InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1181')

    def check_following(self, value):
        """Checks if the response is in exactly 3 bullet points and does not exceed 50 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count > 50:
            return False
        lines = value.strip().split('\n')
        bullet_markers = ['*', '-', '•']
        non_empty_lines = [line.strip() for line in lines if line.strip()]
        bullet_lines = []
        non_bullet_lines = []
        for line in non_empty_lines:
            is_bullet = False
            for marker in bullet_markers:
                if line.startswith(marker):
                    is_bullet = True
                    break
            if is_bullet:
                bullet_lines.append(line)
            else:
                non_bullet_lines.append(line)
        if len(bullet_lines) != 3:
            return False
        if len(non_bullet_lines) > 0:
            return False
        return True



class DataIdx1182InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1182')

    def check_following(self, value):
        """Checks if the response is a story exceeding 150 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response exceeds 150 words, False otherwise.
        """
        words = value.split()
        return len(words) > 150



class DataIdx1183InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1183')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1183.
        - Does not exceed 30 words.
        - Contains at least one exclamation mark (!).

        Args:
            value: A string representing the response (advertisement).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        word_count_ok = word_count <= 30
        has_exclamation = '!' in value
        return word_count_ok and has_exclamation



class DataIdx1184InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1184')

    def check_following(self, value):
        """Checks if the response follows the constraints: max 3 sentences, no commas.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if ',' in value:
            return False
        terminal_punctuation = '[.?!؟]'
        sentences = [s for s in re.split(terminal_punctuation, value) if s.strip()]
        sentence_count = len(sentences)
        if sentence_count > 3:
            return False
        return True



class DataIdx1185InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1185')

    def check_following(self, value):
        """Checks if the response follows the constraints for question 1185.
        Constraints:
        1. No punctuation except a full stop at the end.
        2. The word 'العربية' must appear at least 3 times.
        """
        try:
            arabic_word_count = len(re.findall('\\bالعربية\\b', value))
            if arabic_word_count < 3:
                return False
        except ImportError:
            pass
        forbidden_punctuation_chars = set('!"#$%&\'()*+,-/:;<=>?@[\\]^_`{|}~' + '،؛؟')
        cleaned_value = value.rstrip()
        if not cleaned_value.endswith('.'):
            return False
        text_before_dot = cleaned_value[:-1]
        for char in text_before_dot:
            if char in forbidden_punctuation_chars:
                return False
            if char == '.':
                return False
        return True



class DataIdx1186InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1186')

    def check_following(self, value):
        """Checks if the response is an Arabic slogan consisting of exactly three words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is a string with exactly three words, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        return len(words) == 3



class DataIdx1187InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1187')

    def check_following(self, value):
        """Checks if the response follows the instructions for question IDX 1187.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        has_question_mark = '?' in value
        required_ending = 'ننتظركم بفارغ الصبر.'
        ends_correctly = value.strip().endswith(required_ending)
        first_person_pronouns = ['أنا', 'نحن', 'لي', 'لنا']
        pattern = '\\b(' + '|'.join(first_person_pronouns) + ')\\b'
        contains_first_person = bool(re.search(pattern, value))
        no_first_person = not contains_first_person
        has_name_indicator = any((indicator in value for indicator in ['يا ', 'عزيزي ', 'صديقي ']))
        has_date_indicator = bool(re.search('\\d', value)) or any((keyword in value for keyword in ['يوم', 'تاريخ', 'ساعة', 'وقت', 'مساء', 'صباح', 'ظهرا', 'ليلا']))
        has_location_indicator = any((keyword in value for keyword in ['مكان', 'في ', 'عنوان', 'المنزل', 'القاعة', 'البيت', 'الموقع', 'بالقاعة', 'بالمنزل', 'بالبيت']))
        has_all_elements = has_name_indicator and has_date_indicator and has_location_indicator
        return has_question_mark and ends_correctly and no_first_person and has_all_elements



class DataIdx1188InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1188')

    def check_following(self, value):
        """Checks if the response is a single sentence using 'نجاح' and 'مشترك' about cooperation.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        cleaned_value = value.strip()
        has_نجاح = 'نجاح' in cleaned_value or 'النجاح' in cleaned_value
        has_مشترك = 'مشترك' in cleaned_value or 'المشترك' in cleaned_value
        if not has_نجاح or not has_مشترك:
            return False
        sentence_terminators = ['.', '!', '?']
        terminator_count = sum((cleaned_value.count(term) for term in sentence_terminators))
        if terminator_count > 1:
            return False
        if len(cleaned_value.replace(' ', '')) < 15:
            pass
        return True



class DataIdx1189InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1189')

    def check_following(self, value):
        """Checks if the response is a brief description of a historical landmark in Arabic,
        with word count between 120 and 250, and 'م' appears at least 45 times.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if not 120 <= word_count <= 250:
            return False
        mim_count = value.count('م')
        if not mim_count >= 45:
            return False
        return True



class DataIdx1190InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1190')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.splitlines()
        if len(lines) != 6:
            return False
        if not lines[0].strip().startswith('بداية'):
            return False
        return True



class DataIdx1191InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1191')

    def check_following(self, value):
        """Checks if the response is one imperative sentence with one imperative verb.
        Uses pragmatic heuristics for sentence structure and imperative verb identification.
        Accuracy is limited by the lack of full Arabic NLP parsing.
        """
        if not value or not value.strip():
            return False
        cleaned_value = value.strip()
        terminators = ['.', '!', '?']
        terminator_count = sum((cleaned_value.count(t) for t in terminators))
        if terminator_count > 1:
            return False
        if '?' in cleaned_value:
            return False
        arabic_letters_pattern = '[\\u0621-\\u063A\\u0641-\\u064A]'
        imperative_heuristic_pattern = re.compile(f'\\b(?:ا{arabic_letters_pattern}{{2}}|أ{arabic_letters_pattern}{{2}}|ت{arabic_letters_pattern}{{3}}|است{arabic_letters_pattern}{{2,3}})\\b')
        matches = imperative_heuristic_pattern.findall(cleaned_value)
        if len(matches) != 1:
            return False
        return True



class DataIdx1192InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1192')

    def check_following(self, value):
        """Checks if the response follows the instruction not to use any parentheses.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (no parentheses), False otherwise.
        """
        if '(' in value or ')' in value:
            return False
        return True



class DataIdx1193InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1193')

    def check_following(self, value):
        """Checks if each non-empty line (after stripping whitespace) ends with exactly one question mark.

        Args:
            value: A string representing the response (the poem).

        Returns:
            True if all non-empty lines end with a single question mark, False otherwise.
        """
        lines = value.splitlines()
        for line in lines:
            stripped_line = line.strip()
            if stripped_line:
                if not stripped_line.endswith('?'):
                    return False
                if len(stripped_line) > 1 and stripped_line[-2] == '?':
                    return False
        return True



class DataIdx1194InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1194')

    def check_following(self, value):
        """Checks if the response contains at least two occurrences of text within square brackets.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        matches = re.findall('\\[.*?\\]', value)
        return len(matches) >= 2



class DataIdx1195InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1195')

    def check_following(self, value):
        """Checks if the response is either 'نعم' or 'لا' enclosed in single quotes and uses the word 'نعم' or 'لا' only once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        return value == "'نعم'" or value == "'لا'"



class DataIdx1196InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1196')

    def check_following(self, value):
        """Checks if the response contains two sentences separated by exactly three hash symbols (###).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if '###' not in value:
            return False
        parts = value.split('###')
        if len(parts) != 2:
            return False
        sentence1 = parts[0].strip()
        sentence2 = parts[1].strip()
        if not sentence1 or not sentence2:
            return False
        return True



class DataIdx1197InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1197')

    def check_following(self, value):
        """Checks if the response has three paragraphs separated by two newlines each and a total word count between 200 and 250.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        cleaned_value = value.strip()
        paragraphs = cleaned_value.split('\n\n')
        if len(paragraphs) != 3:
            return False
        for para in paragraphs:
            if not para.strip():
                return False
        words = cleaned_value.split()
        word_count = len(words)
        if not 200 <= word_count <= 250:
            return False
        return True



class DataIdx1198InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1198')

    def check_following(self, value):
        """Checks if the response is 'نعم', assuming the premise 'today is Sunday' is true.
        Args:
            value: A string representing the response.

        Returns:
            True if the response is 'نعم', False otherwise.
        """
        expected_response = 'نعم'
        return value == expected_response



class DataIdx1199InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1199')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1199.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not value.strip().startswith('تقرير اجتماع'):
            return False
        required_keywords = ['اجتماع', 'مناقشة', 'أهداف', 'خطة عمل', 'نتائج']
        for keyword in required_keywords:
            if keyword not in value:
                return False
        return True



class DataIdx1200InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1200')

    def check_following(self, value):
        """Checks if the response provides two reasons separated by '%'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        parts = value.split('%')
        if len(parts) != 2:
            return False
        reason1 = parts[0].strip()
        reason2 = parts[1].strip()
        if not reason1 or not reason2:
            return False
        return True



class DataIdx1201InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1201')

    def check_following(self, value):
        """Checks if the response contains more than 150 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response has more than 150 words, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return word_count > 150



class DataIdx1202InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1202')

    def check_following(self, value):
        """Checks if the value contains at least two sentences,
        each consisting of at least 18 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        text = value.strip()
        if not text:
            return False
        temp_text = text.replace('.', '|').replace('!', '|').replace('؟', '|')
        potential_sentences = temp_text.split('|')
        sentences = [s.strip() for s in potential_sentences if s.strip()]
        if len(sentences) < 2:
            return False
        for sentence in sentences:
            words = sentence.split()
            if len(words) < 18:
                return False
        return True



class DataIdx1203InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1203')

    def check_following(self, value):
        """Checks if the response follows the instructions: two verses (four lines) about spring,
        with a unified rhyme (last two characters of the last word in each line are identical).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.splitlines()
        if len(lines) != 4:
            return False
        last_words = []
        for line in lines:
            stripped_line = line.strip()
            if not stripped_line:
                return False
            words = stripped_line.split()
            if not words:
                return False
            last_word = words[-1]
            last_words.append(last_word)
        if len(last_words) != 4:
            return False
        for word in last_words:
            if len(word) < 2:
                return False
        rhyme_ending = last_words[0][-2:]
        for i in range(1, 4):
            if last_words[i][-2:] != rhyme_ending:
                return False
        return True



class DataIdx1204InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1204')

    def check_following(self, value):
        """Checks if the response is a short mint tea recipe in exactly three numbered steps,
           numbered 1, 2, 3 in order, each starting with a common Arabic imperative verb.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.splitlines()
        expected_prefixes = {1: ('1.', '١.'), 2: ('2.', '٢.'), 3: ('3.', '٣.')}
        imperative_verbs = {'أضف', 'ضع', 'اسكب', 'صب', 'اغلِ', 'اغلي', 'اترك', 'قدم', 'استخدم', 'جهز', 'اغسل', 'قطع', 'ضعوا', 'أضيفوا', 'اسكبوا', 'صبوا', 'اغلوا', 'اتركوا', 'قدموا', 'استخدموا', 'جهزوا', 'اغسلوا', 'قطعوا', 'خذ', 'خذوا', 'صَفِّ', 'صَفّوا', 'سخّن', 'سخّنوا', 'زين', 'زينوا', 'أغلق', 'أغلقوا', 'افتح', 'افتحوا', 'انتظر', 'انتظروا', 'حرك', 'حركوا', 'غطِ', 'غطوا', 'انزع', 'انزعوا', 'كسر', 'كسروا', 'اهرِس', 'اهرِسوا', 'عصر', 'اعصروا'}
        current_expected_step = 1
        for line in lines:
            trimmed_line = line.strip()
            if not trimmed_line:
                continue
            if current_expected_step > 3:
                return False
            is_correct_step_prefix = False
            prefix_end_index = 0
            if current_expected_step in expected_prefixes:
                for prefix in expected_prefixes[current_expected_step]:
                    if trimmed_line.startswith(prefix):
                        idx_after_prefix = len(prefix)
                        while idx_after_prefix < len(trimmed_line) and trimmed_line[idx_after_prefix].isspace():
                            idx_after_prefix += 1
                        if idx_after_prefix < len(trimmed_line):
                            is_correct_step_prefix = True
                            prefix_end_index = idx_after_prefix
                            break
            if not is_correct_step_prefix:
                return False
            rest_of_line = trimmed_line[prefix_end_index:]
            if not rest_of_line:
                return False
            first_word = rest_of_line.split(maxsplit=1)[0]
            if first_word not in imperative_verbs:
                return False
            current_expected_step += 1
        return current_expected_step == 4



class DataIdx1205InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1205')

    def check_following(self, value):
        """Checks if the response is a question using only question marks and no other punctuation.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value:
            return False
        arabic_question_mark = '؟'
        if arabic_question_mark not in value:
            return False
        forbidden_punctuation = {'.', ',', ';', ':', '!', '"', "'", '(', ')', '[', ']', '{', '}', '<', '>', '-', '—', '…', '/', '\\', '|', '~', '_', '#', '$', '%', '&', '*', '+', '=', '@', '^', '«', '»', '„', '‟', '‹', '›', '?'}
        for char in value:
            if char in forbidden_punctuation:
                return False
        return True



class DataIdx1206InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1206')

    def check_following(self, value):
        """
        Checks if the response describes a city in one sentence and does not use the word 'جميل'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if 'جميل' in value:
            return False
        sentence_terminators = ['.', '!', '?']
        terminator_count = sum((value.count(term) for term in sentence_terminators))
        if terminator_count != 1:
            return False
        cleaned_value = value.rstrip()
        if not cleaned_value or cleaned_value[-1] not in sentence_terminators:
            return False
        return True



class DataIdx1207InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1207')

    def check_following(self, value):
        """Checks if the response is a single sentence ending with punctuation.
        It does not check for the presence of antonyms as that requires semantic analysis
        beyond the scope of a simple structural check.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        if not stripped_value:
            return False
        sentence_endings = ['.', '!', '?']
        if not any((stripped_value.endswith(end) for end in sentence_endings)):
            return False
        count = sum((stripped_value.count(end) for end in sentence_endings))
        if count == 1:
            return True
        else:
            return False



class DataIdx1208InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1208')

    def check_following(self, value):
        """Checks if the response is a single formal question asking for the current time, starting with 'كم'.

        Args:
            value: A string representing the response (the student's question).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        cleaned_value = value.strip()
        if not cleaned_value.startswith('كم'):
            return False
        if not cleaned_value.endswith('؟'):
            return False
        if cleaned_value.count('؟') != 1:
            return False
        if 'الساعة' not in cleaned_value and 'الوقت' not in cleaned_value:
            return False
        return True



class DataIdx1209InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1209')

    def check_following(self, value):
        """Checks if the response mentions three items using 'أو' once and 'و' once in a structure implying three items.
        Cannot verify if the items are fruits without external data.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction regarding conjunction usage for three items, False otherwise.
        """
        if not isinstance(value, str):
            return False
        normalized_value = ' '.join(value.split())
        or_count = normalized_value.count('أو')
        and_count = normalized_value.count('و')
        return or_count == 1 and and_count == 1



class DataIdx1210InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1210')

    def check_following(self, value):
        """Checks if the response is a short paragraph about the importance of Arabic language and does not exceed 50 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        words = cleaned_value.split()
        word_count = len(words)
        return word_count <= 50



class DataIdx1211InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1211')

    def check_following(self, value):
        """Checks if the response is a brief description, expected to be in Arabic.

        Args:
            value: A string representing the response.

        Returns:
            True if the response appears brief and contains significant Arabic text, False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        words = value.split()
        word_count = len(words)
        max_words = 200
        if word_count > max_words:
            return False
        arabic_char_count = 0
        for char in value:
            if 1536 <= ord(char) <= 1791:
                arabic_char_count += 1
        min_arabic_chars = 50
        if arabic_char_count < min_arabic_chars:
            return False
        return True



class DataIdx1212InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1212')

    def check_following(self, value):
        """Checks if the response follows the constraints:
        1. At least eight words long.
        2. Does not contain the word "سعيد".

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instructions, False otherwise.
        """
        words = value.split()
        word_count = len(words)
        min_word_count_met = word_count >= 8
        forbidden_word = 'سعيد'
        forbidden_word_not_present = forbidden_word not in value
        return min_word_count_met and forbidden_word_not_present



class DataIdx1213InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1213')

    def check_following(self, value):
        """Checks if the response string contains at least 6 sentences, indicated by . ! or ?

        Args:
            value: A string representing the response.

        Returns:
            True if the response has at least 6 sentences, False otherwise.
        """
        if not isinstance(value, str):
            return False
        value_normalized = value.replace('!', '.').replace('?', '.')
        sentences = value_normalized.split('.')
        non_empty_sentences = [s.strip() for s in sentences if s.strip()]
        return len(non_empty_sentences) >= 6



class DataIdx1214InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1214')

    def check_following(self, value):
        """Checks if the response contains a list with exactly three items,
        formatted as either bullet points or a numbered list.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains a list with 3 items, False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        lines = value.strip().splitlines()
        item_count = 0
        bullet_pattern = re.compile('^\\s*[\\-\\*\\+•●○▪▫]\\s+')
        numbered_pattern = re.compile('^\\s*[\\d\\u0660-\\u0669]+\\.\\s+')
        for line in lines:
            if not line.strip():
                continue
            if bullet_pattern.match(line) or numbered_pattern.match(line):
                item_count += 1
        return item_count == 3



class DataIdx1215InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1215')

    def check_following(self, value):
        """Checks if the response is a numbered list of exactly three items,
        where each item starts with the word 'قلعة'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().splitlines()
        potential_items_text = []
        item_pattern = re.compile('^\\s*\\d+\\s*[\\.\\)-]\\s*(.*)$')
        for line in lines:
            match = item_pattern.match(line.strip())
            if match:
                item_text = match.group(1).strip()
                potential_items_text.append(item_text)
        if len(potential_items_text) != 3:
            return False
        for item_text in potential_items_text:
            if not item_text.startswith('قلعة'):
                return False
        return True



class DataIdx1216InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1216')

    def check_following(self, value):
        """Checks if the response (an email inviting a friend to a party) is in Arabic and uses no more than two English words.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (uses <= 2 English words), False otherwise.
            Note: This checker focuses only on the quantifiable constraint (number of English words).
            It does not check for "short" or if it's truly an email or an invitation in Arabic content.
        """
        english_word_pattern = re.compile('[a-zA-Z]+')
        english_words_found = english_word_pattern.findall(value)
        num_english_words = len(english_words_found)
        return num_english_words <= 2



class DataIdx1217InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1217')

    def check_following(self, value):
        """Checks if the response is an Arabic summary and mentions the author (via keywords).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        value = value.strip()
        total_char_count = len(value)
        if total_char_count == 0:
            return False
        arabic_char_count = 0
        arabic_ranges = [(1536, 1791), (1872, 1919), (2208, 2303), (64336, 65023), (65136, 65279)]
        for char in value:
            char_code = ord(char)
            for start, end in arabic_ranges:
                if start <= char_code <= end:
                    arabic_char_count += 1
                    break
        min_arabic_chars_for_summary = 80
        percentage_threshold = 75
        if arabic_char_count < min_arabic_chars_for_summary:
            return False
        if total_char_count > arabic_char_count:
            if arabic_char_count / total_char_count * 100 < percentage_threshold:
                return False
        author_keywords = ['المؤلف', 'مؤلف', 'الكاتب', 'كاتب', 'تأليف', 'بقلم', 'اسم المؤلف']
        author_mentioned = False
        for keyword in author_keywords:
            if keyword in value:
                author_mentioned = True
                break
        if not author_mentioned:
            return False
        return True



class DataIdx1218InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1218')

    def check_following(self, value):
        """Checks if the response is a dialogue about time management between a student and teacher,
           includes advice from the teacher, and is at least six lines long.
        """
        if not isinstance(value, str):
            return False
        lines = [line.strip() for line in value.split('\n') if line.strip()]
        if len(lines) < 6:
            return False
        theme_keywords = ['وقت', 'تنظيم', 'إدارة', 'مهم', 'ضروري', 'فوائد', 'جدول', 'تخطيط']
        theme_present = any((keyword in value for keyword in theme_keywords))
        if not theme_present:
            return False
        advice_phrases = ['يجب أن', 'ينبغي أن', 'أنصحك ب', 'عليك أن', 'حاول أن', 'نظم وقتك', 'تنظيم وقتك', 'خطط ليومك', 'تخطيط ليومك', 'استغل وقتك', 'استغلال الوقت', 'قسّم مهامك', 'تقسيم المهام', 'ضع جدول', 'وضع جدول', 'عمل جدول']
        advice_present = any((phrase in value for phrase in advice_phrases))
        if not advice_present:
            return False
        return True



class DataIdx1219InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1219')

    def check_following(self, value):
        """Checks if the response uses the word 'لذيذ' at least twice.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        delicious_count = value.count('لذيذ')
        return delicious_count >= 2



class DataIdx1220InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1220')

    def check_following(self, value):
        """
        Checks if the response is a single Arabic imperative sentence urging
        someone to exercise regularly.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction, False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        sentence_terminators = ['.', '!', '؟']
        ends_with_terminator = any((cleaned_value.endswith(term) for term in sentence_terminators))
        if not ends_with_terminator:
            return False
        last_terminator_start_index = len(cleaned_value)
        for i in range(len(cleaned_value) - 1, -1, -1):
            if cleaned_value[i] in sentence_terminators:
                last_terminator_start_index = i
            else:
                break
        if any((char in sentence_terminators for char in cleaned_value[:last_terminator_start_index])):
            return False
        exercise_keywords = ['رياضة', 'تمرن', 'مارس', 'تريض', 'تحرك']
        regularity_keywords = ['بانتظام', 'دائماً', 'مستمر', 'يومياً', 'اسبوعياً', 'كل يوم', 'كل أسبوع']
        has_exercise_keyword = any((keyword in cleaned_value for keyword in exercise_keywords))
        has_regularity_keyword = any((keyword in cleaned_value for keyword in regularity_keywords))
        if not has_exercise_keyword or not has_regularity_keyword:
            return False
        return True



class DataIdx1221InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1221')
        self.copulative_verbs = ['كان', 'صار', 'أصبح', 'أضحى', 'أمسى', 'ظل', 'بات', 'ليس', 'ما زال', 'ما برح', 'ما فتئ', 'ما انفك', 'ما دام']

    def check_following(self, value):
        """Checks if the response describes Cairo in exactly two short sentences (<=10 words each)
           and does not use specified copulative verbs.

        Args:
            value: A string representing the student's response.

        Returns:
            True if the response follows all instructions, False otherwise.
        """
        temp_value = value.replace('!', '.').replace('?', '.')
        potential_sentences = temp_value.split('.')
        sentences = [s.strip() for s in potential_sentences if s.strip()]
        if len(sentences) != 2:
            return False
        for sentence in sentences:
            cleaned_sentence_for_word_count = re.sub('[،؛:,.!?-]', '', sentence)
            words = cleaned_sentence_for_word_count.split()
            if len(words) > 10:
                return False
            for verb in self.copulative_verbs:
                if re.search('\\b' + re.escape(verb) + '\\b', sentence):
                    return False
        return True



class DataIdx1222InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1222')

    def check_following(self, value):
        """Checks if the response starts with 'السيد المدير', ends with 'مع خالص التقدير', and avoids semicolons.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        starts_correctly = value.strip().startswith('السيد المدير')
        ends_correctly = value.strip().endswith('مع خالص التقدير')
        contains_semicolon = ';' in value
        return starts_correctly and ends_correctly and (not contains_semicolon)



class DataIdx1223InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1223')

    def check_following(self, value):
        """Checks if the response lists five renewable energy sources
        in a numbered list (1-5), where each item starts with
        "من مصادر الطاقة المتجددة", and the total response is exactly 5 lines.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.splitlines()
        if len(lines) != 5:
            return False
        line_pattern = re.compile('^\\s*(\\d+)\\s*[\\.\\)]+\\s*(من مصادر الطاقة المتجددة.*)$')
        for i, line in enumerate(lines):
            match = line_pattern.match(line)
            if not match:
                return False
            try:
                item_number = int(match.group(1))
            except (ValueError, IndexError):
                return False
            if item_number != i + 1:
                return False
        return True



class DataIdx1224InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1224')

    def check_following(self, value):
        """Checks if the response contains the required words 'الوفاء' and 'الإخلاص'.
        It does not check for poetic structure or meaning about friendship,
        only the presence of the keywords as explicitly requested.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains both 'الوفاء' and 'الإخلاص', False otherwise.
        """
        if not isinstance(value, str):
            return False
        contains_alwafaa = 'الوفاء' in value
        contains_alekhlas = 'الإخلاص' in value
        return contains_alwafaa and contains_alekhlas



class DataIdx1225InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1225')

    def check_following(self, value):
        """Checks if each sentence in the response has at least 10 words.

        Args:
            value: A string representing the response (the complaint letter).

        Returns:
            True if every sentence has 10 or more words, False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        sentences = re.split('[.!?]+\\s*', value)
        for sentence in sentences:
            cleaned_sentence = sentence.strip()
            if not cleaned_sentence:
                continue
            words = re.split('\\s+', cleaned_sentence)
            actual_words = [word for word in words if word]
            word_count = len(actual_words)
            if word_count < 10:
                return False
        return True



class DataIdx1226InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1226')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        cleaned_value = cleaned_value.replace('؟', '.').replace('!', '.')
        while '..' in cleaned_value:
            cleaned_value = cleaned_value.replace('..', '.')
        sentences = [s.strip() for s in cleaned_value.split('.') if s.strip()]
        return len(sentences) == 3



class DataIdx1227InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1227')

    def check_following(self, value):
        """Checks if the response explains the process of making tea in no more than 70 words
        and does not contain any commas.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if ',' in value:
            return False
        words = value.split()
        word_count = len(words)
        if word_count > 70:
            return False
        return True



class DataIdx1228InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1228')

    def check_following(self, value):
        """Checks if the response is an accurate and concise English translation of 'القراءة غذاء الروح والعقل.'

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (accurate and concise translation in English) or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lower_value = value.lower()
        has_reading = 'read' in lower_value
        has_food_nourish = any((word in lower_value for word in ['food', 'nourish', 'sustenance']))
        has_soul_spirit = any((word in lower_value for word in ['soul', 'spirit']))
        has_mind = 'mind' in lower_value
        word_count = len(value.split())
        is_concise = word_count > 0 and word_count <= 12
        return has_reading and has_food_nourish and has_soul_spirit and has_mind and is_concise



class DataIdx1229InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1229')

    def check_following(self, value):
        """Checks if the response is exactly 5 non-empty lines, numbered 1. to 5. sequentially,
           each starting with a common Arabic imperative verb, and having content after the number.
           Note: The 'no abbreviations or slang' constraint is not checked programmatically
           due to the complexity of implementing a robust check without a specific lexicon or NLP tools."""
        if not isinstance(value, str):
            return False
        lines = [line.strip() for line in value.replace('\r\n', '\n').split('\n') if line.strip()]
        if len(lines) != 5:
            return False
        common_imperative_verbs = {'تناول', 'اشرب', 'نم', 'تمرن', 'استيقظ', 'اغسل', 'حافظ', 'تجنب', 'افحص', 'زر', 'مارس', 'قلل', 'زد', 'احصل', 'استخدم', 'مارسوا', 'قللوا', 'زيدوا', 'احصلوا', 'استخدموا', 'احرص', 'احرصوا', 'راقب', 'راقبوا', 'توقف', 'توقفوا', 'اختر', 'اختاروا', 'خطط', 'خططوا', 'احترم', 'احترموا', 'وازن', 'وازنوا', 'نظم', 'نظموا', 'امش', 'امشوا', 'تابع', 'تابعوا', 'استشر', 'استشيروا', 'ابتعد', 'ابتعدوا', 'تأمل', 'تأملوا', 'تنفس', 'تنفسوا', 'ركز', 'ركزوا', 'ابتسم', 'ابتسموا', 'تحدث', 'تحدثوا', 'استمع', 'استمعوا'}
        for i in range(5):
            line = lines[i]
            expected_prefix = f'{i + 1}.'
            if not line.startswith(expected_prefix):
                return False
            item_text = line[len(expected_prefix):].strip()
            if not item_text:
                return False
            words = item_text.split(maxsplit=1)
            if not words:
                return False
            first_word = words[0]
            while first_word and first_word[-1] in '.,!?;':
                first_word = first_word[:-1]
            if first_word not in common_imperative_verbs:
                return False
        return True



class DataIdx1230InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1230')

    def check_following(self, value):
        """Checks if the response is a definition of 'الذكاء الاصطناعي' in exactly two sentences and uses 'تكنولوجيا' at least once.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        value = value.strip()
        if not value:
            return False
        terminator_count = len(re.findall('[.!?]', value))
        if len(value) < 5:
            return False
        has_exactly_two_sentences = terminator_count == 2
        uses_technology_word = 'تكنولوجيا' in value
        return has_exactly_two_sentences and uses_technology_word



class DataIdx1231InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1231')

    def check_following(self, value):
        """Checks if the response is valid JSON, contains 5 items, and has "لذيذ" at least twice in string values.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        try:
            data = json.loads(value)
        except json.JSONDecodeError:
            return False
        if not isinstance(data, list) or len(data) != 5:
            return False
        delicious_count = 0
        for item in data:
            if isinstance(item, dict):
                for key, val in item.items():
                    if isinstance(val, str):
                        delicious_count += val.count('لذيذ')
            elif isinstance(item, str):
                delicious_count += item.count('لذيذ')
        if delicious_count < 2:
            return False
        return True



class DataIdx1232InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1232')

    def check_following(self, value):
        """Checks if the response follows the constraints for question 1232.
        Constraints:
        1. At least 3 sentences.
        2. Mentions the city name in the first sentence (heuristic check based on frequency).
        3. Uses the word 'جميلة' (beautiful) at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentences = re.split('[.!?]', value.strip())
        non_empty_sentences = [s for s in sentences if s.strip()]
        if len(non_empty_sentences) < 3:
            return False
        first_sentence_string = non_empty_sentences[0].strip()
        if not first_sentence_string:
            return False
        if 'جميلة' not in value:
            return False
        stop_words = set(['و', 'ف', 'ب', 'ل', 'ك', 'في', 'من', 'إلى', 'على', 'عن', 'ال', 'أن', 'إن', 'لا', 'لم', 'لن', 'قد', 'سوف', 'يجب', 'يمكن', 'كان', 'يكون', 'ليس', 'هذا', 'هذه', 'ذلك', 'تلك', 'الذي', 'التي', 'الذين', 'اللاتي', 'هما', 'هم', 'هن', 'أنا', 'نحن', 'أنت', 'أنتِ', 'أنتم', 'أنتن', 'هو', 'هي', 'إنه', 'أنها', 'أحب', 'أجمل', 'أكبر', 'أصغر', 'أفضل', 'رائع', 'جميل', 'كثير', 'جدا', 'فيه', 'فيها', 'له', 'لها', 'لي', 'لنا', 'عليه', 'عليها'])
        cleaned_text_arabic = re.sub('[^\\u0600-\\u06FF\\s]', '', value)
        words = cleaned_text_arabic.split()
        candidate_words = [word for word in words if len(word) > 2 and word not in stop_words and (word != 'مدينة') and (word != 'جميلة')]
        if not candidate_words:
            return False
        word_counts = Counter(candidate_words)
        most_frequent_items = word_counts.most_common(1)
        if not most_frequent_items:
            return False
        most_frequent_word, count = most_frequent_items[0]
        cleaned_first_sentence_arabic = re.sub('[^\\u0600-\\u06FF\\s]', '', first_sentence_string)
        first_sentence_words = cleaned_first_sentence_arabic.split()
        if most_frequent_word not in first_sentence_words:
            return False
        return True



class DataIdx1233InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1233')

    def check_following(self, value):
        """Checks if the response is an Arabic sentence that starts with 'إذا',
        ends with exactly one period, and has at most 22 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        starts_with_itha = cleaned_value.startswith('إذا')
        ends_with_period = cleaned_value.endswith('.')
        has_exactly_one_period = cleaned_value.count('.') == 1
        period_constraint_met = ends_with_period and has_exactly_one_period
        words = cleaned_value.split()
        word_count = len(words)
        word_count_met = word_count <= 22
        return starts_with_itha and period_constraint_met and word_count_met



class DataIdx1234InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1234')

    def check_following(self, value):
        """
        Checks if the response follows the instructions for IDX 1234.

        Instructions:
        1. Mention five types of fruit.
        2. Each word must be only one word (referring to the fruit names).
        3. End your list with the phrase 'هذه بعض الفواكه'.

        Args:
            value: A string representing the student's response.

        Returns:
            True if the response follows all instructions, False otherwise.
        """
        stripped_value = value.strip()
        ending_phrase = 'هذه بعض الفواكه'
        if not stripped_value.endswith(ending_phrase):
            return False
        if len(stripped_value) <= len(ending_phrase):
            return False
        list_part = stripped_value[:-len(ending_phrase)].strip()
        list_part_spaced = list_part.replace(',', ' ')
        items = list_part_spaced.split()
        if len(items) != 5:
            return False
        return True



class DataIdx1235InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1235')

    def check_following(self, value):
        """Checks if the response follows the instructions for question idx_1235.
        Specifically checks if it is a single sentence and contains the word 'التكنولوجيا'.
        (The third constraint 'describes its impact on our daily lives' is semantic
        and not programmatically checked by this function).

        Args:
            value: A string representing the response.

        Returns:
            True if the response meets the implemented constraints, False otherwise.
        """
        if not isinstance(value, str):
            return False
        contains_technology_word = 'التكنولوجيا' in value
        sentence_terminators = ['.', '!', '?']
        terminator_count = sum((value.count(term) for term in sentence_terminators))
        is_single_sentence = terminator_count <= 1
        return contains_technology_word and is_single_sentence



class DataIdx1236InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1236')

    def check_following(self, value):
        """Checks if the response is a single sentence about the importance of reading,
        containing the words 'القراءة' and 'تنمية', and formatted as a single sentence.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if 'القراءة' not in value or 'تنمية' not in value:
            return False
        terminal_punctuation = {'.', '!', '?'}
        punctuation_indices = [i for i, char in enumerate(value) if char in terminal_punctuation]
        if len(punctuation_indices) != 1:
            return False
        single_punct_index = punctuation_indices[0]
        stripped_value = value.rstrip()
        if not stripped_value or stripped_value[-1] != value[single_punct_index]:
            return False
        return True



class DataIdx1237InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1237')

    def check_following(self, value):
        """Checks if the response is a single sentence containing 'فرحة'.
        Constraints:
        1. Single sentence.
        2. Contains the word 'فرحة'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        stripped_value = value.strip()
        contains_farha = 'فرحة' in stripped_value
        is_single_line = '\n' not in stripped_value
        ends_with_punctuation = stripped_value.endswith('.') or stripped_value.endswith('!') or stripped_value.endswith('؟')
        is_not_empty = bool(stripped_value)
        is_single_sentence_format = is_single_line and ends_with_punctuation and is_not_empty
        return contains_farha and is_single_sentence_format



class DataIdx1238InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1238')

    def check_following(self, value):
        """Checks if the response (a paragraph) is within the word limit of 70 words.

        Args:
            value: A string representing the response paragraph in Arabic.

        Returns:
            True if the word count is 70 or less, False otherwise.
        """
        words = value.split()
        word_count = len(words)
        return word_count <= 70



class DataIdx1239InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1239')

    def check_following(self, value):
        """Checks if the response contains no punctuation marks.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains no punctuation, False otherwise.
        """
        punctuation_chars = '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~'
        for char in value:
            if char in punctuation_chars:
                return False
        return True



class DataIdx1240InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1240')

    def check_following(self, value):
        """Checks if the response follows the instruction by avoiding the word "تلوث".
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        forbidden_word = 'تلوث'
        return forbidden_word not in value



class DataIdx1241InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1241')

    def check_following(self, value):
        """Checks if the response mentions exactly one Arab country in Africa and
           exactly one Arab country in Asia, in a sentence using 'بينما'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        arab_countries_africa = {'الجزائر', 'جزر القمر', 'جيبوتي', 'مصر', 'ليبيا', 'موريتانيا', 'المغرب', 'الصومال', 'السودان', 'تونس'}
        arab_countries_asia = {'البحرين', 'العراق', 'الأردن', 'الكويت', 'لبنان', 'عمان', 'فلسطين', 'قطر', 'السعودية', 'سوريا', 'الإمارات', 'اليمن'}
        if 'بينما' not in value:
            return False
        found_african_countries = set()
        for country in arab_countries_africa:
            if country in value:
                found_african_countries.add(country)
        found_asian_countries = set()
        for country in arab_countries_asia:
            if country in value:
                found_asian_countries.add(country)
        if len(found_african_countries) != 1:
            return False
        if len(found_asian_countries) != 1:
            return False
        all_found_countries = found_african_countries.union(found_asian_countries)
        if len(all_found_countries) != 2:
            return False
        return True



class DataIdx1242InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1242')

    def check_following(self, value):
        """Checks if the response is a single word consisting of exactly three characters.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is a single word of length 3, False otherwise.
        """
        if not isinstance(value, str):
            return False
        if ' ' in value.strip():
            return False
        if len(value.strip()) != 3:
            return False
        if len(value.strip()) == 0:
            return False
        return True



class DataIdx1243InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1243')

    def check_following(self, value):
        """Checks if the response is a Markdown bulleted list based on the provided Arabic text."""
        expected_items = ['توفير بيئة تعليمية محفزة', 'تنمية مهارات التفكير النقدي', 'تشجيع الإبداع والابتكار', 'إعداد الطلاب لسوق العمل']
        lines = value.strip().split('\n')
        found_items = []
        bullet_chars = ['*', '-', '+']
        if not lines:
            return False
        for line in lines:
            stripped_line = line.strip()
            if not stripped_line:
                continue
            is_bullet = False
            bullet_text = ''
            for marker in bullet_chars:
                prefix = marker + ' '
                if stripped_line.startswith(prefix):
                    bullet_text = stripped_line[len(prefix):].strip()
                    is_bullet = True
                    break
                if stripped_line.startswith(marker):
                    if len(stripped_line) > len(marker) and stripped_line[len(marker)].isspace():
                        bullet_text = stripped_line[len(marker):].lstrip().strip()
                        is_bullet = True
                        break
            if not is_bullet:
                return False
            if bullet_text in expected_items:
                found_items.append(bullet_text)
            else:
                return False
        return set(found_items) == set(expected_items) and len(found_items) == len(expected_items)



class DataIdx1244InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1244')

    def check_following(self, value):
        """Checks if the response is a numbered list of 5 items, each starting with a verb, and containing 'الاسترخاء' exactly once."""
        lines = [line.strip() for line in value.strip().split('\n') if line.strip()]
        if len(lines) != 5:
            return False
        processed_lines = []
        for i in range(5):
            expected_prefix = f'{i + 1}.'
            line = lines[i]
            if not line.startswith(expected_prefix):
                return False
            item_content = line[len(expected_prefix):].strip()
            if not item_content:
                return False
            processed_lines.append(item_content)
        present_prefixes = ('أ', 'ن', 'ي', 'ت')
        for item in processed_lines:
            words = item.split()
            first_word = words[0]
            if not first_word.startswith(present_prefixes):
                return False
        all_items_text = ' '.join(processed_lines)
        relaxation_matches = re.findall('\\bالاسترخاء\\b', all_items_text)
        relaxation_count = len(relaxation_matches)
        if relaxation_count != 1:
            return False
        return True



class DataIdx1245InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1245')

    def check_following(self, value):
        """Checks if the response answers the question 'What is the capital of Saudi Arabia?'
        in a complete sentence in Arabic.

        Args:
            value: A string representing the response (student's answer).

        Returns:
            True if the response follows the instruction (is a complete sentence,
            contains the correct answer 'الرياض', and mentions 'عاصمة') or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        contains_riyadh = 'الرياض' in cleaned_value
        contains_capital = 'عاصمة' in cleaned_value or 'العاصمة' in cleaned_value
        if not (contains_riyadh and contains_capital):
            return False
        ends_with_punctuation = cleaned_value.endswith('.') or cleaned_value.endswith('!') or cleaned_value.endswith('؟')
        is_reasonably_long = len(cleaned_value) > 15
        if not (ends_with_punctuation and is_reasonably_long):
            if ends_with_punctuation and ' ' not in cleaned_value:
                return False
            return False
        return True



class DataIdx1246InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1246')

    def check_following(self, value):
        """Checks if the response follows the constraints for question 1246.
        Constraints:
        - Less than 40 words.
        - Does not use the word 'العربية'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if 'العربية' in value:
            return False
        words = value.split()
        if len(words) >= 40:
            return False
        return True



class DataIdx1247InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1247')
        self.visual_keywords = {'يرى', 'رؤية', 'منظر', 'ألوان', 'ضوء', 'أضواء', 'شكل', 'أشكال', 'مزدحم', 'زاهي', 'لامع', 'بصري', 'بصرياً', 'مشهد', 'مشاهد', 'أبصر', 'ترى', 'يرون'}
        self.auditory_keywords = {'صوت', 'أصوات', 'يسمع', 'سمع', 'سمعي', 'صخب', 'ضجيج', 'يصرخ', 'صرخات', 'يهمس', 'همسات', 'موسيقى', 'حديث', 'حوار', 'ضوضاء', 'أذن', 'سمعي', 'تسمع', 'يسمعون'}
        self.olfactory_keywords = {'رائحة', 'روائح', 'يشم', 'شم', 'شمي', 'عبير', 'بخور', 'توابل', 'طعام', 'عادم', 'زهور', 'عطر', 'عطور', 'أنف', 'تشم', 'يشمون'}
        self.gustatory_keywords = {'طعم', 'أطعمة', 'يتذوق', 'تذوق', 'ذوقي', 'حلو', 'مر', 'حامض', 'مالح', 'لاذع', 'مشروب', 'أكل', 'مأكولات', 'لسان', 'فم', 'يتذوقون', 'تتذوق'}
        self.tactile_keywords = {'ملمس', 'ملامس', 'يلمس', 'لمس', 'لمسي', 'حرارة', 'برودة', 'ناعم', 'خشن', 'رطب', 'دافئ', 'حار', 'بارد', 'جلد', 'يد', 'احتكاك', 'ضغوط', 'يلمسون', 'تلمس'}

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1247.

        Args:
            value: A string representing the response (the description).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        title_start = value.find('<<')
        title_end = value.find('>>', title_start + 2)
        if title_start == -1 or title_end == -1 or title_end < title_start + 2:
            return False
        words = value.split()
        word_count = len(words)
        if word_count < 350:
            return False
        detected_senses = set()
        text_lower = value.lower()
        if any((keyword in text_lower for keyword in self.visual_keywords)):
            detected_senses.add('visual')
        if any((keyword in text_lower for keyword in self.auditory_keywords)):
            detected_senses.add('auditory')
        if any((keyword in text_lower for keyword in self.olfactory_keywords)):
            detected_senses.add('olfactory')
        if any((keyword in text_lower for keyword in self.gustatory_keywords)):
            detected_senses.add('gustatory')
        if any((keyword in text_lower for keyword in self.tactile_keywords)):
            detected_senses.add('tactile')
        if len(detected_senses) < 5:
            return False
        return True



class DataIdx1248InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1248')

    def check_following(self, value):
        """Checks if the response contains the word 'عشاء'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains 'عشاء', False otherwise.
        """
        required_word = 'عشاء'
        return required_word in value



class DataIdx1249InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1249')

    def check_following(self, value):
        """Checks if the response requests 5 days leave and includes structure
           suggesting at least three reasons (e.g., list items).
        """
        if not isinstance(value, str):
            return False
        has_leave_and_days = 'إجازة' in value and 'خمسة أيام' in value
        lines = value.strip().split('\n')
        reason_list_count = 0
        numbered_reasons_seen = set()
        for line in lines:
            line = line.strip()
            numbered_match = re.match('^\\s*(\\d+|[\\u0660-\\u0669]+)\\.\\s*\\S+', line)
            if numbered_match:
                number_str = numbered_match.group(1)
                numbered_reasons_seen.add(number_str)
            elif re.match('^\\s*[\\*\\-]\\s*\\S+', line):
                reason_list_count += 1
        total_potential_reasons = len(numbered_reasons_seen) + reason_list_count
        return has_leave_and_days and total_potential_reasons >= 3



class DataIdx1250InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1250')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        pattern = '\\bبيت\\b'
        matches = re.findall(pattern, value)
        count = len(matches)
        return count >= 3



class DataIdx1251InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1251')

    def check_following(self, value):
        """Checks if the response is a short play with at least two characters,
        each speaking at least 5 lines.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        lines = value.splitlines()
        character_lines = {}
        current_character = None
        char_line_pattern = re.compile('^\\s*([^:\\n]+?):\\s*(.*)$')
        sd_pattern = re.compile('^\\s*[\\(\\[].*[\\)\\]]\\s*$')
        for line in lines:
            line = line.strip()
            if not line:
                continue
            if sd_pattern.match(line):
                continue
            match = char_line_pattern.match(line)
            if match:
                char_name = match.group(1).strip()
                dialogue_part = match.group(2).strip()
                if char_name:
                    current_character = char_name
                    character_lines.setdefault(current_character, 0)
                    if dialogue_part:
                        character_lines[current_character] += 1
                elif current_character is not None:
                    character_lines[current_character] += 1
            elif current_character is not None and line:
                character_lines[current_character] += 1
        if len(character_lines) < 2:
            return False
        for char_name, count in character_lines.items():
            if count < 5:
                return False
        return True



class DataIdx1252InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1252')

    def check_following(self, value):
        """Checks if the response is a single line of text ending with a question mark.
        It does NOT check if the response is actual poetry, about reading, or contains a rhyme,
        as these aspects are too complex for a simple programmatic string check.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is a single line ending with a question mark, False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if '\n' in cleaned_value:
            return False
        if not cleaned_value.endswith('?'):
            return False
        return True



class DataIdx1253InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1253')

    def check_following(self, value):
        """Checks if the response describes Saudi Kabsa, is <= 60 words, and uses only commas as punctuation.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        if len(words) > 60:
            return False
        allowed_chars = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ,')
        for char in value:
            is_arabic = '\u0600' <= char <= 'ۿ'
            if char not in allowed_chars and (not is_arabic):
                return False
        return True



class DataIdx1254InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1254')

    def check_following(self, value):
        """Checks if the response is an Arabic sentence about cats, ending with punctuation.
           Note: Checking for 'funny' is not feasible programmatically and is omitted.
        Args:
            value: A string representing the response.

        Returns:
            True if the response meets the verifiable constraints, False otherwise.
        """
        if not isinstance(value, str) or not value:
            return False
        stripped_value = value.strip()
        min_length = 5
        if not stripped_value.endswith(('.', '!', '?')) or len(stripped_value) < min_length:
            return False
        arabic_chars = 0
        total_relevant_chars = 0
        for char in stripped_value:
            if '\u0600' <= char <= 'ۿ':
                arabic_chars += 1
                total_relevant_chars += 1
            elif char.isspace() or char in '.,!?:;()[]{}':
                total_relevant_chars += 1
        min_arabic_percentage = 0.4
        if total_relevant_chars == 0 or arabic_chars / total_relevant_chars < min_arabic_percentage:
            return False
        cat_keywords = ['قطة', 'قطط', 'بسة', 'بسس', 'هر', 'هرة', 'القطط', 'القطة', 'بسسها', 'هروها']
        contains_cat_keyword = any((keyword in stripped_value for keyword in cat_keywords))
        if not contains_cat_keyword:
            return False
        return True



class DataIdx1255InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1255')

    def check_following(self, value):
        """Checks if the response uses the word 'التشبيه' at least twice.
        Args:
            value: A string representing the response.

        Returns:
            True if the word 'التشبيه' appears at least twice, False otherwise.
        """
        word_to_count = 'التشبيه'
        count = value.count(word_to_count)
        return count >= 2



class DataIdx1256InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        pass

    def check_following(self, value):
        """Checks if the response is a single sentence command to open a document.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        terminators = ['.', '!']
        terminator_count = sum((cleaned_value.count(t) for t in terminators))
        if terminator_count > 1:
            return False
        if terminator_count == 1:
            if not cleaned_value.rstrip().endswith(('.', '!')):
                return False
        open_keywords = ['فتح', 'افتح', 'يفتح', 'تفتح', 'open']
        doc_file_keywords = ['مستند', 'ملف', 'docx', 'pdf', 'txt']
        value_lower = cleaned_value.lower()
        has_open_keyword = any((kw in value_lower for kw in open_keywords))
        has_doc_file_keyword = any((kw in value_lower for kw in doc_file_keywords))
        return has_open_keyword and has_doc_file_keyword



class DataIdx1257InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1257')

    def check_following(self, value):
        """Checks if the response is a paragraph of at least three lines and uses the word 'المستقبل' at least twice.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.split('\n')
        min_lines = 3
        if len(lines) < min_lines:
            return False
        word_to_check = 'المستقبل'
        min_word_count = 2
        word_count = value.count(word_to_check)
        if word_count < min_word_count:
            return False
        return True



class DataIdx1258InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1258')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        expected_output_friday = 'اليوم يوم مبارك'
        expected_output_other = 'يوم سعيد'
        if value == expected_output_friday or value == expected_output_other:
            return True
        else:
            return False



class DataIdx1259InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1259')

    def check_following(self, value):
        """Checks if the response explains cake baking steps in five sentences or less,
        using the word 'الكعكة' at least twice.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentences = re.split('[.!?]+', value.strip())
        sentences = [s for s in sentences if s.strip()]
        sentence_count = len(sentences)
        keyword_count = len(re.findall('\\bالكعكة\\b', value))
        return sentence_count <= 5 and keyword_count >= 2



class DataIdx1260InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1260')

    def check_following(self, value):
        """
        Checks if the response contains the name of two teams and mentions the match result.
        Args:
            value: A string representing the response (the news report).

        Returns:
            True if the response follows the instruction, False otherwise.
        """
        score_pattern = re.compile('\\b\\d+-\\d+\\b|\\b\\d+:\\d+\\b')
        result_mentioned = bool(score_pattern.search(value))
        arabic_words_pattern = re.compile('[ا-ي]{3,}')
        potential_names = set(arabic_words_pattern.findall(value))
        two_teams_mentioned_heuristic = len(potential_names) >= 2
        return result_mentioned and two_teams_mentioned_heuristic



class DataIdx1261InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1261')

    def check_following(self, value):
        """Checks if the response is two lines of poetry and each line has at least 8 words.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = [line.strip() for line in value.strip().splitlines() if line.strip()]
        if len(lines) != 2:
            return False
        for line in lines:
            words = line.split()
            if len(words) < 8:
                return False
        return True



class DataIdx1262InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1262')

    def check_following(self, value):
        """Checks if the response follows the constraints: no commas and word count between 280 and 350.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if ',' in value:
            return False
        words = value.split()
        word_count = len(words)
        if not 280 <= word_count <= 350:
            return False
        return True



class DataIdx1263InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1263')

    def check_following(self, value):
        """
        Checks if the response is an Arabic sentence that is a question,
        uses no punctuation except a question mark at the end,
         and contains at least one character before the question mark.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if len(value) < 2 or value[-1] != '?':
            return False
        forbidden_punctuation = string.punctuation.replace('?', '')
        for char in value[:-1]:
            if char in forbidden_punctuation:
                return False
        return True



class DataIdx1264InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1264')

    def check_following(self, value):
        """
        Checks if the response is a summary about a book on Islamic history,
        not exceeding 120 words, and mentions the book title and author.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        word_count = len(words)
        if word_count > 120:
            return False
        book_indicators = ['اسم الكتاب', 'عنوان الكتاب', 'كتاب بعنوان', 'كتاب اسمه', 'كتاب']
        book_mentioned = any((indicator in value for indicator in book_indicators))
        author_indicators = ['المؤلف', 'الكاتب', 'تأليف', 'كتبه', 'للمؤلف', 'للكاتب']
        author_mentioned = any((indicator in value for indicator in author_indicators))
        return book_mentioned and author_mentioned



class DataIdx1265InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1265')

    def check_following(self, value):
        """
        Checks if the response follows the instruction by detecting word repetition,
        as a simple heuristic for 'جناس' (pun/paronomasia).

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains a word repeated (suggesting جناس), False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        cleaned_value = re.sub('[^\\u0600-\\u06FF\\s]', '', value)
        cleaned_value = re.sub('\\s+', ' ', cleaned_value).strip()
        words = cleaned_value.split()
        if len(words) < 2:
            return False
        word_counts = Counter(words)
        for word, count in word_counts.items():
            if count > 1:
                return True
        return False



class DataIdx1266InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1266')

    def check_following(self, value):
        """Checks if the response contains a list of exactly five items, separated by newlines.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (contains exactly 5 lines of non-whitespace content) or False otherwise.
        """
        if not isinstance(value, str):
            return False
        items = value.strip().split('\n')
        non_empty_items = [item.strip() for item in items if item.strip()]
        return len(non_empty_items) == 5



class DataIdx1267InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1267')

    def check_following(self, value):
        """Checks if the response specifies the day and date.
        Args:
            value: A string representing the response.

        Returns:
            True if the response contains a day and a date indication, False otherwise.
        """
        if not isinstance(value, str):
            return False
        value = value.strip()
        if not value:
            return False
        day_names = ['الأحد', 'الاثنين', 'الثلاثاء', 'الأربعاء', 'الخميس', 'الجمعة', 'السبت']
        month_names = ['يناير', 'فبراير', 'مارس', 'أبريل', 'مايو', 'يونيو', 'يوليو', 'أغسطس', 'سبتمبر', 'أكتوبر', 'نوفمبر', 'ديسمبر']
        escaped_day_names = [re.escape(name) for name in day_names]
        day_pattern = '\\b(?:' + '|'.join(escaped_day_names) + ')\\b'
        day_found = re.search(day_pattern, value) is not None
        escaped_month_names = [re.escape(name) for name in month_names]
        month_pattern_str = '|'.join(escaped_month_names)
        month_found = re.search('\\b(?:' + month_pattern_str + ')\\b', value) is not None
        date_pattern_numeric_separator = '\\d{1,2}[^\\w\\s]\\d{1,2}(?:[^\\w\\s]\\d{2,4})?'
        date_pattern_year_first = '\\d{4}[^\\w\\s]\\d{1,2}[^\\w\\s]\\d{1,2}'
        date_pattern_day_month_text = '\\d{1,2}\\s+(?:' + month_pattern_str + ')'
        date_pattern_month_text_day = '(?:' + month_pattern_str + ')\\s+\\d{1,2}'
        date_pattern_full_text = '\\d{1,2}\\s+(?:' + month_pattern_str + ')\\s+\\d{4}'
        date_pattern_full_text_comma = '(?:' + month_pattern_str + ')\\s+\\d{1,2},\\s*\\d{4}'
        date_found_by_pattern = re.search(date_pattern_numeric_separator, value) is not None or re.search(date_pattern_year_first, value) is not None or re.search(date_pattern_day_month_text, value) is not None or (re.search(date_pattern_month_text_day, value) is not None) or (re.search(date_pattern_full_text, value) is not None) or (re.search(date_pattern_full_text_comma, value) is not None)
        date_found = month_found or date_found_by_pattern
        return day_found and date_found



class DataIdx1268InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1268')

    def check_following(self, value):
        """Checks if the response adheres to the constraints:
        - Does not exceed 100 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (specifically word count), False otherwise.
        """
        words = value.split()
        word_count = len(words)
        return word_count <= 100



class DataIdx1269InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1269')

    def check_following(self, value):
        """Checks if the response contains the word 'صحة' within double quotes as required by the instruction.
        Args:
            value: A string representing the response.

        Returns:
            True if the response contains '"صحة"', False otherwise.
        """
        required_substring = '"صحة"'
        return required_substring in value



class DataIdx1270InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1270')

    def check_following(self, value):
        """Checks if the response describes a famous teacher without mentioning their name directly.
        Focuses primarily on the negative constraint: not mentioning the name directly.
        This check is based on detecting specific famous names using regex word boundaries.
        It also includes a minimal length check.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response likely follows the instruction (passes name and length checks),
            False otherwise.
        """
        forbidden_names_patterns = ['\\bسقراط\\b', '\\bأفلاطون\\b', '\\bأرسطو\\b', '\\bآينشتاين\\b', '\\bنيوتن\\b', '\\bالخوارزمي\\b', '\\bابن\\s+سينا\\b', '\\bمانديلا\\b', '\\bغاندي\\b', '\\bكونفوشيوس\\b', '\\bمحمد\\b', '\\bيسوع\\b', '\\bالمسيح\\b', '\\bجان\\s+بول\\s+سارتر\\b', '\\bجبران\\s+خليل\\s+جبران\\b', '\\bطه\\s+حسين\\b', '\\bأحمد\\s+شوقي\\b']
        if not value or len(value.strip()) < 30:
            return False
        normalized_value = value
        for pattern in forbidden_names_patterns:
            if re.search(pattern, normalized_value, re.IGNORECASE):
                return False
        return True



class DataIdx1271InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1271')

    def check_following(self, value):
        """Checks if the response is a dialogue about a book, contains at least two quotation marks,
        and includes a fictional character name.

        Note: Checking for dialogue structure, topic (book), and presence of a fictional character
        name precisely via code is complex and unreliable without advanced NLP or external data.
        This check focuses on the most concrete, programmatically verifiable constraint:
        the presence of at least two quotation marks.

        Args:
            value: A string representing the response.

        Returns:
            True if the response meets the verifiable constraints (at least two quotation marks).
            False otherwise.
        """
        quotation_count = value.count('"')
        has_at_least_two_quotes = quotation_count >= 2
        return has_at_least_two_quotes



class DataIdx1272InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1272')

    def check_following(self, value):
        """Checks if the Arabic paragraph follows the constraints:
        - Less than 25 words.
        - Uses the word 'الكتاب' at least twice.
        - Avoids using exclamation marks.

        Args:
            value: A string representing the response (Arabic paragraph).

        Returns:
            True if the response follows all instructions, False otherwise.
        """
        if '!' in value:
            return False
        words = value.split()
        cleaned_words = []
        punctuation_to_strip = '.,;?:!"()[]{}'
        for word in words:
            cleaned_word = word.strip(punctuation_to_strip)
            if cleaned_word:
                cleaned_words.append(cleaned_word)
        word_count = len(cleaned_words)
        if word_count >= 25:
            return False
        kitab_count = cleaned_words.count('الكتاب')
        if kitab_count < 2:
            return False
        return True



class DataIdx1273InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1273')

    def check_following(self, value):
        """Checks if the response follows the instruction for IDX 1273.
        The instruction requires the response to be a question containing 'لماذا' and ending with '?'.

        Args:
            value: A string representing the response (the generated question).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        contains_لماذا = 'لماذا' in value
        ends_with_question_mark = value.strip().endswith('?')
        return contains_لماذا and ends_with_question_mark



class DataIdx1274InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1274')

    def check_following(self, value):
        """Checks if the response is an Arabic verbal sentence expressing an opinion about reading,
        contains the word 'نافذة', and starts with a verb (checked heuristically).

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction's structural and lexical constraints,
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        response = value.strip()
        if 'نافذة' not in response:
            return False
        first_word = response.split(maxsplit=1)[0] if response else ''
        if first_word.startswith('ال'):
            return False
        common_pronouns = {'أنا', 'نحن', 'أنت', 'أنتِ', 'أنتما', 'أنتم', 'أنتن', 'هو', 'هي', 'هما', 'هم', 'هن'}
        if first_word in common_pronouns:
            return False
        return True



class DataIdx1275InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1275')

    def check_following(self, value):
        """Checks if the response is at least 15 words long and does not contain the word 'ازدحام'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        word_count = len(words)
        forbidden_word = 'ازدحام'
        contains_forbidden_word = forbidden_word in value
        is_long_enough = word_count >= 15
        does_not_contain_forbidden = not contains_forbidden_word
        return is_long_enough and does_not_contain_forbidden



class DataIdx1276InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1276')

    def check_following(self, value):
        """Checks if the response contains the Arabic word 'تفاعلي' at least three times.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        count = value.count('تفاعلي')
        return count >= 3



class DataIdx1277InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1277')

    def check_following(self, value):
        """Checks if the response follows the instruction for IDX 1277.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        contains_jameel = 'جميل' in value
        ends_with_hifthahullah = value.endswith('حفظه الله')
        starts_with_plus = value.strip().startswith('+')
        does_not_contain_ajmal = 'أجمل' not in value
        all_conditions_met = contains_jameel and ends_with_hifthahullah and starts_with_plus and does_not_contain_ajmal
        return all_conditions_met



class DataIdx1278InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1278')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1278.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        mentions_phone = 'هاتف' in value
        mentions_upload = 'تحميل' in value
        words = value.split()
        word_count = len(words)
        within_word_limit = word_count <= 70
        return mentions_phone and mentions_upload and within_word_limit



class DataIdx1279InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1279')

    def check_following(self, value):
        """Checks if the Arabic paragraph contains at least three past tense verbs (heuristic).
           Uses suffix matching and length heuristic for 'ت' ending after removing tashkeel.
           This is a heuristic and may not be perfectly accurate for all Arabic verbs.
        """
        if not isinstance(value, str):
            return False
        explicit_suffix_patterns = ['تُ$', 'تَ$', 'تِ$', 'نا$', 'وا$', 'تم$', 'تن$', 'تْ$', 'نَ$']
        base_suffixes_no_tashkeel = ['تم', 'تن', 'نا', 'وا', 'ت']
        tashkeel_pattern = re.compile('[\\u064B-\\u0652]')
        words = re.findall('\\b\\w+\\b', value, re.UNICODE)
        past_verb_count = 0
        counted_words = set()
        for word in words:
            if word in counted_words:
                continue
            matched = False
            for pattern in explicit_suffix_patterns:
                if re.search(pattern, word, re.UNICODE):
                    past_verb_count += 1
                    counted_words.add(word)
                    matched = True
                    break
            if matched:
                continue
            word_no_tashkeel = tashkeel_pattern.sub('', word)
            for suffix in base_suffixes_no_tashkeel:
                if word_no_tashkeel.endswith(suffix):
                    if suffix == 'ت':
                        if len(word_no_tashkeel) >= 3:
                            past_verb_count += 1
                            counted_words.add(word)
                            matched = True
                            break
                    elif len(word_no_tashkeel) > len(suffix):
                        past_verb_count += 1
                        counted_words.add(word)
                        matched = True
                        break
        return past_verb_count >= 3



class DataIdx1280InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1280')

    def check_following(self, value):
        """Checks if the response follows the instruction.
        The instruction is to write a short comment (not exceeding 25 words) on a beautiful landscape photo, using the word 'جميل' at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        word_count_ok = word_count <= 25
        contains_جميل = 'جميل' in value
        return word_count_ok and contains_جميل



class DataIdx1281InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1281')

    def check_following(self, value):
        """
        Checks if the response avoids mentioning the teacher's name using simple heuristics.
        Looks for common titles followed by common first names or explicit naming phrases.
        This is a heuristic approach and may not catch all names or could have false positives.
        """
        common_first_names = {'محمد', 'أحمد', 'علي', 'حسن', 'حسين', 'إبراهيم', 'يوسف', 'موسى', 'عيسى', 'عمر', 'عثمان', 'خالد', 'طارق', 'زياد', 'ماجد', 'فهد', 'سلمان', 'ناصر', 'ياسر', 'رشيد', 'سمير', 'عماد', 'جمال', 'فاطمة', 'عائشة', 'مريم', 'زينب', 'خديجة', 'عبدالله', 'عبدالرحمن', 'عبدالكريم', 'مصطفى', 'محمود', 'كمال', 'فؤاد', 'سعيد', 'بشير', 'صالح', 'عادل', 'هشام', 'نبيل', 'باسل'}
        common_titles = {'أستاذ', 'معلم', 'دكتور', 'شيخ', 'الأستاذ', 'المعلم', 'الدكتور', 'الشيخ', 'الأستاذة', 'المعلمة', 'الدكتورة', 'الشيخة', 'بروفيسور', 'البروفيسور'}
        naming_phrases = {'اسمه', 'يدعى', 'يسمى', 'اسمها', 'تدعى', 'تسمى'}
        value = value.replace('.', '').replace(',', '').replace('!', '').replace('?', '').replace('،', '').replace('؛', '').replace(':', '')
        value = value.strip()
        if not value:
            return True
        words = value.split()
        for i in range(len(words) - 1):
            if words[i] in common_titles and words[i + 1] in common_first_names:
                return False
        for i in range(len(words)):
            if words[i] in naming_phrases:
                if i + 1 < len(words):
                    return False
        return True



class DataIdx1282InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1282')

    def check_following(self, value):
        """
        Checks if the response mentions the word 'مستقبل' exactly three times.
        The question asks for a paragraph describing a futuristic city focusing on
        technological and environmental aspects, mentioning the word 'مستقبل' three times.
        This checker focuses on the quantifiable constraint: the word count.
        """
        if not isinstance(value, str):
            return False
        word_count = len(re.findall('\\bمستقبل\\b', value))
        return word_count == 3



class DataIdx1283InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1283')

    def check_following(self, value):
        """Checks if the response is a single Arabic sentence containing the dual forms of 'الكتاب' and 'القراءة'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        has_dual_kitab = 'الكتابان' in value or 'الكتابين' in value
        has_dual_qiraa = 'القراءتان' in value or 'القراءتين' in value
        is_reasonably_short = len(value) < 150
        return has_dual_kitab and has_dual_qiraa and is_reasonably_short



class DataIdx1284InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1284')

    def check_following(self, value):
        """Checks if the response follows the constraints for question 1284.
        Constraints:
        - Word count >= 115 and <= 240.
        - Character 'ص' count >= 50.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        word_count_ok = word_count >= 115 and word_count <= 240
        char_sad_count = value.count('ص')
        char_sad_count_ok = char_sad_count >= 50
        return word_count_ok and char_sad_count_ok



class DataIdx1285InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1285')

    def check_following(self, value):
        """Checks if the response describes a historical Arab city in a paragraph
           not exceeding 60 words, mentioning the city name and using 'تاريخ'.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        word_count = len([word for word in words if word])
        if word_count > 60:
            return False
        if 'تاريخ' not in value:
            return False
        common_historical_cities = ['بغداد', 'دمشق', 'القاهرة', 'القدس', 'قرطبة', 'حلب', 'فاس', 'تونس', 'مكة', 'المدينة', 'الكوفة', 'البصرة', 'صنعاء', 'الإسكندرية', 'القيروان']
        city_mentioned = False
        for city in common_historical_cities:
            if city in value:
                city_mentioned = True
                break
        if not city_mentioned:
            return False
        return True



class DataIdx1286InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1286')

    def check_following(self, value):
        """Checks if the response describes a historical city within the word limit.
        Args:
            value: A string representing the response.

        Returns:
            True if the response is within the word limit (<= 40 words), False otherwise.
            Note: Checking for the mention of a specific city name and reason for fame
            semantically is beyond the scope of this automated checker without external
            knowledge or further constraints. This check primarily verifies the word count.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        filtered_words = [word for word in words if word]
        word_count = len(filtered_words)
        return word_count <= 40



class DataIdx1287InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1287')

    def check_following(self, value):
        """Checks if the response is a string that ends with exactly one exclamation mark.
        Note: Cannot reliably check for Arabic language, exclamatory nature, or specific content about spring beauty.
        Only verifies the structural constraint regarding the exclamation mark.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the checkable constraint, False otherwise.
        """
        if not isinstance(value, str) or not value:
            return False
        if not value.endswith('!'):
            return False
        if value.count('!') != 1:
            return False
        return True



class DataIdx1288InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1288')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 1288.

        Constraints:
        - Use '!' at least once.
        - Use '?' at most once.
        - Do not exceed 35 words.
        - (Implicit) Be about a new training course in 'Digital Marketing' (this part is hard to check strictly).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the constraints or False otherwise.
        """
        if not isinstance(value, str):
            return False
        exclamation_count = value.count('!')
        if exclamation_count < 1:
            return False
        question_count = value.count('?')
        if question_count > 1:
            return False
        words = value.split()
        word_count = len(words)
        if word_count > 35:
            return False
        return True



class DataIdx1289InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1289')

    def check_following(self, value):
        """Checks if the response lists five items ordered alphabetically,
           using numbers (1-5), and without commas.
           Does NOT verify if the items are ancient or Arab cities.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the structural and formatting
            constraints or False otherwise.
        """
        if ',' in value:
            return False
        matches = re.findall('(\\d+)\\.\\s*(.*?)(?=\\s*(?:\\d+\\.|$))', value.strip(), re.DOTALL)
        if len(matches) != 5:
            return False
        numbers_found = [m[0] for m in matches]
        if numbers_found != ['1', '2', '3', '4', '5']:
            return False
        items = [m[1].strip() for m in matches]
        if any((not item for item in items)):
            return False
        if items != sorted(items):
            return False
        return True



class DataIdx1290InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1290')

    def check_following(self, value):
        """
        Checks if the response is a simple fruit salad recipe in five points
        mentioning three different types of fruit (based on a predefined list).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = [line.strip() for line in value.strip().split('\n') if line.strip()]
        has_five_points = len(lines) == 5
        common_fruits = {'تفاح', 'موز', 'برتقال', 'فراولة', 'عنب', 'مانجو', 'كرز', 'أناناس', 'كيوي', 'كمثرى', 'خوخ', 'مشمش', 'تين', 'رمان', 'بلح', 'توت', 'بطيخ', 'شمام', 'مانجو'}
        text = value.lower()
        found_fruits = set()
        for fruit in common_fruits:
            if fruit in text:
                found_fruits.add(fruit)
        has_at_least_three_fruits = len(found_fruits) >= 3
        return has_five_points and has_at_least_three_fruits



class DataIdx1291InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1291')

    def check_following(self, value):
        """Checks if the response contains the word 'قهوة' exactly two times.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction, False otherwise.
        """
        keyword = 'قهوة'
        count = value.count(keyword)
        return count == 2



class DataIdx1292InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1292')

    def check_following(self, value):
        """Checks if the response is a short paragraph about a pet, not exceeding 60 words.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count > 60:
            return False
        return True



class DataIdx1293InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1293')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.strip().split()
        return len(words) == 1



class DataIdx1294InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1294')

    def check_following(self, value):
        """Checks if the response describes winter without using forbidden cold weather words and uses 'دافئ' at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        required_word = 'دافئ'
        if required_word not in value:
            return False
        forbidden_words = ['برد', 'ثلج', 'زمهرير', 'بارد', 'صقيع', 'جليد']
        for word in forbidden_words:
            if word in value:
                return False
        return True



class DataIdx1295InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1295')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 1295.

        Args:
            value: A string representing the response (the movie review).

        Returns:
            True if the response follows the instructions or False otherwise.
        """
        words = value.split()
        word_count = len(words)
        if word_count <= 70:
            return False
        return True



class DataIdx1296InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1296')

    def check_following(self, value):
        """Checks if the response mentions the Saudi flag colors (green and white)
        in a sentence using the conjunction 'و'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        has_green = 'أخضر' in value or 'خضراء' in value
        has_white = 'أبيض' in value or 'بيضاء' in value
        has_conjunction_wa = 'و' in value
        return has_green and has_white and has_conjunction_wa



class DataIdx1297InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1297')

    def check_following(self, value):
        """Checks if the response lists five water sports separated by 'و'."""
        items = value.split('و')
        if len(items) != 5:
            return False
        for item in items:
            if not item.strip():
                return False
        return True



class DataIdx1298InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1298')

    def check_following(self, value):
        """Checks if the response (tweet) includes at least one hashtag and the word 'تخفيضات'.
        Args:
            value: A string representing the response (the tweet).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        has_hashtag = '#' in value
        has_takhfidat = 'تخفيضات' in value
        return has_hashtag and has_takhfidat



class DataIdx1299InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1299')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 1299.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if '\n' in cleaned_value:
            return False
        if not cleaned_value.startswith('التعليم'):
            return False
        if not cleaned_value.endswith('وبناء مستقبل أفضل'):
            return False
        if '،' in cleaned_value:
            return False
        return True



class DataIdx1300InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1300')

    def check_following(self, value):
        """Checks if the response follows the constraints for question 1300.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        expected_ending = 'هل كانت هذه الخطوات واضحة؟'
        separator = '***'
        if not value.endswith(expected_ending):
            return False
        content_part = value[:-len(expected_ending)]
        steps = content_part.split(separator)
        if len(steps) != 3:
            return False
        for step in steps:
            if not step.strip():
                return False
        return True



class DataIdx1301InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1301')

    def check_following(self, value):
        """Checks if the response describes a natural scene at sunset in three lines
           using only the comma as punctuation.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.strip().split('\n')
        if len(lines) != 3:
            return False
        allowed_punctuation = {','}
        forbidden_punctuation = set(string.punctuation) - allowed_punctuation
        for char in value:
            if char in forbidden_punctuation:
                return False
        return True



class DataIdx1302InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1302')

    def check_following(self, value):
        """Checks if the response is a message longer than two sentences.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        sentences = [s.strip() for s in re.split('([.!؟])', value) if s.strip()]
        potential_sentences = re.split('[.!؟]', value)
        valid_sentences = [s.strip() for s in potential_sentences if s.strip()]
        sentence_count = len(valid_sentences)
        if sentence_count <= 2:
            return False
        return True



class DataIdx1303InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1303')

    def check_following(self, value):
        """
        Checks if the response contains at least four identifiable steps,
        assuming steps are commonly presented as numbered or bulleted list items.

        Args:
            value: A string representing the response.

        Returns:
            True if the response appears to contain at least 4 steps based on list formatting,
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        step_pattern = re.compile('^\\s*(?:\\d+[\\.\\):]|[+\\-\\*])\\s*')
        lines = value.strip().split('\n')
        step_count = 0
        for line in lines:
            if step_pattern.match(line):
                step_count += 1
        return step_count >= 4



class DataIdx1304InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1304')

    def check_following(self, value):
        """Checks if the response contains the keyword 'ضروري' at least twice.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        keyword = 'ضروري'
        count = value.lower().count(keyword.lower())
        return count >= 2



class DataIdx1305InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1305')

    def check_following(self, value):
        """Checks if the response is a single sentence expressing thanks,
        includes 'شكراً', and does not exceed 10 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        includes_shukran = 'شكراً' in cleaned_value
        words = [word for word in cleaned_value.split() if word]
        word_count_ok = len(words) <= 10
        terminal_punctuations = ['.', '!', '?']
        punct_count = sum((cleaned_value.count(p) for p in terminal_punctuations))
        single_sentence_ok = punct_count <= 1
        return includes_shukran and word_count_ok and single_sentence_ok



class DataIdx1306InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1306')

    def check_following(self, value):
        """Checks if the response is a single sentence in Arabic expressing the importance of continuous learning,
        and contains the word 'ضروري'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if 'ضروري' not in value:
            return False
        if '\n' in value or '\r' in value:
            return False
        return True



class DataIdx1307InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1307')

    def check_following(self, value):
        """Checks if the response is a valid JSON representing a two-day trip
        plan to Cairo focusing on historical sites, and uses the word 'قديم'
        no more than once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        qadim_count = len(re.findall('\\bقديم\\b', value))
        if qadim_count > 1:
            return False
        try:
            data = json.loads(value)
        except json.JSONDecodeError:
            return False
        is_two_day_plan = False
        if isinstance(data, list):
            if len(data) >= 2:
                is_two_day_plan = True
        elif isinstance(data, dict):
            day_keys_found_count = 0
            for key in data.keys():
                if isinstance(key, str):
                    if key.lower().startswith('day') or key.startswith('اليوم'):
                        day_keys_found_count += 1
            if day_keys_found_count >= 2:
                is_two_day_plan = True
        if not is_two_day_plan:
            return False
        return True



class DataIdx1308InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1308')

    def check_following(self, value):
        """
        Checks if the response follows the constraints for question 1308.
        Constraints:
        1. Less than 50 words.
        2. Mentions at least one prominent landmark.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the verifiable constraints, False otherwise.
        """
        words = value.split()
        word_count = len(words)
        if word_count >= 50:
            return False
        return True



class DataIdx1309InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1309')

    def check_following(self, value):
        """Checks if the response follows the instruction for IDX 1309.
        The instruction requires a single paragraph describing a long-term
        career goal, using the word 'تطوير' at least twice.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the verifiable constraints (single
            paragraph structure and word count) or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = [line.strip() for line in value.split('\n') if line.strip()]
        is_single_paragraph = '\n\n' not in value.strip()
        word_count = value.count('تطوير')
        has_required_word_count = word_count >= 2
        return is_single_paragraph and has_required_word_count



class DataIdx1310InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1310')

    def check_following(self, value):
        """Checks if the response is a short news report in Arabic using modern journalistic style.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        is_arabic = any(('\u0600' <= c <= 'ۿ' for c in value))
        if not is_arabic:
            return False
        words = value.split()
        word_count = len(words)
        min_words = 50
        max_words = 300
        if not min_words <= word_count <= max_words:
            return False
        return True



class DataIdx1311InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1311')

    def check_following(self, value):
        """Checks if the response follows the instructions:
        - Starts with the word 'أحضر' (Ahdir) after stripping leading/trailing whitespace.
        - Includes at least three distinct steps, assumed to be separated by newlines
          and non-empty.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if not value.strip().startswith('أحضر'):
            return False
        lines = value.split('\n')
        steps = [line for line in lines if line.strip()]
        if len(steps) < 3:
            return False
        return True



class DataIdx1312InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1312')

    def check_following(self, value):
        """Checks if the response follows the constraints for IDX 1312.

        Constraints:
        1. Total number of points is exactly seven.
        2. Forbidden punctuation (',', '.', '?') is not used.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        forbidden_punctuation = [',', '.', '?']
        for char in forbidden_punctuation:
            if char in value:
                return False
        lines = value.splitlines()
        non_empty_lines = [line.strip() for line in lines if line.strip()]
        if len(non_empty_lines) != 7:
            return False
        return True



class DataIdx1313InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1313')

    def check_following(self, value):
        """Checks if the response is an Arabic exclamation sentence expressing admiration,
        starting with an exclamation word and ending with '!'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not value.strip().endswith('!'):
            return False
        cleaned_value = value.strip()
        exclamation_starts = ['ما أجمل', 'يا له من']
        starts_correctly = False
        for start_phrase in exclamation_starts:
            if cleaned_value.startswith(start_phrase):
                starts_correctly = True
                break
        if not starts_correctly:
            return False
        return True



class DataIdx1314InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1314')

    def check_following(self, value):
        """Checks if the recipe follows the constraints.

        Args:
            value: A string representing the response (the recipe).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if not 100 <= word_count <= 150:
            return False
        if any((char.isdigit() for char in value)):
            return False
        ordinal_words = ['أولاً', 'ثانيًا', 'ثالثًا', 'رابعاً', 'خامساً', 'سادساً', 'سابعاً', 'ثامناً', 'تاسعاً', 'عاشراً']
        ordinal_present = any((word in value for word in ordinal_words))
        if not ordinal_present:
            return False
        return True



class DataIdx1315InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1315')

    def check_following(self, value):
        """Checks if the response is a question in Classical Arabic about the weather today,
        starting with 'هل', ending with '?', and consisting of exactly seven words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        starts_with_hel = stripped_value.startswith('هل')
        ends_with_q = stripped_value.endswith('؟')
        words = stripped_value.split()
        word_count = len(words)
        return starts_with_hel and ends_with_q and (word_count == 7)



class DataIdx1316InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1316')

    def check_following(self, value):
        """Checks if the response is a single sentence including a vivid metaphor (تشبيه بليغ)
        describing the beauty of the moon at night.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        value = value.strip()
        sentence_enders = ['.', '!', '?']
        if not value or value[-1] not in sentence_enders:
            return False
        if any((char in sentence_enders for char in value[:-1])):
            return False
        if 'القمر' not in value and 'قمر' not in value:
            return False
        beauty_keywords = ['جمال', 'جميل', 'بديع', 'خلاب', 'ساحر', 'ساطع', 'منير', 'نور', 'ضياء', 'فاتن', 'بهي', 'رائع']
        has_beauty_context = any((word in value for word in beauty_keywords))
        if not has_beauty_context:
            return False
        night_sky_keywords = ['ليل', 'الليل', 'سماء', 'السماء', 'نجوم', 'الظلام', 'ظلام']
        has_night_sky_context = any((word in value for word in night_sky_keywords))
        if not has_night_sky_context:
            return False
        explicit_comparison_words = ['مثل', 'كأن', 'يشبه']
        avoids_explicit_comparison = not any((word in value for word in explicit_comparison_words))
        if not avoids_explicit_comparison:
            return False
        return True



class DataIdx1317InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1317')

    def check_following(self, value):
        """Checks if the response follows the instruction for question 1317.

        Constraints:
        1. Exactly 21 sentences.
        2. No numbers used.
        3. Content is a comparison of two Arab fruits (cannot reliably check programmatically without NLP).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the verifiable instructions, False otherwise.
        """
        if any((char.isdigit() for char in value)):
            return False
        text_cleaned = re.sub('\\.{2,}', '.', value)
        sentences = re.split('[.?!]+\\s*', text_cleaned)
        sentences = [s for s in sentences if s and (not s.isspace())]
        if len(sentences) != 21:
            return False
        return True



class DataIdx1318InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1318')

    def check_following(self, value):
        """Checks if the response is a paragraph expressing overwhelming happiness
        with at least 5 sentences, reflecting the extent of joy.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction (at least 5 sentences),
            False otherwise.
        """
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        processed_text = cleaned_value.replace('!', '.').replace('؟', '.')
        sentences = processed_text.split('.')
        valid_sentences = [s.strip() for s in sentences if s.strip()]
        sentence_count = len(valid_sentences)
        return sentence_count >= 5



class DataIdx1319InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1319')

    def check_following(self, value):
        """Checks if the response starts with the word 'لأن'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response starts with 'لأن', False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        return value.strip().startswith('لأن')



class DataIdx1320InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1320')

    def check_following(self, value):
        """Checks if the value is a JSON string containing specific keys and values.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        try:
            data = json.loads(value)
            if not isinstance(data, dict):
                return False
            if data.get('اسم') != 'كتاب':
                return False
            if data.get('نوع') != 'خيال':
                return False
            return True
        except json.JSONDecodeError:
            return False
        except Exception:
            return False



class DataIdx1321InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1321')

    def check_following(self, value):
        """Checks if the value is a JSON object containing 'name' and 'age' keys.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        try:
            data = json.loads(value)
            if not isinstance(data, dict):
                return False
            if 'name' in data and 'age' in data:
                return True
            else:
                return False
        except json.JSONDecodeError:
            return False
        except Exception:
            return False



class DataIdx1322InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1322')

    def check_following(self, value):
        """Checks if the response is a recipe title that is less than 5 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        return len(words) < 5



class DataIdx1323InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1323')

    def check_following(self, value):
        """Checks if the response follows the constraints:
        - Is in Arabic (checked by presence of Arabic characters).
        - Does not contain commas (standard ',' or Arabic '،').
        (Constraints about simple sentences and topic are hard to check programmatically).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the feasible constraints, False otherwise.
        """
        if not isinstance(value, str):
            return False
        if ',' in value or '،' in value:
            return False
        arabic_found = False
        for char in value:
            if 1536 <= ord(char) <= 1791:
                arabic_found = True
                break
        if not arabic_found:
            return False
        return True



class DataIdx1324InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1324')

    def check_following(self, value):
        """Checks if the response follows the instruction: at least three sentences, avoid attached pronouns.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentence_terminators_count = value.count('.') + value.count('!') + value.count('?')
        is_three_sentences = sentence_terminators_count >= 2
        AMBIGUOUS_ENDINGS = ['ي', 'ك', 'ه']
        UNAMBIGUOUS_ENDINGS = ['ني', 'نا', 'كِ', 'كما', 'كم', 'كن', 'ها', 'هما', 'هم', 'هن', 'وه']
        text_for_analysis = value.replace('.', ' ').replace('!', ' ').replace('?', ' ')
        text_for_analysis = text_for_analysis.translate(str.maketrans('', '', string.punctuation.replace(' ', '')))
        text_for_analysis = re.sub('\\d+', '', text_for_analysis)
        words = text_for_analysis.split()
        has_attached_pronoun = False
        HARAKAT = 'ًٌٍَُِّْٓ'
        TATWEEL = 'ـ'
        for word in words:
            cleaned_word = word.translate(str.maketrans('', '', HARAKAT))
            cleaned_word = cleaned_word.replace(TATWEEL, '')
            cleaned_word = cleaned_word.strip()
            if not cleaned_word:
                continue
            for ending in UNAMBIGUOUS_ENDINGS:
                if cleaned_word.endswith(ending):
                    if len(cleaned_word) > len(ending):
                        has_attached_pronoun = True
                        break
            if has_attached_pronoun:
                break
            if not has_attached_pronoun:
                for ending in AMBIGUOUS_ENDINGS:
                    if cleaned_word.endswith(ending):
                        if len(cleaned_word) > 2:
                            has_attached_pronoun = True
                            break
                if has_attached_pronoun:
                    break
        return is_three_sentences and (not has_attached_pronoun)



class DataIdx1325InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1325')

    def check_following(self, value):
        """Checks if the response starts with 'إليك إجابتي:' and contains information about three fruits.
        Note: This checker primarily enforces the starting phrase constraint as checking for
        exactly three 'fruit types' reliably in Arabic without a predefined list or NLP is complex.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (starts with the required phrase), False otherwise.
        """
        required_start = 'إليك إجابتي:'
        if not value.strip().startswith(required_start):
            return False
        if value.strip() == required_start:
            return False
        return True



class DataIdx1326InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1326')

    def check_following(self, value):
        """Checks if the response is a question starting with 'هل',
        including 'اليوم', and ending with '؟', implying a yes/no question structure.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction, False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value.startswith('هل'):
            return False
        if 'اليوم' not in cleaned_value:
            return False
        if not cleaned_value.endswith('؟'):
            return False
        return True



class DataIdx1327InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1327')

    def check_following(self, value):
        """Checks if the response is a single, concise sentence that could be a proverb.

        Constraints checked:
        1.  Is it a single sentence?
        2.  Is it reasonably concise (word count)?
        The constraints about encouraging diligence/perseverance and rhetorical style are difficult to check
        programmatically without advanced NLP and are therefore not strictly enforced by this checker,
        focusing on the structural requirements.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the checkable structural instructions or False otherwise.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        if not stripped_value:
            return False
        terminators = ['.', '!', '?']
        terminator_count = sum((stripped_value.count(t) for t in terminators))
        if terminator_count > 1:
            return False
        if terminator_count == 1:
            if stripped_value[-1] not in terminators:
                return False
        words = stripped_value.split()
        word_count = len(words)
        MAX_WORDS = 20
        if word_count > MAX_WORDS:
            return False
        return True



class DataIdx1328InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1328')

    def check_following(self, value):
        """Checks if the response follows the constraints for question IDX 1328.

        Constraints:
        1. Contains exactly three separate paragraphs.
        2. Each paragraph is a single paragraph (separated by 

).
        3. The keyword 'التعلم' is used at least once in each paragraph.
        4. No titles are included.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        paragraphs = value.strip().split('\n\n')
        if len(paragraphs) != 3:
            return False
        for para in paragraphs:
            if not para.strip():
                return False
            if 'التعلم' not in para:
                return False
            if len(para.split('\n\n')) > 1:
                return False
        return True



class DataIdx1329InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1329')

    def check_following(self, value):
        """Checks if the response contains exactly five items, each starting with the letter 'ا'."""
        if not isinstance(value, str):
            return False
        items = value.replace(',', ' ').split()
        items = [item.strip() for item in items if item.strip()]
        if len(items) != 5:
            return False
        for item in items:
            if not item:
                return False
            if not item.startswith('ا'):
                return False
        return True



class DataIdx1330InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1330')

    def check_following(self, value):
        """Checks if the response contains a list of 5 suggestions,
        each starting with a potential imperative verb marker (heuristic).
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        processed_lines = []
        list_marker_re = re.compile('^\\s*(\\d+\\.\\s+|\\-\\s+|\\*\\s+|\\+\\s+|\\s*[٠-٩]+\\.\\s+)')
        for line in lines:
            cleaned_line = line.strip()
            cleaned_line = list_marker_re.sub('', cleaned_line).strip()
            if cleaned_line:
                processed_lines.append(cleaned_line)
        if len(processed_lines) != 5:
            return False
        common_imperative_starts = ('ا', 'أ', 'ت', 'است')
        for line in processed_lines:
            words = line.split(maxsplit=1)
            if not words or not words[0]:
                return False
            first_word = words[0]
            if not first_word.startswith(common_imperative_starts):
                return False
        return True



class DataIdx1331InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1331')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        cleaned_value_para = value.strip()
        if '\n\n' in cleaned_value_para:
            return False
        potential_words = cleaned_value_para.split()
        cleaned_words = []
        punctuation = '.,!?;:"\'()[]{}<>«»—–…-ـ،؛؟'
        for word in potential_words:
            cleaned_word = word.strip(punctuation)
            if cleaned_word:
                cleaned_words.append(cleaned_word)
        muqaddas_count = cleaned_words.count('مقدس')
        word_count = len(cleaned_words)
        if word_count > 60:
            return False
        if muqaddas_count != 1:
            return False
        return True



class DataIdx1332InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1332')

    def check_following(self, value):
        """Checks if the response is a single sentence expressing gratitude,
        contains 'شكراً', and is 6 to 8 words long.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        contains_shukran = 'شكراً' in value
        words = value.split()
        word_count = len(words)
        is_valid_length = 6 <= word_count <= 8
        if not value.strip():
            return False
        return contains_shukran and is_valid_length



class DataIdx1333InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1333')

    def check_following(self, value):
        """Checks if the response explains 'الكتاب' briefly (less than 20 words) and uses the word 'صفحات'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instructions, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        is_word_count_valid = word_count < 20
        is_keyword_present = 'صفحات' in value
        return is_word_count_valid and is_keyword_present



class DataIdx1334InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1334')

    def check_following(self, value):
        """Checks if the response is a single paragraph between 60 and 80 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if '\n\n' in cleaned_value:
            return False
        words = cleaned_value.split()
        word_count = len(words)
        if 60 <= word_count <= 80:
            return True
        else:
            return False



class DataIdx1335InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1335')

    def check_following(self, value):
        """Checks if the response is a single sentence containing an adjacent pair of words that both start with 'ال' as a heuristic for a definite noun followed by a definite adjective."""
        stripped_value = value.strip()
        terminators = '.!?'
        if not stripped_value:
            return False
        if stripped_value[-1] not in terminators:
            return False
        if sum((stripped_value.count(t) for t in terminators)) != 1:
            return False
        content_without_terminator = stripped_value[:-1].strip()
        if not content_without_terminator:
            return False
        words = content_without_terminator.split()
        if len(words) < 2:
            return False
        has_definite_definite_pair = False
        for i in range(len(words) - 1):
            word1 = words[i]
            word2 = words[i + 1]
            word1_clean = word1.rstrip(',;:')
            word2_clean = word2.rstrip(',;:')
            if word1_clean.startswith('ال') and word2_clean.startswith('ال'):
                has_definite_definite_pair = True
                break
        return has_definite_definite_pair



class DataIdx1336InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1336')

    def check_following(self, value):
        """
        Checks if the response is a table with 'الترتيب' and 'اسم النهر' columns
        (in that order) and contains at least 5 data rows.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        lines = value.strip().splitlines()
        header_line_index = -1
        for i, line in enumerate(lines):
            stripped_line = line.strip()
            tertib_index = stripped_line.find('الترتيب')
            name_index = stripped_line.find('اسم النهر')
            if tertib_index != -1 and name_index != -1 and (tertib_index < name_index):
                header_line_index = i
                break
        if header_line_index == -1:
            return False
        data_row_count = 0
        start_index = header_line_index + 1
        for i in range(start_index, len(lines)):
            line = lines[i].strip()
            if not line or all((c in '-|=+ ' for c in line)):
                continue
            data_row_count += 1
        return data_row_count >= 5



class DataIdx1337InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1337')

    def check_following(self, value):
        """Checks if the response follows the constraints:
        1. At most 130 words.
        2. No semicolons.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if ';' in value:
            return False
        words = value.split()
        if len(words) > 130:
            return False
        return True



class DataIdx1338InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1338')

    def check_following(self, value):
        """Checks if the response is a single interrogative sentence asking about the weather,
           starts with an interrogative word, and includes the word 'الطقس'.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value.endswith('?'):
            return False
        if 'الطقس' not in cleaned_value:
            return False
        if cleaned_value.find('?') != len(cleaned_value) - 1:
            return False
        interrogative_words = ['كيف', 'ماذا', 'ما', 'هل', 'أين', 'متى', 'كم', 'أي']
        value_stem = cleaned_value[:-1].strip()
        starts_with_interrogative = False
        for word in interrogative_words:
            if value_stem.startswith(word):
                if len(value_stem) == len(word) or value_stem[len(word):].startswith(' '):
                    starts_with_interrogative = True
                    break
        if not starts_with_interrogative:
            return False
        return True



class DataIdx1339InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1339')

    def check_following(self, value):
        """Checks if the response is an Arabic sentence expressing a wish using 'ليت' and including 'السعادة'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        contains_layta = 'ليت' in value
        contains_happiness = 'السعادة' in value
        return contains_layta and contains_happiness



class DataIdx1340InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1340')

    def check_following(self, value):
        """Checks if the response is a bulleted list with exactly two points.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        bullet_count = 0
        bullet_chars = ['*', '-']
        for line in lines:
            stripped_line = line.strip()
            if any((stripped_line.startswith(f'{char} ') or stripped_line.startswith(f'{char}\t') for char in bullet_chars)):
                content = stripped_line[1:].strip()
                if content:
                    bullet_count += 1
            elif stripped_line.startswith('• ') or stripped_line.startswith('•\t'):
                content = stripped_line[1:].strip()
                if content:
                    bullet_count += 1
        return bullet_count == 2



class DataIdx1341InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1341')

    def check_following(self, value):
        """Checks if the response is a single Arabic sentence expressing polite refusal,
           using 'لكن' exactly once, and ending with a single sentence terminator.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if value.count('لكن') != 1:
            return False
        terminators = ['.', '؟', '!']
        terminator_count = sum((value.count(term) for term in terminators))
        if terminator_count != 1:
            return False
        return True



class DataIdx1342InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1342')

    def check_following(self, value):
        """Checks if the response is a table comparing traditional and distance education
        with the specified columns and number of rows.
        """
        lines = value.strip().split('\n')
        header_idx = -1
        separator_idx = -1
        required_headers = ['وجه المقارنة', 'التعليم التقليدي', 'التعليم عن بعد']

        def parse_table_row(line):
            """Helper to parse a line into a list of stripped column strings, allowing empty cells."""
            stripped_line = line.strip()
            if not stripped_line:
                return None
            parts = stripped_line.split('|')
            content_parts = []
            if stripped_line.startswith('|') and stripped_line.endswith('|') and (len(parts) >= 2):
                content_parts = parts[1:-1]
            elif stripped_line.startswith('|') and len(parts) >= 1:
                content_parts = parts[1:]
            elif stripped_line.endswith('|') and len(parts) >= 1:
                content_parts = parts[:-1]
            else:
                content_parts = parts
            if len(content_parts) != 3:
                return False
            cleaned_parts = [part.strip() for part in content_parts]
            return cleaned_parts
        for i, line in enumerate(lines):
            if 'وجه المقارنة' in line and 'التعليم التقليدي' in line and ('التعليم عن بعد' in line):
                cleaned_parts = parse_table_row(line)
                if cleaned_parts is not False and cleaned_parts == required_headers:
                    header_idx = i
                    if i + 1 < len(lines):
                        next_line = lines[i + 1].strip()
                        if re.match('^\\|?\\s*[:-]+\\s*\\|?\\s*[:-]+\\s*\\|?\\s*[:-]+\\s*\\|?$', next_line):
                            sep_parts_raw = next_line.split('|')
                            sep_content_parts = []
                            if next_line.startswith('|') and next_line.endswith('|') and (len(sep_parts_raw) >= 2):
                                sep_content_parts = sep_parts_raw[1:-1]
                            elif next_line.startswith('|') and len(sep_parts_raw) >= 1:
                                sep_content_parts = sep_parts_raw[1:]
                            elif next_line.endswith('|') and len(sep_parts_raw) >= 1:
                                sep_content_parts = sep_parts_raw[:-1]
                            else:
                                sep_content_parts = sep_parts_raw
                            if len(sep_content_parts) == 3:
                                sep_parts_stripped = [part.strip() for part in sep_content_parts]
                                if all(('-' in part for part in sep_parts_stripped)):
                                    separator_idx = i + 1
                                    break
        if header_idx == -1 or separator_idx == -1 or separator_idx != header_idx + 1:
            return False
        if len(lines) < 4:
            return False
        data_lines = lines[separator_idx + 1:]
        for line in data_lines:
            cleaned_parts = parse_table_row(line)
            if cleaned_parts is None:
                continue
            if cleaned_parts is False:
                return False
        return True



class DataIdx1343InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1343')

    def check_following(self, value):
        """Checks if the response is a numbered list of three tips, each starting with 'تأكد'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.strip().split('\n')
        numbered_tips = {}
        for line in lines:
            line = line.strip()
            if line.startswith('1.'):
                numbered_tips[1] = line[2:].strip()
            elif line.startswith('2.'):
                numbered_tips[2] = line[2:].strip()
            elif line.startswith('3.'):
                numbered_tips[3] = line[2:].strip()
        if len(numbered_tips) != 3 or not all((i in numbered_tips for i in [1, 2, 3])):
            return False
        for i in [1, 2, 3]:
            tip_text = numbered_tips[i]
            if not (tip_text.startswith('تأكد ') or tip_text == 'تأكد'):
                return False
        return True



class DataIdx1344InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1344')

    def check_following(self, value):
        """Checks if the response is a paragraph about travel that does not mention airplanes.
        The primary constraint checked is the absence of words related to airplanes.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (does not mention airplanes), False otherwise.
        """
        forbidden_words = ['طائرة', 'طائرات', 'الطيارات']
        for word in forbidden_words:
            if word in value:
                return False
        return True



class DataIdx1345InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1345')

    def check_following(self, value):
        """Checks if the response contains any punctuation marks.
        Args:
            value: A string representing the response (slogan).

        Returns:
            True if the response contains no punctuation, False otherwise.
        """
        if not isinstance(value, str):
            return False
        for char in value:
            if unicodedata.category(char).startswith('P'):
                return False
        return True



class DataIdx1346InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1346')

    def check_following(self, value):
        """Checks if the response starts with 'لماذا', ends with exactly one '?'
        and contains only one question mark in total.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        starts_with_لماذا = value.strip().startswith('لماذا')
        ends_with_qm = value.strip().endswith('?')
        qm_count = value.strip().count('?')
        has_exactly_one_qm_at_end = ends_with_qm and qm_count == 1
        return starts_with_لماذا and has_exactly_one_qm_at_end



class DataIdx1347InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1347')

    def check_following(self, value):
        """Checks if the response follows the instruction: explain a concept without using the word 'مفهوم'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        forbidden_word = 'مفهوم'
        return forbidden_word not in value



class DataIdx1348InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        pass

    def check_following(self, value):
        """Checks if the response is a paragraph of at least 6 sentences,
           and each sentence contains at least one word starting with a potential present tense prefix (أ, ن, ي, ت).
           This is a weak heuristic for the Arabic present tense constraint without full NLP.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentences = re.split('[.?!؟!\\n]+', value)
        cleaned_sentences = [s.strip() for s in sentences if s.strip()]
        if len(cleaned_sentences) < 6:
            return False
        present_prefixes = ['أ', 'ن', 'ي', 'ت']
        for sentence in cleaned_sentences:
            words = sentence.split()
            sentence_has_present_indicator = False
            for word in words:
                if word and word[0] in present_prefixes:
                    sentence_has_present_indicator = True
                    break
            if not sentence_has_present_indicator:
                return False
        return True



class DataIdx1349InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1349')

    def check_following(self, value):
        """
        Checks if the response is a list of exactly three items,
        where each item is on a new line and is not empty.
        (Programmatic checking for 'starts with imperative verb' is not feasible
        without a dedicated Arabic NLP library or lexicon).

        Args:
            value: A string representing the response.

        Returns:
            True if the response represents a list of exactly 3 non-empty lines,
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = [line.strip() for line in value.splitlines()]
        non_empty_lines = [line for line in lines if line]
        if len(non_empty_lines) != 3:
            return False
        return True



class DataIdx1350InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1350')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 1350.

        Constraints:
        - The words 'اللغة' and 'العربية' must appear at least three times each.
        - (The constraint about lowercase letters is not applicable to standard Arabic script).

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lugha_count = value.count('اللغة')
        arabiyyah_count = value.count('العربية')
        return lugha_count >= 3 and arabiyyah_count >= 3



class DataIdx1351InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1351')

    def check_following(self, value):
        """Checks if the response is a numbered list of 5 tips in Arabic,
           including the word 'ممارسة', based on detectable constraints.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the detectable instructions or False otherwise.
        """
        if not isinstance(value, str):
            return False
        has_practice_word = 'ممارسة' in value
        lines = value.strip().split('\n')
        numbered_items_count = 0
        list_item_pattern = re.compile('^\\s*\\d+[\\.\\)]\\s*(.*)')
        for line in lines:
            if list_item_pattern.match(line):
                numbered_items_count += 1
        is_five_items = numbered_items_count == 5
        return is_five_items and has_practice_word



class DataIdx1352InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1352')

    def check_following(self, value):
        """Checks if the response follows the constraints for question 1352.
        Constraints:
        1. Must be valid JSON.
        2. Must not contain the word "مرادف".
        3. The JSON value must be a single word string.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        try:
            parsed_json = json.loads(value)
        except json.JSONDecodeError:
            return False
        if not isinstance(parsed_json, str):
            return False
        words = parsed_json.split()
        if len(words) != 1:
            return False
        if 'مرادف' in value:
            return False
        return True



class DataIdx1353InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1353')

    def check_following(self, value):
        """Checks if the response explains the difference between a noun and a verb in exactly two numbered sentences (1. and 2.).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        found_1 = False
        found_2 = False
        for line in lines:
            stripped_line = line.strip()
            if not stripped_line:
                continue
            if stripped_line.startswith('1.'):
                if found_1:
                    return False
                found_1 = True
            elif stripped_line.startswith('2.'):
                if found_2:
                    return False
                found_2 = True
            else:
                return False
        return found_1 and found_2



class DataIdx1354InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1354')

    def check_following(self, value):
        """Checks if the response follows the verifiable instructions:
        - Is at least 7 sentences long.
        (Cannot verify paragraph count, content description, or specific name mention programmatically).

        Args:
            value: A string representing the response.

        Returns:
            True if the response has at least 7 sentences, False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentence_pattern = '[^.!?؟]+[.!?؟]|\\s*[^.!?؟]+$'
        sentences = re.findall(sentence_pattern, value.strip())
        sentences = [s for s in sentences if s and s.strip()]
        sentence_count = len(sentences)
        if sentence_count < 7:
            return False
        return True



class DataIdx1355InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1355')

    def check_following(self, value):
        """Checks if the response is a single sentence expressing opinion on education's importance
           and contains the word 'ضروري' at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        trimmed_value = value.strip()
        has_keyword = 'ضروري' in value
        if not has_keyword:
            return False
        terminal_punctuations = ['.', '!', '?']
        if not trimmed_value:
            return False
        ends_with_punctuation = trimmed_value[-1] in terminal_punctuations
        if not ends_with_punctuation:
            return False
        substring_before_end = trimmed_value[:-1]
        contains_internal_punctuation = any((p in substring_before_end for p in terminal_punctuations))
        if contains_internal_punctuation:
            return False
        return True



class DataIdx1356InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1356')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 1356.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        has_saada = 'سعادة' in value
        ends_with_period_correctly = value.endswith('.') and len(value) > 1
        punctuation_ok = False
        if ends_with_period_correctly:
            string_before_end = value[:-1]
            other_punctuation_chars = '،؛؟!():[]{}<>"\'`~@#$%^&*_-+='
            has_other_punctuation_before_end = False
            for char in string_before_end:
                if char in other_punctuation_chars:
                    has_other_punctuation_before_end = True
                    break
            punctuation_ok = not has_other_punctuation_before_end
        return has_saada and punctuation_ok



class DataIdx1357InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1357')

    def check_following(self, value):
        """
        Checks if the response is a rewrite of the sentence 'الحديقة جميلة في فصل الربيع'
        using a synonym for 'جميل' and without using the word 'رائع'.

        Args:
            value: A string representing the response (the rewritten sentence).

        Returns:
            True if the response follows the instruction (uses a synonym for
            'جميل' and does not use 'رائع'), False otherwise.
        """
        forbidden_word = 'رائع'
        acceptable_synonyms = ['ساحرة', 'خلابة', 'بهية', 'فاتنة', 'بديعة']
        if forbidden_word in value:
            return False
        has_synonym = False
        for synonym in acceptable_synonyms:
            if f' {synonym} ' in f' {value} ':
                has_synonym = True
                break
        return has_synonym



class DataIdx1358InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1358')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1358.

        Instructions: Write a short paragraph no more than three sentences about the importance of sports in students' lives.
        The paragraph must contain the word 'صحة'.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instructions (contains 'صحة', no more than 3 sentences),
            False otherwise.
        """
        if 'صحة' not in value:
            return False
        sentences = []
        temp_sentence = ''
        for char in value:
            temp_sentence += char
            if char in '.!?':
                if temp_sentence.strip():
                    sentences.append(temp_sentence.strip())
                temp_sentence = ''
        if temp_sentence.strip():
            sentences.append(temp_sentence.strip())
        if len(sentences) > 3:
            return False
        return True



class DataIdx1359InstructionChecker(IFevalSynArInstructions):
    """Checks constraints for question IDX 1359."""

    def __init__(self):
        super().__init__('idx_1359')

    def check_following(self, value):
        """Checks if the poem contains at least 5 words starting with 'ر'.

        Args:
            value: A string representing the response (the poem).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        arabic_word_pattern = re.compile('[\\u0600-\\u06FF]+')
        words = arabic_word_pattern.findall(value)
        count_ra_words = 0
        for word in words:
            if word.startswith('ر'):
                count_ra_words += 1
        return count_ra_words >= 5



class DataIdx1360InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1360')

    def check_following(self, value):
        """Checks if the response contains exactly three sentences based on punctuation.
        A sentence is considered to end with '.', '!', or '?'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response has exactly 3 sentences, False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentence_count = 0
        potential_sentence_buffer = ''
        for char in value:
            potential_sentence_buffer += char
            if char in ('.', '!', '?'):
                content_before_punctuation = potential_sentence_buffer[:-1].strip()
                if content_before_punctuation:
                    sentence_count += 1
                potential_sentence_buffer = ''
        return sentence_count == 3



class DataIdx1361InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1361')

    def check_following(self, value):
        """Checks if the response is a formal letter in exactly two paragraphs separated by '***'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (structurally) or False otherwise.
        """
        separator = '***'
        if separator not in value:
            return False
        parts = value.split(separator)
        if len(parts) != 2:
            return False
        paragraph1 = parts[0].strip()
        paragraph2 = parts[1].strip()
        if not paragraph1 or not paragraph2:
            return False
        return True



class DataIdx1362InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1362')

    def check_following(self, value):
        """Checks if the response contains three different questions, all starting with 'لماذا'
        and related to the topic 'أهمية التعليم'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = [line.strip() for line in value.split('\n')]
        questions = [line for line in lines if line]
        if len(questions) != 3:
            return False
        if len(set(questions)) != 3:
            return False
        for q in questions:
            if not q.startswith('لماذا'):
                return False
            if not q.rstrip().endswith('?'):
                return False
            content_part = q[len('لماذا'):].rstrip()
            if not content_part.endswith('?'):
                return False
            content = content_part[:-1].strip()
            if not content:
                return False
        return True



class DataIdx1363InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1363')

    def check_following(self, value):
        """Checks if the response is a single German sentence about winter,
        containing 'Schnee' at least once and a colon at least once,
        and appears to be a single sentence based on punctuation.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        has_schnee = value.count('Schnee') >= 1
        has_colon = value.count(':') >= 1
        sentence_enders = ['.', '!', '?']
        sentence_ender_count = sum((value.count(ender) for ender in sentence_enders))
        is_single_sentence = sentence_ender_count <= 1
        return has_schnee and has_colon and is_single_sentence



class DataIdx1364InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1364')

    def check_following(self, value):
        """Checks if the response is a persuasive letter in Arabic about the benefits of exercise,
        mentioning the words "الصحة" and "الرفاهية" and using "أنت" and "نحن".

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains 'الصحة', 'الرفاهية', 'أنت', and 'نحن',
            False otherwise.
        """
        required_words = ['الصحة', 'الرفاهية', 'أنت', 'نحن']
        all_present = all((word in value for word in required_words))
        return all_present



class DataIdx1365InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1365')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1365.
        Instructions:
        1. Single sentence.
        2. Describe the color of the sky on a sunny day (content - hard to check).
        3. Must contain the word 'أزرق'.
        4. The word 'السماء' must be in parentheses ( ).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the structural/keyword instructions, False otherwise.
        """
        if 'أزرق' not in value:
            return False
        if '(السماء)' not in value:
            return False
        terminal_punctuation_count = 0
        for char in value:
            if char in ['.', '!', '?']:
                terminal_punctuation_count += 1
        if terminal_punctuation_count > 1:
            return False
        return True



class DataIdx1366InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1366')

    def check_following(self, value):
        """Checks if the response contains exactly three non-empty parts separated by commas only.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        parts = value.split('،')
        if len(parts) != 3:
            return False
        for part in parts:
            if not part.strip():
                return False
        return True



class DataIdx1367InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1367')

    def check_following(self, value):
        """
        Checks if the response is a self-introduction in Arabic for a job application
        that is less than 150 words and mentions key skills.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.strip().split()
        word_count = len(words)
        if word_count >= 150:
            return False
        skill_keywords = ['مهاراتي', 'مهارات', 'خبرة في', 'خبرة', 'أمتلك', 'القدرة على', 'قوي في', 'متخصص في', 'يجيد', 'أجيد', 'لدي']
        text_lower = value.lower()
        mentions_skills = any((keyword in text_lower for keyword in skill_keywords))
        return mentions_skills



class DataIdx1368InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1368')

    def check_following(self, value):
        """Checks if the response is a prayer wishing good and peace for the world and includes the word 'سلام' at least twice.
        Args:
            value: A string representing the response (the student's prayer).

        Returns:
            True if the response includes the substring 'سلام' at least twice, False otherwise.
        """
        count_salam = value.count('سلام')
        return count_salam >= 2



class DataIdx1369InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1369')

    def check_following(self, value):
        """Checks if the response contains exactly three items separated by commas.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        items = value.split(',')
        if len(items) != 3:
            return False
        for item in items:
            if not item.strip():
                return False
        return True



class DataIdx1370InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1370')

    def check_following(self, value):
        """Checks if the response mentions a school subject, as required by the instruction.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if a common school subject is mentioned in the response, False otherwise.
        """
        subjects = ['الرياضيات', 'العلوم', 'اللغة العربية', 'التاريخ', 'الجغرافيا', 'الفيزياء', 'الكيمياء', 'الأحياء', 'اللغة الإنجليزية', 'التربية الإسلامية', 'الفنون', 'الحاسوب', 'الرياضة', 'الموسيقى', 'مادة الرياضيات', 'مادة العلوم', 'مادة اللغة العربية', 'مادة التاريخ', 'مادة الجغرافيا', 'مادة الفيزياء', 'مادة الكيمياء', 'مادة الأحياء', 'مادة اللغة الإنجليزية', 'مادة التربية الإسلامية', 'مادة الفنون', 'مادة الحاسوب', 'مادة الرياضة', 'مادة الموسيقى']
        for subject in subjects:
            if subject in value:
                return True
        return False



class DataIdx1371InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1371')

    def check_following(self, value):
        """Checks if the response follows the constraints for question 1371.
        Constraints:
        - Must contain '(التكنولوجيا)'
        - Must contain '(التعليم)'
        - Must contain ''تحليل''

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        contains_tech_paren = '(التكنولوجيا)' in value
        contains_edu_paren = '(التعليم)' in value
        contains_analysis_quotes = "'تحليل'" in value
        return contains_tech_paren and contains_edu_paren and contains_analysis_quotes



class DataIdx1372InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1372')

    def check_following(self, value):
        """
        Checks if the response follows the instructions for IDX 1372:
        - Exactly 60 words.
        - Contains the keyword 'التقييم' exactly once.
        - The keyword is approximately in the middle (word index 25-35).
        """
        words = re.findall('\\b\\w+\\b', value, re.UNICODE)
        if len(words) != 60:
            return False
        keyword = 'التقييم'
        keyword_count = words.count(keyword)
        if keyword_count != 1:
            return False
        try:
            keyword_index = words.index(keyword)
            if not 25 <= keyword_index <= 35:
                return False
        except ValueError:
            return False
        return True



class DataIdx1373InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1373')

    def check_following(self, value):
        """Checks if the response is in Arabic and consists of exactly two sentences.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        if not re.search('[\\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF\\uFB50-\\uFDFF\\uFE70-\\uFEFF]', value):
            return False
        segments = re.split('[.!?]', value)
        non_empty_segments = [s for s in segments if s.strip()]
        if len(non_empty_segments) != 2:
            return False
        return True



class DataIdx1374InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1374')

    def check_following(self, value):
        """
        Checks if the response follows the instructions for IDX 1374.
        - Paragraph length: 6 to 8 sentences.
        - Mentions at least three prominent Cairo landmarks.
        - Uses the word 'أضواء' at least twice.
        """
        if not isinstance(value, str):
            return False
        sentences = re.split('[.!?؟]', value)
        sentences = [s.strip() for s in sentences if s.strip()]
        sentence_count = len(sentences)
        if not 6 <= sentence_count <= 8:
            return False
        prominent_landmarks = ['برج القاهرة', 'الأهرامات', 'قلعة صلاح الدين', 'كورنيش النيل', 'النيل', 'المتحف المصري', 'الأزهر', 'خان الخليلي']
        mentioned_landmarks_count = 0
        for landmark in prominent_landmarks:
            if landmark in value:
                mentioned_landmarks_count += 1
        if mentioned_landmarks_count < 3:
            return False
        keyword = 'أضواء'
        keyword_count = value.count(keyword)
        if keyword_count < 2:
            return False
        return True



class DataIdx1375InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1375')

    def check_following(self, value):
        """Checks if the response is a short story for children not exceeding 200 words
           and using the colon (:) exactly once.

        Args:
            value: A string representing the response (the story).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        word_count = len(words)
        colon_count = value.count(':')
        if word_count <= 200 and colon_count == 1:
            return True
        else:
            return False



class DataIdx1376InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1376')

    def check_following(self, value):
        """Checks if the response is a string and has at least 100 words,
        based on the question's constraints.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is a string and meets the minimum word count,
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return word_count >= 100



class DataIdx1377InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1377')

    def check_following(self, value):
        """Checks if the response follows the constraints for question 1377.
        Constraints:
        1. Single paragraph.
        2. At least 3 sentences.
        3. Starts with 'لقد وجدت مؤخرًا...'.
        4. Ends with 'مفيد'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if '\n\n' in value.strip():
            return False
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        start_phrase_full = 'لقد وجدت مؤخرًا...'
        if not cleaned_value.startswith(start_phrase_full):
            return False
        end_word = 'مفيد'
        if not cleaned_value.endswith(end_word):
            return False
        sentences = re.split('[.؟!]\\s*', cleaned_value)
        valid_sentences = [s for s in sentences if s.strip()]
        sentence_count = len(valid_sentences)
        if sentence_count < 3:
            return False
        return True



class DataIdx1378InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1378')

    def check_following(self, value):
        """Checks if the value is formatted as a numbered list.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (is a numbered list) or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        lines = value.strip().split('\n')
        expected_number = 1
        found_numbered_item = False
        for line in lines:
            stripped_line = line.strip()
            if not stripped_line:
                continue
            match = re.match('^\\s*(\\d+)\\s*[\\.\\)]\\s*(.*)$', stripped_line)
            if match:
                current_number_str = match.group(1)
                try:
                    current_number = int(current_number_str)
                except ValueError:
                    return False
                if current_number != expected_number:
                    return False
                found_numbered_item = True
                expected_number += 1
            else:
                return False
        return found_numbered_item



class DataIdx1379InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1379')

    def check_following(self, value):
        """Checks if the response defines creative thinking, provides an example, and includes the word 'حلول'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        required_word = 'حلول'
        if required_word in value:
            return True
        else:
            return False



class DataIdx1380InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1380')

    def check_following(self, value):
        """Checks if the response (Arabic paragraph) adheres to the constraint
        that no sentence exceeds ten words.

        Args:
            value: A string representing the response containing an Arabic paragraph.

        Returns:
            True if every sentence in the response has 10 words or fewer,
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentence_terminators = ['.', '!', '?']
        temp_value = value
        for terminator in sentence_terminators:
            temp_value = temp_value.replace(terminator, '###')
        sentences = temp_value.split('###')
        for sentence in sentences:
            stripped_sentence = sentence.strip()
            if not stripped_sentence:
                continue
            words = stripped_sentence.split()
            if len(words) > 10:
                return False
        return True



class DataIdx1381InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1381')

    def check_following(self, value):
        """Checks if the response is an Arabic question about tolerance,
        starts with 'كيف يمكننا', and is between 15 and 20 words.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        trimmed_value = value.strip()
        prefix = 'كيف يمكننا'
        if not trimmed_value.startswith(prefix):
            return False
        words = trimmed_value.split()
        word_count = len(words)
        min_words = 15
        max_words = 20
        if not min_words <= word_count <= max_words:
            return False
        return True



class DataIdx1382InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1382')

    def check_following(self, value):
        """Checks if the response is a definition of AI in less than 20 words.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (less than 20 words) or False otherwise.
        """
        words = value.split()
        word_count = len(words)
        return word_count < 20



class DataIdx1383InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1383')

    def check_following(self, value):
        """
        Checks if the response is a single sentence and contains at least two words starting with 'ال'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentence_terminators = ['.', '?', '!']
        total_terminator_count = sum((value.count(char) for char in sentence_terminators))
        if total_terminator_count > 1:
            return False
        words = value.split()
        al_word_count = 0
        arabic_punctuation = '.,!?;:"\'()[]{}-_«»—'
        for word in words:
            cleaned_word = word.strip(arabic_punctuation)
            if cleaned_word.startswith('ال'):
                al_word_count += 1
        if al_word_count < 2:
            return False
        return True



class DataIdx1384InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1384')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 1384.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        ending_phrase = 'هل هناك أي شيء آخر يمكنني مساعدتك به؟'
        if not value.endswith(ending_phrase):
            return False
        ending_phrase_start_index = value.rfind(ending_phrase)
        summary_part_raw = value[:ending_phrase_start_index]
        if ',' in summary_part_raw:
            return False
        summary_words = summary_part_raw.split()
        if len(summary_words) >= 40:
            return False
        return True



class DataIdx1385InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1385')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1385.

        Instructions:
        1. Write one line of poetry about the desert.
        2. Do not use the word 'صحراء'.
        3. Emphasize/highlight the first word.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        value_stripped = value.strip()
        if '\n' in value:
            return False
        if 'صحراء' in value:
            return False
        inner_word = None
        len_emphasized_block = 0
        if value_stripped.startswith('**'):
            end_star_idx = value_stripped.find('**', 2)
            if end_star_idx != -1:
                potential_emphasized_block = value_stripped[:end_star_idx + 2]
                inner_word = value_stripped[2:end_star_idx]
                len_emphasized_block = len(potential_emphasized_block)
        elif value_stripped.startswith('<b>'):
            end_b_idx = value_stripped.find('</b>', 3)
            if end_b_idx != -1:
                potential_emphasized_block = value_stripped[:end_b_idx + 4]
                inner_word = value_stripped[3:end_b_idx]
                len_emphasized_block = len(potential_emphasized_block)
        if inner_word is None or not inner_word.strip():
            return False
        if len_emphasized_block < len(value_stripped) and (not value_stripped[len_emphasized_block].isspace()):
            return False
        if ' ' in inner_word.strip():
            return False
        return True



class DataIdx1386InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1386')

    def check_following(self, value):
        """Checks if the response is an informal email inviting a friend to a party based on keywords and structure.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        text = value
        if 'حفلة' not in text:
            return False
        invitation_keywords = ['أدعو', 'تعال', 'تعالي', 'تعالوا', 'عزومة', 'تيجي', 'تعزم', 'عزمتك', 'معزوم']
        found_invitation = False
        for keyword in invitation_keywords:
            if keyword in text:
                found_invitation = True
                break
        if not found_invitation:
            return False
        if 'موضوع:' not in text and 'subject:' not in text.lower():
            return False
        informal_indicators = ['سلام', 'أهلًا', 'إزيك', 'كيفك', 'شلونك', 'يا صاحبي', 'يا زميلي', 'مع السلامة', 'تحياتي', 'يلا باي', 'باي', 'تمام', 'كتير']
        found_informal = False
        for indicator in informal_indicators:
            if indicator in text:
                found_informal = True
                break
        if not found_informal:
            return False
        formal_markers = ['السيد المحترم', 'السادة الكرام', 'وتفضلوا بقبول فائق الاحترام', 'وبعد', 'يشرفني', 'نفيدكم علما', 'تحية طيبة وبعد']
        for marker in formal_markers:
            if marker in text:
                return False
        return True



class DataIdx1387InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1387')

    def check_following(self, value):
        """Checks if the response contains the word 'تطور' and is at least 10 words long.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        word_to_check = 'تطور'
        if word_to_check not in value:
            return False
        words = value.split()
        word_count = len(words)
        if word_count < 10:
            return False
        return True



class DataIdx1388InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1388')

    def check_following(self, value):
        """Checks if the response is the English translation "The book is on the table." enclosed in single quotes.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if len(value) < 3:
            return False
        if value[0] != "'" or value[-1] != "'":
            return False
        content = value[1:-1]
        expected_translations = ['The book is on the table.', 'the book is on the table.', 'The book is on the table', 'the book is on the table']
        if content in expected_translations:
            return True
        return False



class DataIdx1389InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1389')

    def check_following(self, value):
        """Checks if the response is a sentence in Arabic, uses the word 'تكنولوجيا',
           and is at least five words long.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if 'تكنولوجيا' not in value:
            return False
        words = value.split()
        if len(words) < 5:
            return False
        return True



class DataIdx1390InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1390')

    def check_following(self, value):
        """Checks if the response is a recognized renewable energy source fitting the blank.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is a valid renewable energy source, False otherwise.
        """
        accepted_answers = {'الطاقة الشمسية', 'طاقة الرياح', 'الطاقة الكهرومائية', 'الطاقة الحرارية الجوفية', 'طاقة الكتلة الحيوية', 'الوقود الحيوي', 'الهيدروجين الأخضر', 'الشمسية', 'الرياح', 'الكهرومائية', 'الشمس', 'الهيدروجين', 'الكتلة الحيوية', 'الشمس والرياح', 'الطاقة المتجددة'}
        normalized_value = value.strip()
        return normalized_value in accepted_answers



class DataIdx1391InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1391')

    def check_following(self, value):
        """Checks if the response is an advertisement for a digital photo frame that focuses on ease of use, 
           mentions 'سهل' at least twice, and is between 65 and 95 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instructions or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if not 65 <= word_count <= 95:
            return False
        سهل_count = words.count('سهل')
        if سهل_count < 2:
            return False
        return True



class DataIdx1392InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1392')

    def check_following(self, value):
        """
        Checks if the response contains exactly three questions, each starting with 'كيف',
        and uses only the Arabic question mark '؟' as punctuation.
        The topic constraint ("الذكاء الاصطناعي في التعليم") is not checked programmatically.
        """
        if not isinstance(value, str):
            return False
        value = value.strip()
        allowed_chars = set(' ؟0123456789')
        disallowed_punctuation = '.,!:;()[]{}"\'/\\-_*&^%$#@~`+=<>،؛'
        if any((char in disallowed_punctuation for char in value)):
            return False
        if value.count('؟') != 3:
            return False
        if not value.endswith('؟'):
            return False
        parts = value.split('؟')
        if len(parts) != 4:
            return False
        if parts[-1] != '':
            return False
        for i in range(3):
            question_part = parts[i].strip()
            if not question_part:
                return False
            words = question_part.split(maxsplit=1)
            if not words:
                return False
            if words[0] != 'كيف':
                return False
        return True



class DataIdx1393InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1393')

    def check_following(self, value):
        """Checks if the response is in the form of a dialogue between two people.
        It looks for lines starting with a potential speaker name followed by a
        common separator like ':', '-' or '—' and some content. It then checks
        if exactly two distinct potential speakers are identified.
        """
        lines = value.strip().split('\n')
        speakers = set()
        found_dialogue_line = False
        for line in lines:
            line = line.strip()
            if not line:
                continue
            separator_index = -1
            separator_char = None
            for sep in [':', '-', '—']:
                idx = line.find(sep)
                if idx > 0 and idx < len(line) - 1 and line[idx + 1:].strip():
                    potential_speaker_part = line[:idx].strip()
                    if potential_speaker_part:
                        separator_index = idx
                        separator_char = sep
                        break
            if separator_index != -1:
                potential_speaker = line[:separator_index].strip()
                speakers.add(potential_speaker)
                found_dialogue_line = True
        return len(speakers) == 2 and found_dialogue_line



class DataIdx1394InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1394')

    def check_following(self, value):
        """Checks if the response follows the constraints:
        1. Is a short story (implied, not strictly checked beyond length).
        2. Is about an orphaned animal finding a friend (not programmatically checked for meaning).
        3. Consists of at least five sentences.
        4. Ends with the phrase 'وعاشا بسعادة'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the verifiable instructions (at least 5 sentences, ends with the specific phrase), False otherwise.
        """
        required_ending = 'وعاشا بسعادة'
        min_sentences = 5
        if not value.strip().endswith(required_ending):
            return False
        sentence_enders = ['.', '؟', '!']
        punctuation_count = sum((value.count(ender) for ender in sentence_enders))
        segments = []
        last_idx = 0
        for i in range(len(value)):
            if value[i] in sentence_enders:
                segments.append(value[last_idx:i + 1].strip())
                last_idx = i + 1
        remaining = value[last_idx:].strip()
        if remaining:
            segments.append(remaining)
        non_empty_segments = [segment for segment in segments if segment]
        sentence_count = len(non_empty_segments)
        if sentence_count < min_sentences:
            return False
        return True



class DataIdx1395InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1395')

    def check_following(self, value):
        """Checks if the response follows the constraints for the fruit salad recipe question.

        Args:
            value: A string representing the response (the recipe).

        Returns:
            True if the response includes an ingredients list, preparation steps,
            and does not exceed 100 words; False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value_for_word_count = ' '.join(value.split())
        words = cleaned_value_for_word_count.split()
        word_count = len(words)
        if word_count > 100:
            return False
        has_ingredients_section = 'المكونات' in value or 'قائمة بالمكونات' in value
        has_steps_section = 'خطوات التحضير' in value or 'طريقة التحضير' in value
        return has_ingredients_section and has_steps_section



class DataIdx1396InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1396')

    def check_following(self, value):
        """Checks if the response is a detailed description of a landscape
           in at least five paragraphs, where each paragraph starts with 'المنظر',
           and contains at least 80 sentences.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        text = value.strip()
        if not text:
            return False
        paragraphs = re.split('\\n\\s*\\n+', text)
        paragraphs = [p for p in paragraphs if p.strip()]
        if len(paragraphs) < 5:
            return False
        for para in paragraphs:
            stripped_para = para.strip()
            if not stripped_para.startswith('المنظر'):
                return False
        sentences = re.split('[.؟!]+(?:\\s+|\\Z)', text)
        sentence_count = 0
        for sentence in sentences:
            if sentence.strip():
                sentence_count += 1
        if sentence_count < 80:
            return False
        return True



class DataIdx1397InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1397')

    def check_following(self, value):
        """Checks if the response follows the instruction for question 1397.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if not (value.startswith('<<') and value.endswith('>>')):
            return False
        if len(value) < len('<<>>') + 1:
            return False
        content = value[2:-2]
        stripped_content = content.strip()
        if not stripped_content:
            return False
        sentence_enders = '.!?'
        if stripped_content[-1] not in sentence_enders:
            return False
        ender_count = 0
        for char in stripped_content:
            if char in sentence_enders:
                ender_count += 1
        if ender_count != 1:
            return False
        return True



class DataIdx1398InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1398')

    def find_list_with_min_length(self, data, min_len):
        """Recursively searches for a list within the data structure with at least min_len items."""
        if isinstance(data, list):
            if len(data) >= min_len:
                return True
            for item in data:
                if self.find_list_with_min_length(item, min_len):
                    return True
        elif isinstance(data, dict):
            for value in data.values():
                if self.find_list_with_min_length(value, min_len):
                    return True
        return False

    def check_following(self, value):
        """
        Checks if the response is valid JSON and contains a list with at least 3 elements.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        try:
            json_data = json.loads(value)
        except json.JSONDecodeError:
            return False
        return self.find_list_with_min_length(json_data, 3)



class DataIdx1399InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1399')

    def check_following(self, value):
        """Checks if the response explains planning in two sentences and uses 'مستقبل' at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (two sentences, uses 'مستقبل'), False otherwise.
        """
        if not isinstance(value, str):
            return False
        if 'مستقبل' not in value:
            return False
        terminal_punctuations = len(re.findall('[.!?]', value))
        sentences = [s.strip() for s in re.split('[.!?]', value) if s.strip()]
        if len(sentences) != 2:
            return False
        return True



class DataIdx1400InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1400')

    def check_following(self, value):
        """Checks if the response is an Arabic poem about nature with at least 4 verses.
           Focuses on structural checks: minimum 4 non-empty lines and presence of Arabic characters.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction's structural constraints, False otherwise.
        """
        if not isinstance(value, str):
            return False
        has_arabic_chars = any(('\u0600' <= char <= 'ۿ' for char in value))
        if not has_arabic_chars:
            return False
        lines = value.strip().split('\n')
        non_empty_lines = [line.strip() for line in lines if line.strip()]
        if len(non_empty_lines) < 4:
            return False
        return True



class DataIdx1401InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1401')

    def check_following(self, value: str):
        """Checks if the response is a list of exactly three questions,
        each starting with 'ما هو' in Arabic.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        questions = [line.strip() for line in lines if line.strip()]
        if len(questions) != 3:
            return False
        for q in questions:
            if not q.startswith('ما هو'):
                return False
        return True



class DataIdx1402InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1402')

    def count_sentences(self, text):
        """Counts sentences by splitting on common terminators, ignoring empty strings."""
        if not text:
            return 0
        text = text.replace('!', '.').replace('?', '.')
        sentences = text.split('.')
        valid_sentences = [s.strip() for s in sentences if s.strip()]
        return len(valid_sentences)

    def count_words(self, text):
        """Counts words by splitting on whitespace."""
        if not text:
            return 0
        words = text.split()
        return len(words)

    def check_following(self, value):
        """
        Checks if the response follows the instruction for IDX 1402.
        Constraints:
        1. Must contain the exact core text.
        2. Introduction (part before core text) has >= 2 sentences.
        3. Conclusion (part after core text) has >= 2 sentences.
        4. Total article word count <= 100.
        """
        core_text = 'الرياضة ضرورية لصحة الجسم والعقل. ممارسة الرياضة بانتظام تقوي العضلات وتحسن الدورة الدموية وتقلل من خطر الإصابة بالأمراض المزمنة. كما أنها تساعد على تخفيف التوتر وتحسين المزاج.'
        if self.count_words(value) > 100:
            return False
        start_index = value.find(core_text)
        if start_index == -1:
            return False
        end_index = start_index + len(core_text)
        intro_part = value[:start_index].strip()
        conclusion_part = value[end_index:].strip()
        if self.count_sentences(intro_part) < 2:
            return False
        if self.count_sentences(conclusion_part) < 2:
            return False
        return True



class DataIdx1403InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1403')

    def check_following(self, value):
        """Checks if the response is a single sentence ending with a terminal punctuation mark.
        This check serves as a proxy for the "single sentence" constraint.
        Constraints regarding problem/solution description and environmental topic are
        not checked programmatically due to the need for semantic analysis beyond simple code.

        Args:
            value: A string representing the response.

        Returns:
            True if the response appears to be a single sentence ending with ., !, or ?,
            and contains no other ., !, or ? characters before the last one.
            Returns False otherwise.
        """
        if not isinstance(value, str):
            return False
        text = value.strip()
        if not text:
            return False
        terminal_punctuation = ['.', '!', '?']
        if text[-1] not in terminal_punctuation:
            return False
        for i in range(len(text) - 1):
            if text[i] in terminal_punctuation:
                return False
        return True



class DataIdx1404InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1404')

    def check_following(self, value):
        """Checks if the response is a "rhyming answer" by ensuring it contains more than one word.
        This is a simplified check due to the ambiguity of the instruction without context.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains more than one word, False otherwise.
        """
        stripped_value = value.strip()
        words = stripped_value.split()
        return len(words) > 1



class DataIdx1405InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1405')

    def check_following(self, value):
        """Checks if the response is a short dialogue planning a trip to a historical city,
           mentioning three places to visit and an approximate date.

        Args:
            value: A string representing the response (the dialogue).

        Returns:
            True if the response appears to follow the main quantifiable constraints (three places, one date),
            False otherwise.
        """
        date_keywords = ['يناير', 'فبراير', 'مارس', 'أبريل', 'مايو', 'يونيو', 'يوليو', 'أغسطس', 'سبتمبر', 'أكتوبر', 'نوفمبر', 'ديسمبر', 'كانون الثاني', 'شباط', 'آذار', 'نيسان', 'أيار', 'حزيران', 'تموز', 'آب', 'أيلول', 'تشرين الأول', 'تشرين الثاني', 'كانون الأول', 'الصيف', 'الشتاء', 'الربيع', 'الخريف', 'الشهر القادم', 'الأسبوع القادم', 'العام القادم', 'الشهر المقبل', 'الأسبوع المقبل', 'العام المقبل', 'في الصيف', 'في الشتاء', 'في الربيع', 'في الخريف', 'بعد أسبوع', 'بعد شهر', 'بعد سنة', 'موعد', 'تاريخ', 'وقت', 'الأسبوع المقبل', 'الشهر المقبل', 'السنة المقبلة', 'الشهر القادم', 'السنة القادمة']
        has_date = any((keyword in value for keyword in date_keywords))
        place_keywords_nearby = ['أماكن', 'وجهات', 'معالم', 'مواقع', 'أثرية', 'تاريخية', 'سياحية', 'المعالم', 'الأماكن', 'المواقع', 'الوجهات', 'مكان']
        three_word_pattern = re.compile('(ثلاثة?\\s+)')
        three_digit_pattern = re.compile('(?<!\\d)3\\s+(?!\\d)')
        match_three = three_word_pattern.search(value) or three_digit_pattern.search(value)
        has_three_places = False
        if match_three:
            start_index_after_three = match_three.end()
            text_after_three = value[start_index_after_three:]
            has_three_places = any((place_kw in text_after_three for place_kw in place_keywords_nearby))
        three_word_after_pattern = re.compile('(\\s+ثلاثة?)')
        three_digit_after_pattern = re.compile('(\\s+3)(?!\\d)')
        if not has_three_places:
            for place_kw in place_keywords_nearby:
                place_kw_pattern = re.compile(re.escape(place_kw) + '\\s+')
                for place_match in place_kw_pattern.finditer(value):
                    text_after_place_kw = value[place_match.end():]
                    if three_word_after_pattern.search(text_after_place_kw) or three_digit_after_pattern.search(text_after_place_kw):
                        has_three_places = True
                        break
                if has_three_places:
                    break
        return has_date and has_three_places



class DataIdx1406InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1406')

    def check_following(self, value):
        """Checks if the response is divided into three parts using numbers 1, 2, and 3 as markers.
        Args:
            value: A string representing the response (Arabic text).

        Returns:
            True if the response contains '1', then '2' after '1', and '3' after '2', False otherwise.
        """
        if not isinstance(value, str):
            return False
        idx1 = value.find('1')
        if idx1 == -1:
            return False
        idx2 = value.find('2', idx1 + 1)
        if idx2 == -1:
            return False
        idx3 = value.find('3', idx2 + 1)
        if idx3 == -1:
            return False
        return True



class DataIdx1407InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1407')

    def check_following(self, value):
        """Checks if the response follows the constraints for question 1407.
        Constraints:
        1. Contains the word 'مبتكر' at least once.
        2. Consists of exactly two sentences (checked by punctuation).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        contains_innovative = 'مبتكر' in value
        sentence_enders = ['.', '!', '?']
        sentence_count = sum((value.count(ender) for ender in sentence_enders))
        has_two_sentence_markers = sentence_count == 2
        ends_with_sentence_marker = value.strip().endswith(tuple(sentence_enders))
        is_two_sentences = has_two_sentence_markers and ends_with_sentence_marker
        return contains_innovative and is_two_sentences



class DataIdx1408InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1408')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1408.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        includes_keyword = 'المراجعة' in value
        words = value.split()
        word_count_ok = len(words) <= 25
        ends_with_question_mark = value.strip().endswith('؟')
        return includes_keyword and word_count_ok and ends_with_question_mark



class DataIdx1409InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1409')

    def check_following(self, value):
        """
        Checks if the response correctly classifies the given Arabic words
        into verbs (أفعال), nouns (أسماء), and particles (حروف).
        Assumes the response uses the category names as headings or indicators
        and lists the words associated with them.
        The response must classify all given words correctly, and only the given words from the original list.
        """
        correct_classification = {'أفعال': {'كتب', 'يلعب', 'قرأ'}, 'أسماء': {'المدرسة', 'طالب'}, 'حروف': {'في', 'إلى', 'على'}}
        all_given_words = correct_classification['أفعال'] | correct_classification['أسماء'] | correct_classification['حروف']
        student_classification = {'أفعال': set(), 'أسماء': set(), 'حروف': set()}
        cleaned_value = value.strip()
        category_patterns = {'أفعال': '\\bأفعال\\b', 'أسماء': '\\bأسماء\\b', 'حروف': '\\bحروف\\b'}
        category_names = list(category_patterns.keys())
        category_matches = []
        for cat_name, pattern in category_patterns.items():
            header_pattern = re.compile(f'({pattern})\\s*[:\\s]*', re.IGNORECASE)
            match = header_pattern.search(cleaned_value)
            if match:
                category_matches.append((match.start(1), cat_name, match.end()))
        found_category_names = {name for _, name, _ in category_matches}
        if found_category_names != set(category_names):
            return False
        category_matches.sort(key=lambda item: item[0])
        segments = {}
        for i in range(len(category_matches)):
            cat_name = category_matches[i][1]
            content_start_pos = category_matches[i][2]
            segment_end_pos = category_matches[i + 1][0] if i + 1 < len(category_matches) else len(cleaned_value)
            segment_text = cleaned_value[content_start_pos:segment_end_pos].strip()
            segments[cat_name] = segment_text
        word_splitter = re.compile('[\\s,\\-—:;•*+.\\u060C\\u061B\\u06D4]+')
        classified_words_set = set()
        for cat_name, text_segment in segments.items():
            potential_words = [word.strip() for word in word_splitter.split(text_segment) if word.strip()]
            for p_word in potential_words:
                if p_word in all_given_words:
                    student_classification[cat_name].add(p_word)
                    classified_words_set.add(p_word)
        if classified_words_set != all_given_words:
            return False
        for cat_name in category_names:
            if student_classification[cat_name] != correct_classification[cat_name]:
                return False
        return True



class DataIdx1410InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1410')

    def check_following(self, value):
        """Checks if the response is a single interrogative sentence in Arabic,
           starts with 'ما', and ends with exactly one question mark.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        if not cleaned_value.startswith('ما'):
            return False
        if not cleaned_value.endswith('?'):
            return False
        if cleaned_value.count('?') != 1:
            return False
        terminators = ['.', '!', ';']
        for terminator in terminators:
            if terminator in cleaned_value[:-1]:
                return False
        if len(cleaned_value) < 6:
            return False
        return True



class DataIdx1411InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1411')

    def check_following(self, value):
        """Checks if the response is a verbal sentence starting with a past verb,
        equivalent in meaning to 'الطلاب مجتهدون في دروسهم'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction, False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        acceptable_answers = {'اجتهد الطلاب في دروسهم', 'جدّ الطلاب في دروسهم'}
        return cleaned_value in acceptable_answers



class DataIdx1412InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1412')

    def check_following(self, value):
        """Checks if the response is a definition of "الديمقراطية" with a maximum of 50 words.
        Args:
            value: A string representing the response (the definition).

        Returns:
            True if the word count is 50 words or less, False otherwise.
        """
        words = value.strip().split()
        word_count = len(words)
        return word_count <= 50



class DataIdx1413InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1413')

    def check_following(self, value):
        """Checks if the response (comment) does not exceed 40 words.
        Args:
            value: A string representing the response (the comment).

        Returns:
            True if the word count is 40 or less, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        return len(words) <= 40



class DataIdx1414InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1414')

    def check_following(self, value):
        """Checks if the response is a descriptive name for a cafe serving traditional Arabic coffee
           and includes the word 'قهوة' at least once.

        Args:
            value: A string representing the proposed cafe name.

        Returns:
            True if the name includes 'قهوة', False otherwise.
        """
        return 'قهوة' in value



class DataIdx1415InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1415')

    def check_following(self, value):
        """Check if the response follows the instruction for IDX 1415.

        Constraints:
        1. Four numbered steps (1., 2., 3., 4.).
        2. Steps separated by '--'.
        3. The word 'خضروات' (vegetables) must appear exactly three times.
        4. Each step must start with a specific imperative verb from the list (اغسل, قطع, أضف, قدم).
           Based on the example in the prompt, it's assumed these verbs must appear in this order for steps 1, 2, 3, and 4 respectively.
        """
        khadrawat_count = value.count('خضروات')
        if khadrawat_count != 3:
            return False
        steps = value.split('--')
        if len(steps) != 4:
            return False
        required_verbs_in_order = ['اغسل', 'قطع', 'أضف', 'قدم']
        for i in range(4):
            step_text = steps[i].strip()
            expected_prefix = f'{i + 1}.'
            if not step_text.startswith(expected_prefix):
                return False
            step_content = step_text[len(expected_prefix):].strip()
            if not step_content:
                return False
            words = step_content.split()
            if not words:
                return False
            first_word = words[0]
            expected_verb = required_verbs_in_order[i]
            if first_word != expected_verb:
                return False
        return True



class DataIdx1416InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1416')

    def check_following(self, value):
        """Checks if the response is a recipe with exactly four numbered steps.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        numbered_step_count = 0
        step_pattern = re.compile('^\\s*\\d+[\\.\\)\\s].*')
        for line in lines:
            if step_pattern.match(line):
                numbered_step_count += 1
        return numbered_step_count == 4



class DataIdx1417InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1417')

    def check_following(self, value):
        """Checks if the response is a single Arabic question asking about the current time
        using the word 'الساعة' exactly once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        cleaned_value = value.strip()
        cleaned_value = ' '.join(cleaned_value.split())
        if cleaned_value.count('؟') != 1:
            return False
        words = []
        temp_value = cleaned_value.replace('؟', ' ؟ ')
        for word in temp_value.split():
            cleaned_word = word.rstrip('.,!?;:،؛')
            words.append(cleaned_word)
        saaa_count = words.count('الساعة')
        if saaa_count != 1:
            return False
        return True



class DataIdx1418InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1418')

    def check_following(self, value):
        """Checks if the response starts with 'اليوم' and is longer than just 'اليوم'.
        This checks the most explicit constraint. Checking for "simple nominal sentence"
        and "describing weather" robustly requires linguistic analysis.

        Args:
            value: A string representing the response.

        Returns:
            True if the response starts with 'اليوم' and is longer than 'اليوم', False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value.startswith('اليوم'):
            return False
        if len(cleaned_value) <= len('اليوم'):
            return False
        return True



class DataIdx1419InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1419')

    def check_following(self, value):
        """Checks if the response does not contain exclamation marks.
        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain any exclamation marks, False otherwise.
        """
        return '!' not in value



class DataIdx1420InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1420')

    def check_following(self, value):
        """Checks if the response is a single sentence expressing gratitude and containing 'شكراً'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if 'شكراً' not in value:
            return False
        sentence_enders = ['.', '!', '?']
        stripped_value = value.strip()
        if not stripped_value:
            return False
        end_punctuation_count = 0
        for char in stripped_value:
            if char in sentence_enders:
                end_punctuation_count += 1
        if end_punctuation_count != 1:
            return False
        if stripped_value[-1] not in sentence_enders:
            return False
        return True



class DataIdx1421InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1421')

    def check_following(self, value):
        """Checks if the response lists exactly three points using bullet points.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (three bullet points), False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        bullet_count = 0
        bullet_chars = ['-', '*', '+', '•']
        for line in lines:
            stripped_line = line.strip()
            if not stripped_line:
                continue
            is_bullet = False
            for char in bullet_chars:
                if stripped_line.startswith(char):
                    if len(stripped_line) > len(char):
                        if stripped_line[len(char)].isspace():
                            is_bullet = True
                            break
                        elif not stripped_line[len(char)].isspace():
                            is_bullet = True
                            break
                    elif len(stripped_line) == len(char):
                        is_bullet = True
                        break
            if is_bullet:
                bullet_count += 1
        return bullet_count == 3



class DataIdx1422InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1422')

    def check_following(self, value):
        """Checks if the response is in English by ensuring it does not contain Arabic script characters.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain Arabic script characters, False otherwise.
        """
        if not isinstance(value, str):
            return False
        arabic_script_range = (1536, 1791)
        for char in value:
            code_point = ord(char)
            if arabic_script_range[0] <= code_point <= arabic_script_range[1]:
                return False
        return True



class DataIdx1423InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1423')

    def check_following(self, value):
        """Checks if the response is a formal letter with at least 80 words.
        The constraint is primarily checking the word count.

        Args:
            value: A string representing the response.

        Returns:
            True if the response has at least 80 words, False otherwise.
        """
        words = value.split()
        word_count = len(words)
        return word_count >= 80



class DataIdx1424InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1424')

    def check_following(self, value):
        """Checks if the response (a poem) does not exceed 80 words.
        Args:
            value: A string representing the response (the poem).

        Returns:
            True if the word count is 80 or less, False otherwise.
        """
        words = value.split()
        word_count = len(words)
        return word_count <= 80



class DataIdx1425InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1425')

    def check_following(self, value):
        """Checks if the response follows the instructions for question 1425.

        Constraints:
        - Not exceed 100 words.
        - Mention the word 'شكراً' at least twice.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count > 100:
            return False
        keyword_count = 0
        punctuation = '.,!?:;()[]{}"\''
        for word in words:
            cleaned_word = word.strip(punctuation)
            if cleaned_word == 'شكراً':
                keyword_count += 1
        if keyword_count < 2:
            return False
        return True



class DataIdx1426InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1426')

    def check_following(self, value):
        """Checks if the response is an example of a pet animal starting with 'س' and does not contain 'قطة' or 'كلب'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        starts_with_seen = cleaned_value.startswith('س')
        contains_qittah = 'قطة' in cleaned_value
        contains_kalb = 'كلب' in cleaned_value
        return starts_with_seen and (not contains_qittah) and (not contains_kalb)



class DataIdx1427InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1427')

    def check_following(self, value):
        """Checks if the response discusses the importance of reading,
        mentioning at least two benefits (checked via keyword heuristic),
        and implies a positive tone (not explicitly checked programmatically).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if len(value.split()) < 20:
            return False
        if 'قراءة' not in value and 'القراءة' not in value:
            return False
        benefit_indicators = {'معرفة', 'آفاق', 'عقل', 'تفكير', 'لغة', 'ثقافة', 'وعي', 'مهارات', 'معلومات', 'حل المشكلات', 'نجاح', 'إبداع', 'استرخاء', 'متعة', 'فائدة', 'فوائد', 'تزيد', 'يزيد', 'توسع', 'يوسع', 'تطور', 'يطور', 'تحسن', 'يحسن', 'تنمي', 'ينمي', 'تقلل', 'يقلل', 'مصدر', 'غذاء للعقل', 'تنمية المهارات', 'توسيع المدارك', 'زيادة الوعي'}
        found_indicators = set()
        for indicator in benefit_indicators:
            if indicator in value:
                found_indicators.add(indicator)
        min_benefit_indicators = 4
        return len(found_indicators) >= min_benefit_indicators



class DataIdx1428InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1428')

    def check_following(self, value):
        """Checks if the response starts with the required phrase and potentially tries to detect common abbreviations (though this is limited for Arabic).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        required_start = 'ببساطة، الذكاء الاصطناعي هو...'
        if not value.strip().startswith(required_start):
            return False
        return True



class DataIdx1429InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1429')

    def check_following(self, value):
        """Checks if the response follows the instructions for question idx_1429.
        Instructions:
        - The invitation must include Date (التاريخ), Time (الوقت), and Location (الموقع).
        - The invitation must be less than 30 words.

        Args:
            value: A string representing the response (the birthday invitation).

        Returns:
            True if the response follows the instructions, False otherwise.
        """
        words = value.split()
        word_count = len(words)
        if word_count >= 30:
            return False
        includes_date = 'التاريخ' in value
        includes_time = 'الوقت' in value
        includes_location = 'الموقع' in value
        if not (includes_date and includes_time and includes_location):
            return False
        return True



class DataIdx1430InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1430')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1430.

        The main verifiable constraint is the length ("قصيرة"). Other constraints
        like being humorous, entertaining, or a personal experience are subjective
        and cannot be reliably checked programmatically without advanced NLP.
        This check focuses on the "short" constraint by checking the word count.
        Assumes "short" means between 20 and 200 words as a pragmatic range.

        Args:
            value: A string representing the response.

        Returns:
            True if the response meets the length constraint (between 20 and 200 words),
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        is_short = 20 <= word_count <= 200
        return is_short



class DataIdx1431InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1431')

    def check_following(self, value):
        """Checks if the response meets the constraints:
        1. Paragraph is at least 70 words long.
        2. Paragraph does not contain the Arabic letter "ر".

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        word_count = len(words)
        is_long_enough = word_count >= 70
        forbidden_letter = 'ر'
        contains_forbidden_letter = forbidden_letter in value
        return is_long_enough and (not contains_forbidden_letter)



class DataIdx1432InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1432')

    def check_following(self, value):
        """
        Checks if the response contains exactly one semicolon and no other punctuation.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        punctuation_count = 0
        found_punctuation = None
        all_punctuation = '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~'
        for char in value:
            if char in all_punctuation:
                punctuation_count += 1
                if punctuation_count == 1:
                    found_punctuation = char
                elif punctuation_count > 1:
                    return False
        if punctuation_count == 1 and found_punctuation == ';':
            return True
        else:
            return False



class DataIdx1433InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1433')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1433.

        Args:
            value: A string representing the response (an Arabic paragraph comparing two fruits).

        Returns:
            True if the response includes the word 'بينما' at least once and is at least 55 words long, False otherwise.
        """
        contains_benma = 'بينما' in value
        words = value.split()
        word_count = len(words)
        is_long_enough = word_count >= 55
        return contains_benma and is_long_enough



class DataIdx1434InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1434')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        has_arabic = False
        for char in value:
            ordinal = ord(char)
            if 1536 <= ordinal <= 1791 or 1872 <= ordinal <= 1919 or 2208 <= ordinal <= 2303 or (64336 <= ordinal <= 65023) or (65136 <= ordinal <= 65279):
                has_arabic = True
                break
        if not has_arabic:
            return False
        words = value.split()
        if len(words) > 75:
            return False
        return True



class DataIdx1435InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1435')

    def check_following(self, value):
        if not isinstance(value, str):
            return False
        text = value.lower()
        text_no_punct = text.translate(str.maketrans('', '', string.punctuation))
        words = text_no_punct.split()
        max_words = 200
        if len(words) > max_words:
            return False
        feature_keywords = ['ميزة', 'خاصية', 'يتميز ب', 'يدعم', 'أداء قوي', 'بطارية تدوم', 'شاشة واضحة', 'سريع', 'سهل الاستخدام', 'جودة عالية', 'تصميم جميل', 'كاميرا ممتازة', 'ذاكرة كبيرة', 'معالج سريع', 'صوت نقي', 'تحديثات منتظمة', 'مرونة', 'فعالية', 'موثوقية', 'مريح', 'إيجابيات']
        drawback_keywords = ['عيب', 'مشكلة', 'سلبي', 'ضعيف', 'بطيء', 'البطارية ضعيفة', 'يستهلك', 'صعب', 'يسخن', 'الثمن مرتفع', 'غالي', 'يعاني من', 'لا يدعم', 'قيود', 'تكلفة صيانة عالية', 'حجم كبير', 'وزن ثقيل', 'عدم توافق', 'توقف مفاجئ', 'لكن', 'ومع ذلك', 'بالرغم من ذلك', 'سلبيات']
        feature_count = 0
        for keyword in feature_keywords:
            feature_count += text.count(keyword)
        drawback_count = 0
        for keyword in drawback_keywords:
            drawback_count += text.count(keyword)
        has_enough_features = feature_count >= 2
        has_enough_drawbacks = drawback_count >= 1
        return has_enough_features and has_enough_drawbacks and (len(words) <= max_words)



class DataIdx1436InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1436')

    def check_following(self, value):
        """Checks if the response is a short play with two characters about weather
           and does not contain any question marks.

        Args:
            value: A string representing the response (the play).

        Returns:
            True if the response follows the instructions, False otherwise.
        """
        if '?' in value:
            return False
        character_names = set()
        lines = value.strip().split('\n')
        for line in lines:
            line = line.strip()
            if not line:
                continue
            colon_index = line.find(':')
            if colon_index != -1:
                potential_name = line[:colon_index].strip()
                if potential_name:
                    character_names.add(potential_name)
        if len(character_names) == 2:
            return True
        else:
            return False



class DataIdx1437InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1437')

    def check_following(self, value):
        """Checks if the response describes a live concert experience,
        is at least 180 words long, and if the last sentence contains
        the word "الموسيقى".

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count < 180:
            return False
        sentences = []
        current_sentence = []
        terminators = ['.', '!', '?']
        for char in value:
            current_sentence.append(char)
            if char in terminators:
                sentences.append(''.join(current_sentence).strip())
                current_sentence = []
        if current_sentence:
            sentences.append(''.join(current_sentence).strip())
        valid_sentences = [s for s in sentences if s]
        if not valid_sentences:
            return False
        last_sentence = valid_sentences[-1]
        if 'الموسيقى' not in last_sentence:
            return False
        return True



class DataIdx1438InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1438')

    def check_following(self, value):
        """Checks if the response follows the instruction.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        cleaned_value = value.strip()
        starts_with_dear = cleaned_value.startswith('عزيزي')
        ends_with_regards = cleaned_value.endswith('مع خالص التقدير')
        return starts_with_dear and ends_with_regards



class DataIdx1439InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1439')

    def check_following(self, value):
        """Checks if the response uses the Arabic word 'صوت' (sound) at least three times.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        sound_count = value.count('صوت')
        return sound_count >= 3



class DataIdx1440InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1440')

    def check_following(self, value):
        """Checks if the response describes the water cycle in 70-90 words and uses at least 3 sentences.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        words = cleaned_value.split()
        word_count = len([word for word in words if word.strip()])
        sentence_enders = ['.', '!', '?']
        sentences = []
        current_sentence = ''
        for char in cleaned_value:
            current_sentence += char
            if char in sentence_enders:
                if current_sentence.strip():
                    sentences.append(current_sentence.strip())
                current_sentence = ''
        if current_sentence.strip():
            sentences.append(current_sentence.strip())
        sentence_count = len(sentences)
        word_count_ok = 70 <= word_count <= 90
        sentence_count_ok = sentence_count >= 3
        return word_count_ok and sentence_count_ok



class DataIdx1441InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1441')

    def check_following(self, value):
        """Checks if the response is a short thank you message to a teacher that does not exceed 30 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        words = value.split()
        word_count = len(words)
        return word_count <= 30



class DataIdx1442InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1442')

    def check_following(self, value):
        """Checks if the response is a short sentence about exercise benefits that mentions 'صحة' at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        has_seha = 'صحة' in value
        is_short = len(value) <= 150
        return has_seha and is_short



class DataIdx1443InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1443')

    def check_following(self, value):
        """Checks if the response describes a historical event without dates and uses the word "تاريخ".

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        uses_tarikh = 'تاريخ' in value
        contains_four_digit_number = bool(re.search('\\d{4}', value))
        return uses_tarikh and (not contains_four_digit_number)



class DataIdx1444InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1444')

    def check_following(self, value):
        """Checks if the response explains 'Renewable Energy' within 105 to 125 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the word count is between 105 and 125 (inclusive), False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.strip().split()
        word_count = len(words)
        return 105 <= word_count <= 125



class DataIdx1445InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1445')

    def check_following(self, value):
        """Checks if the response describes the difference between 'الرأي' and 'الحقيقة',
        includes 'موضوعي' and 'شخصي', and is between 70 and 90 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        includes_subjective = 'شخصي' in value
        includes_objective = 'موضوعي' in value
        words = value.split()
        word_count = len(words)
        is_word_count_correct = 70 <= word_count <= 90
        return includes_subjective and includes_objective and is_word_count_correct



class DataIdx1446InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1446')

    def check_following(self, value):
        """Checks if the response contains exactly two paragraphs separated by exactly three empty lines.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.splitlines()
        empty_block_indices = []
        i = 0
        while i < len(lines):
            if not lines[i].strip():
                block_start = i
                j = i
                while j < len(lines) and (not lines[j].strip()):
                    j += 1
                block_end = j
                block_length = block_end - block_start
                if block_length >= 3:
                    empty_block_indices.append((block_start, block_length))
                i = block_end
            else:
                i += 1
        if len(empty_block_indices) != 1:
            return False
        block_start, block_length = empty_block_indices[0]
        if block_length != 3:
            return False
        content_before = any((lines[i].strip() for i in range(block_start)))
        if not content_before:
            return False
        content_after = any((lines[i].strip() for i in range(block_start + block_length, len(lines))))
        if not content_after:
            return False
        return True



class DataIdx1447InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1447')

    def check_following(self, value):
        """
        Checks if the response follows the constraints:
        1. Contains only one example (checked by looking for multiple example markers).
        2. Is in Modern Standard Arabic only (checked by looking for non-Arabic characters/scripts).
        3. Is in an informal style (difficult to check programmatically, will be lenient).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        allowed_chars = set((chr(i) for i in range(1536, 1791)))
        allowed_chars.update((chr(i) for i in range(1872, 1919)))
        allowed_chars.update((chr(i) for i in range(2208, 2303)))
        allowed_chars.update((chr(i) for i in range(64336, 65023)))
        allowed_chars.update((chr(i) for i in range(65136, 65279)))
        allowed_chars.update(' ')
        allowed_chars.update('\n')
        allowed_chars.update('\r')
        allowed_chars.update('\t')
        allowed_chars.update('.,?!:;\'"()[]{}<>،؛؟')
        allowed_chars.update('٠١٢٣٤٥٦٧٨٩')
        allowed_chars.update('0123456789')
        allowed_chars.update('+-*/%<=>#@&')
        for char in value:
            if char not in allowed_chars:
                return False
        lines = value.strip().split('\n')
        non_empty_lines = [line.strip() for line in lines if line.strip()]
        if len(non_empty_lines) > 1:
            for line in non_empty_lines[1:]:
                if line.startswith('- ') or line.startswith('* '):
                    return False
                if len(line) >= 3:
                    first_char = line[0]
                    second_char = line[1]
                    third_char = line[2]
                    if first_char in '0123456789٠١٢٣٤٥٦٧٨٩' and second_char in '. )' and (third_char == ' '):
                        return False
                if len(line) == 2:
                    first_char = line[0]
                    second_char = line[1]
                    if first_char in '0123456789٠١٢٣٤٥٦٧٨٩' and second_char in '. )':
                        return False
        return True



class DataIdx1448InstructionChecker(IFevalSynArInstructions):
    _common_arabic_adjectives = {'جميل', 'جميلة', 'جميلون', 'جميلات', 'كبير', 'كبيرة', 'كبيرون', 'كبيرات', 'صغير', 'صغيرة', 'صغيرون', 'صغيرات', 'سعيد', 'سعيدة', 'سعيدون', 'سعيدات', 'جديد', 'جديدة', 'جديدون', 'جديدات', 'قديم', 'قديمة', 'قديمون', 'قديمات', 'طويل', 'طويلة', 'طويلون', 'طويلات', 'قصير', 'قصيرة', 'قصيرون', 'قصيرات', 'جيد', 'جيدة', 'سيء', 'سيئة', 'سريع', 'سريعة', 'سريعون', 'سريعات', 'بطيء', 'بطيئة', 'بطيئون', 'بطيئات', 'نظيف', 'نظيفة', 'نظيفون', 'نظيفات', 'متعب', 'متعبة', 'سهل', 'سهلة', 'صعب', 'صعبة', 'كريم', 'كريمة', 'بخيل', 'بخيلة', 'ذكي', 'ذكية', 'غبي', 'غبيه', 'قوي', 'قوية', 'ضعيف', 'ضعيفة', 'نشيط', 'نشيطة', 'كسول', 'كسولة', 'لطيف', 'لطيفة', 'قاسي', 'قاسية', 'مهم', 'مهمة', 'واضح', 'واضحة', 'غامض', 'غامضة', 'مفتوح', 'مفتوحة', 'مغلق', 'مغلقة', 'الجميل', 'الجميلة', 'الكبير', 'الكبيرة', 'الصغير', 'الصغيرة', 'السعيد', 'السعيدة', 'الجديد', 'الجديدة', 'القديم', 'القديمة', 'الطويل', 'الطويلة', 'القصير', 'القصيرة', 'الجيد', 'الجيدة', 'السيء', 'السيئة', 'السريع', 'السريعة', 'البطيء', 'البطيئة', 'النظيف', 'النظيفة', 'المتعب', 'المتعبة', 'السهل', 'السهلة', 'الصعب', 'الصعبة', 'الكريم', 'الكريمة', 'البخيل', 'البخيلة', 'الذكي', 'الذكية', 'الغبي', 'الغبيه', 'القوي', 'القوية', 'الضعيف', 'الضعيفة', 'النشيط', 'النشيطة', 'الكسول', 'الكسولة', 'اللطيف', 'اللطيفة', 'القاسي', 'القاسية', 'المهم', 'المهمة', 'الواضح', 'الواضحة', 'الغامض', 'الغامضة', 'المفتوح', 'المفتوحة', 'المغلق', 'المغلقة', 'جميلون', 'كبار', 'صغار', 'سعداء', 'جدد', 'قدماء', 'طوال', 'قصار', 'سريعون', 'بطيئون', 'نظيفون', 'متعبون', 'سهلون', 'صعبون', 'كرماء', 'بخلاء', 'أذكياء', 'أغبياء', 'أقوياء', 'ضعفاء', 'نشيطون', 'كسالى', 'لطفاء', 'قساة', 'مهمون', 'واضحون', 'غامضون', 'مفتوحون', 'مغلقون', 'جميلات', 'كبيرات', 'صغيرات', 'سعيدات', 'جديدات', 'قديمات', 'طويلات', 'قصيرات', 'سريعات', 'بطيئات', 'نظيفات', 'متعبات', 'سهلات', 'صعبات', 'كريمات', 'بخيلات', 'ذكيّات', 'غبيّات', 'قويّات', 'ضعيفات', 'نشيطات', 'كسالات', 'لطيفات', 'قاسيات', 'مهمات', 'واضحات', 'غامضات', 'مفتوحات', 'مغلقات'}

    def __init__(self):
        super().__init__('idx_1448')

    def check_following(self, value):
        """Checks if the response describes a day without using adjectives.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response appears to follow the instruction (contains none
            of the hardcoded common adjectives), False otherwise.
            Note: This is a highly imperfect check due to the difficulty of
            identifying Arabic adjectives without a lexicon and NLP tools
            and the constraint of not using imports for proper tokenization.
        """
        if not isinstance(value, str):
            return False
        tokens = value.split()
        punctuation = '.,!?;:"\'()[]{}<>«»'
        for token in tokens:
            cleaned_token = token.strip(punctuation)
            if cleaned_token in self._common_arabic_adjectives:
                return False
        return True



class DataIdx1449InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1449')

    def check_following(self, value):
        """Checks if the response is a sentence with at least 12 words.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction regarding word count,
            False otherwise.
        """
        words = value.split()
        return len(words) >= 12



class DataIdx1450InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1450')

    def check_following(self, value):
        """Checks if the response is a plausible riddle about a book, including the answer 'الكتاب'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        keywords = ['صفحات', 'غلاف', 'فصول', 'قراءة', 'يقرأ', 'قارئ', 'معرفة', 'قصص', 'حكايات', 'روايات', 'علم', 'سطور', 'كلمات', 'حروف', 'ورق', 'مكتبة', 'أقرأ', 'كعب', 'حبر', 'طبع', 'طباعة']
        answer_string = 'الكتاب'
        answer_idx = value.rfind(answer_string)
        if answer_idx == -1:
            return False
        riddle_text = value[:answer_idx].strip()
        if not riddle_text:
            return False
        contains_keyword = any((keyword in riddle_text for keyword in keywords))
        return contains_keyword



class DataIdx1451InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1451')

    def check_following(self, value):
        """Checks if the response summarizes WWI causes under 130 words and emphasizes >= 5 events in uppercase.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count >= 130:
            return False
        uppercase_event_count = 0
        for word in words:
            if word.isupper() and any((c.isalpha() for c in word)):
                uppercase_event_count += 1
        if uppercase_event_count < 5:
            return False
        return True



class DataIdx1452InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1452')

    def check_following(self, value):
        """Checks if the response contains a sufficient number of Chinese characters from the main CJK Unified Ideographs range (U+4E00 to U+9FFF) to be considered "in Chinese" for this task."""
        if not isinstance(value, str) or not value.strip():
            return False
        cjk_count = 0
        cjk_start = 19968
        cjk_end = 40959
        for char in value:
            ord_char = ord(char)
            if cjk_start <= ord_char <= cjk_end:
                cjk_count += 1
        min_cjk_chars = 8
        return cjk_count >= min_cjk_chars



class DataIdx1453InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1453')

    def check_following(self, value):
        """Checks if the response is a valid JSON string.
        
        The instruction requires the answer to be placed inside JSON format tags.
        It also requires a brief description of advantages and disadvantages,
        but this checker only verifies the JSON format constraint, which is
        programmatically verifiable.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is a valid JSON string, False otherwise.
        """
        if not isinstance(value, str):
            return False
        try:
            json.loads(value)
            return True
        except json.JSONDecodeError:
            return False
        except Exception:
            return False



class DataIdx1454InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1454')

    def check_following(self, value):
        """Checks if the response contains the words 'حل' and 'مشكلة' at least once.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        contains_hal = 'حل' in value
        contains_mushkila = 'مشكلة' in value
        return contains_hal and contains_mushkila



class DataIdx1455InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1455')

    def check_following(self, value):
        """
        Checks if the response is a list of 5 items, where each item's first significant character is a potential Arabic verb prefix.
        Constraint Checklist:
        1. Is it a list? (Implied by formatting, checked by splitting lines)
        2. Are there exactly five items? Yes.
        3. Does each item start with a verb? (Heuristic check based on common imperfect verb prefixes)
        """
        lines = value.strip().split('\n')
        items = [line.strip() for line in lines if line.strip()]
        if len(items) != 5:
            return False
        verb_prefixes = {'أ', 'ن', 'ت', 'ي'}
        marker_chars = '0123456789.-* '
        for item in items:
            first_significant_char = None
            for char in item:
                if char not in marker_chars:
                    first_significant_char = char
                    break
            if first_significant_char is None or first_significant_char not in verb_prefixes:
                return False
        return True



class DataIdx1456InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1456')

    def check_following(self, value):
        """Checks if the response is a list of three words starting with 's' and length > 5.
        Assumes the response is a comma-separated list.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        potential_words = [word.strip() for word in value.split(',')]
        words = [word for word in potential_words if word]
        if len(words) != 3:
            return False
        for word in words:
            if not word.startswith('s'):
                return False
            if len(word) <= 5:
                return False
        return True



class DataIdx1457InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1457')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1457.

        Instructions: Write exactly one poetic verse about the beauty of the Arabian desert.
        The verse must have a unified rhyme and end with the letter Raa ('ر').
        The word count must be between 7 and 10 words (inclusive).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the constraints or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if not value.strip() or '\n' in value.strip():
            return False
        cleaned_value = value.strip()
        words = cleaned_value.split()
        word_count = len(words)
        if not 7 <= word_count <= 10:
            return False
        if not cleaned_value.rstrip().endswith('ر'):
            return False
        return True



class DataIdx1458InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1458')

    def check_following(self, value):
        """Checks if the response follows the constraints for explaining human heart functions.
        Constraints:
        1. Use at least 7 sentences.
        2. Italicize/underline at least 3 heart parts using *part* syntax.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        sentences = [sent for sent in value.split('.') if sent.strip()]
        sentences = [sent for sent in sentences if sent.strip()]
        q_sentences = [sent for sent in value.split('?') if sent.strip()]
        all_sentences = sentences + q_sentences
        sentence_enders = re.compile('[.!?]+')
        parts = sentence_enders.split(value)
        valid_sentences = [part for part in parts if part.strip()]
        sentence_count = len(valid_sentences)
        if sentence_count < 7:
            return False
        italicized_parts = re.findall('\\*(\\S+)\\*', value)
        if len(italicized_parts) < 3:
            return False
        return True



class DataIdx1459InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1459')

    def check_following(self, value):
        """Checks if the response is a single sentence expressing gratitude,
           includes 'شكرًا', and does not exceed 15 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if 'شكرًا' not in value:
            return False
        words = value.split()
        if len(words) > 15:
            return False
        return True



class DataIdx1460InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1460')

    def check_following(self, value):
        """Checks if the response is a paragraph about a favorite hobby
        with a word count between 50 and 60 words, inclusive.

        Args:
            value: A string representing the response (the paragraph).

        Returns:
            True if the response follows the instruction (word count is 50-60),
            False otherwise.
        """
        words = re.findall('\\b\\w+\\b', value)
        word_count = len(words)
        return 50 <= word_count <= 60



class DataIdx1461InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1461')

    def check_following(self, value):
        """Checks if the response is a short paragraph describing a desert sunset and includes 'رمال' and 'ألوان'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        has_ramal = 'رمال' in value
        has_alwan = 'ألوان' in value
        return has_ramal and has_alwan



class DataIdx1462InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1462')

    def check_following(self, value):
        """Checks if the response is a single interrogative sentence ending
           with exactly one question mark, as per instruction 1462.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value.endswith('?'):
            return False
        question_mark_count = cleaned_value.count('?')
        if question_mark_count != 1:
            return False
        return True



class DataIdx1463InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1463')

    def check_following(self, value):
        """Checks if the response contains the word 'شكراً' at least four times.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction, False otherwise.
        """
        if not isinstance(value, str):
            return False
        thank_you_count = value.count('شكراً')
        return thank_you_count >= 4



class DataIdx1464InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1464')

    def check_following(self, value):
        """Checks if the response is a list of 5 different single-word items, separated by commas.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        items_raw = cleaned_value.split(',')
        items = [item.strip() for item in items_raw if item.strip()]
        if len(items) != 5:
            return False
        for item in items:
            if len(item.split()) > 1:
                return False
        if len(set(items)) != 5:
            return False
        return True



class DataIdx1465InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1465')

    def check_following(self, value):
        """Checks if the response starts with the exact required sentence.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        required_start = 'الرياضة المنتظمة هي مفتاح الصحة الجيدة.'
        return value.strip().startswith(required_start)



class DataIdx1466InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1466')

    def check_following(self, value):
        """Checks if the response contains exactly one exclamation mark.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains exactly one '!', False otherwise.
        """
        return value.count('!') == 1



class DataIdx1467InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1467')

    def check_following(self, value):
        """Checks if the response follows the instruction.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.split('\n')
        return len(lines) == 6



class DataIdx1468InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1468')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1468.

        Instructions:
        - The paragraph must contain the word 'القرآن' (Al-Quran) at least three times.
        - The paragraph must be at least 60 words long.
        - Use a descriptive style (this constraint is not programmatically checked).

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the measurable instructions (word count and Quran count),
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        word_count_met = word_count >= 60
        quran_count = value.count('القرآن')
        quran_count_met = quran_count >= 3
        return word_count_met and quran_count_met



class DataIdx1469InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1469')

    def check_following(self, value):
        """Checks if the response is a short news report about a recent sports event,
        consisting of exactly 5 sentences and containing no exclamation marks.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if '!' in value:
            return False
        sentences = [s.strip() for s in value.split('.') if s.strip()]
        return len(sentences) == 5



class DataIdx1470InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1470')

    def check_following(self, value):
        """Checks if the response is a short congratulatory message for graduation
        that starts with 'تهانينا بمناسبة تخرجك!', ends with 'مع أطيب التمنيات',
        and includes at least one sentence expressing pride in the achievement.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        start_phrase = 'تهانينا بمناسبة تخرجك!'
        if not cleaned_value.startswith(start_phrase):
            return False
        end_phrase = 'مع أطيب التمنيات'
        if not cleaned_value.endswith(end_phrase):
            return False
        pride_keywords = ['فخور', 'إنجاز', 'رائع', 'ممتاز', 'نجاح', 'بنجاح كبير', 'تستحق']
        has_pride_content = any((keyword in cleaned_value for keyword in pride_keywords))
        if not has_pride_content:
            return False
        min_len_for_body = len(start_phrase) + len(end_phrase) + 1
        if len(cleaned_value) < min_len_for_body:
            if cleaned_value == start_phrase + end_phrase:
                return False
        return True



class DataIdx1471InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1471')
        self.country_mapping = {'algeria': 'Algeria', 'الجزائر': 'Algeria', 'angola': 'Angola', 'أنغولا': 'Angola', 'benin': 'Benin', 'بنين': 'Benin', 'botswana': 'Botswana', 'بوتسوانا': 'Botswana', 'burkina faso': 'Burkina Faso', 'بوركينا فاسو': 'Burkina Faso', 'burundi': 'Burundi', 'بوروندي': 'Burundi', 'cape verde': 'Cape Verde', 'الرأس الأخضر': 'Cape Verde', 'cameroon': 'Cameroon', 'الكاميرون': 'Cameroon', 'central african republic': 'Central African Republic', 'جمهورية أفريقيا الوسطى': 'Central African Republic', 'chad': 'Chad', 'تشاد': 'Chad', 'comoros': 'Comoros', 'جزر القمر': 'Comoros', 'republic of the congo': 'Republic of the Congo', 'جمهورية الكونغو': 'Republic of the Congo', 'congo brazzaville': 'Republic of the Congo', 'democratic republic of the congo': 'Democratic Republic of the Congo', 'جمهورية الكونغو الديمقراطية': 'Democratic Republic of the Congo', 'drc': 'Democratic Republic of the Congo', 'congo kinshasa': 'Democratic Republic of the Congo', "cote d'ivoire": 'Ivory Coast', 'ساحل العاج': 'Ivory Coast', 'ivory coast': 'Ivory Coast', 'djibouti': 'Djibouti', 'جيبوتي': 'جيبوتي', 'egypt': 'Egypt', 'مصر': 'Egypt', 'equatorial guinea': 'Equatorial Guinea', 'غينيا الاستوائية': 'Equatorial Guinea', 'eritrea': 'Eritrea', 'إريتريا': 'إريتريا', 'eswatini': 'Eswatini', 'إسواتيني': 'Eswatini', 'swaziland': 'Eswatini', 'ethiopia': 'Ethiopia', 'إثيوبيا': 'إثيوبيا', 'gabon': 'Gabon', 'الغابون': 'الغابون', 'gambia': 'Gambia', 'غامبيا': 'غامبيا', 'ghana': 'Ghana', 'غانا': 'غانا', 'guinea': 'Guinea', 'غينيا': 'غينيا', 'guinea-bissau': 'Guinea-Bissau', 'غينيا بيساو': 'غينيا بيساو', 'kenya': 'Kenya', 'كينيا': 'كينيا', 'lesotho': 'Lesotho', 'ليسوتو': 'ليسوتو', 'liberia': 'Liberia', 'ليبريا': 'ليبريا', 'libya': 'Libya', 'ليبيا': 'ليبيا', 'madagascar': 'Madagascar', 'مدغشقر': 'مدغشقر', 'malawi': 'Malawi', 'مالاوي': 'مالاوي', 'mali': 'Mali', 'مالي': 'مالي', 'mauritania': 'Mauritania', 'موريتانيا': 'موريتانيا', 'mauritius': 'Mauritius', 'موريشيوس': 'موريشيوس', 'morocco': 'Morocco', 'المغرب': 'المغرب', 'mozambique': 'Mozambique', 'موزمبيق': 'موزمبيق', 'namibia': 'Namibia', 'ناميبيا': 'ناميبيا', 'niger': 'Niger', 'النيجر': 'النيجر', 'nigeria': 'Nigeria', 'نيجيريا': 'نيجيريا', 'rwanda': 'Rwanda', 'رواندا': 'رواندا', 'sao tome and principe': 'Sao Tome and Principe', 'ساو تومي وبرينسيب': 'ساو تومي وبرينسيب', 'senegal': 'Senegal', 'السنغال': 'السنغال', 'seychelles': 'Seychelles', 'سيشل': 'سيشل', 'sierra leone': 'Sierra Leone', 'سيراليون': 'سيراليون', 'somalia': 'Somalia', 'الصومال': 'الصومال', 'south africa': 'South Africa', 'جنوب أفريقيا': 'South Africa', 'south sudan': 'South Sudan', 'السودان الجنوبي': 'السودان الجنوبي', 'sudan': 'Sudan', 'السودان': 'السودان', 'tanzania': 'Tanzania', 'تنزانيا': 'تنزانيا', 'togo': 'Togo', 'توغو': 'توغو', 'tunisia': 'Tunisia', 'تونس': 'تونس', 'uganda': 'Uganda', 'أوغندا': 'أوغندا', 'zambia': 'Zambia', 'زامبيا': 'زامبيا', 'zimbabwe': 'Zimbabwe', 'زيمبابوي': 'زيمبابوي'}
        pattern_keys = sorted([re.escape(key) for key in self.country_mapping.keys()], key=len, reverse=True)
        self.country_pattern = '\\b(' + '|'.join(pattern_keys) + ')\\b'
        self.required_prefix = 'هذه هي إجابتي:'

    def check_following(self, value):
        """Checks if the response starts with the required phrase and mentions exactly five unique African countries (English or Arabic names)."""
        value_stripped = value.strip()
        prefix_lower = self.required_prefix.lower()
        value_lower_stripped = value_stripped.lower()
        if not value_lower_stripped.startswith(prefix_lower):
            return False
        content_after_prefix_original_case = value_stripped[len(self.required_prefix):].strip()
        content_to_search = content_after_prefix_original_case.lower()
        found_name_forms = re.findall(self.country_pattern, content_to_search)
        unique_canonical_countries = set()
        for name_form in found_name_forms:
            canonical_name = self.country_mapping.get(name_form)
            if canonical_name:
                unique_canonical_countries.add(canonical_name)
        return len(unique_canonical_countries) == 5



class DataIdx1472InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1472')

    def check_following(self, value):
        """Checks if the response contains the word 'انتقام' at least once.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        return 'انتقام' in value



class DataIdx1473InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1473')

    def check_following(self, value):
        """Checks if the response describes Riyadh in five short, different sentences,
        each starting with a different word, and without using the word 'الرياض'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentences = [s.strip() for s in re.split('[.!؟\\n]+', value) if s.strip()]
        if len(sentences) != 5:
            return False
        if 'الرياض' in value:
            return False
        if len(set(sentences)) != len(sentences):
            return False
        first_words = []
        for sentence in sentences:
            words = sentence.split()
            if not words:
                return False
            first_word = words[0]
            first_words.append(first_word)
        if len(set(first_words)) != len(first_words):
            return False
        return True



class DataIdx1474InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1474')

    def check_following(self, value):
        """
        Checks if the response lists exactly three books and mentions the author for each.
        Assumes books are listed on separate lines or clearly delineated items.
        Checks for indicators of book-author link within each item.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = [line.strip() for line in value.splitlines() if line.strip()]
        if len(lines) != 3:
            return False
        indicators = ['(', ')', '-', ':', ',', 'بواسطة', 'تأليف', 'لـ']
        for line in lines:
            has_indicator = False
            for indicator in indicators:
                if indicator in line:
                    has_indicator = True
                    break
            if not has_indicator:
                return False
        return True



class DataIdx1475InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1475')

    def check_following(self, value):
        """Checks if the response is a single sentence and does not exceed 20 words.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentence_terminators = ['.', '!', '?']
        terminator_count = sum((value.count(term) for term in sentence_terminators))
        is_single_sentence = False
        if terminator_count == 0:
            is_single_sentence = True
        elif terminator_count == 1:
            terminator = None
            for term in sentence_terminators:
                if term in value:
                    terminator = term
                    break
            is_single_sentence = value.rstrip().endswith(terminator)
        else:
            is_single_sentence = False
        words = value.split()
        word_count = len([word for word in words if word])
        max_words = 20
        is_within_word_limit = word_count <= max_words
        return is_single_sentence and is_within_word_limit



class DataIdx1476InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1476')

    def check_following(self, value):
        """Checks if the response string contains a markdown-like table
           with at least 3 rows and at least 2 columns, comparing apples and oranges.
           Assumes a markdown table format using '|' delimiters.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        table_lines = [line.strip() for line in lines if line.strip().startswith('|') and line.strip().endswith('|')]
        if len(table_lines) < 3:
            return False
        first_table_line = table_lines[0]
        pipe_count = first_table_line.count('|')
        if pipe_count < 3:
            return False
        return True



class DataIdx1477InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1477')

    def check_following(self, value):
        """Checks if the response is a single sentence containing a word starting with a capital letter.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        trimmed_value = value.strip()
        if not trimmed_value:
            return False
        sentence_terminators = {'.', '!', '?'}
        if not trimmed_value[-1] in sentence_terminators:
            return False
        if any((char in sentence_terminators for char in trimmed_value[:-1])):
            return False
        sentence_without_punctuation = trimmed_value[:-1].strip()
        if not sentence_without_punctuation:
            return False
        words = sentence_without_punctuation.split()
        found_capitalized_word = False
        for word in words:
            if word and word[0].isupper():
                found_capitalized_word = True
                break
        return found_capitalized_word



class DataIdx1478InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1478')

    def check_following(self, value):
        """Checks if the response contains the word 'رائع' exactly twice.
        Args:
            value: A string representing the response.

        Returns:
            True if the response contains 'رائع' exactly twice, False otherwise.
        """
        count_raway = value.count('رائع')
        return count_raway == 2



class DataIdx1479InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1479')

    def check_following(self, value):
        """Checks if the response follows the instruction not to use any commas.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain any commas, False otherwise.
        """
        if ',' in value:
            return False
        return True



class DataIdx1480InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1480')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1480.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows all instructions, False otherwise.
        """
        title_matches = re.findall('<<(.*?)>>', value, re.DOTALL)
        found_valid_title = False
        if title_matches:
            for title_content in title_matches:
                if title_content.strip():
                    found_valid_title = True
                    break
        if not found_valid_title:
            return False
        words = value.split()
        if len(words) < 200:
            return False
        normalized_value = re.sub('\\s+', ' ', value).strip()
        learning_phrases = ['تعلمت منك', 'لقد علمتني', 'استفدت منك', 'منك تعلمت', 'الذي تعلمته منك', 'درسا مهما منك', 'شيئا محددا منك', 'تحديدًا تعلمت منك', 'بالتحديد تعلمت منك', 'الدرس الذي تعلمته منك', 'كيف تعلمت منك', 'تعلمت من دروسك', 'ما تعلمته منك', 'علمتني كيف', 'علمتني أن']
        found_learning_mention = False
        for phrase in learning_phrases:
            if phrase in normalized_value:
                found_learning_mention = True
                break
        if not found_learning_mention:
            return False
        return True



class DataIdx1481InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1481')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1481.
        Instructions: Write a short announcement about a photography training course.
                      Must mention course name, start date, phone number for registration.
                      Must not exceed 50 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows all instructions, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count > 50:
            return False
        mentions_course_name = ('دورة' in value or 'تدريب') in value and 'التصوير' in value
        mentions_start_date = 'يبدأ' in value or 'موعد' in value
        mentions_phone_keyword = 'هاتف' in value or 'للتسجيل' in value
        contains_digit = any((char.isdigit() for char in value))
        mentions_phone_number = mentions_phone_keyword and contains_digit
        return mentions_course_name and mentions_start_date and mentions_phone_number



class DataIdx1482InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1482')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1482.
        The question asks for a single paragraph of eight sentences about
        environmental preservation, mentioning 'بيئة' at least six times,
        using repetition, and without quotation marks.

        Constraints checked by this function:
        1.  Response is a string.
        2.  Contains no quotation marks (single or double).
        3.  Is a single paragraph (does not contain double newlines '

').
        4.  Contains the word 'بيئة' (whole word) at least 6 times.
        5.  Contains exactly eight sentences, as determined by counting sentence-ending punctuation (., !, ?).

        Args:
            value: A string representing the response text.

        Returns:
            True if the response follows all checked constraints, False otherwise.
        """
        if not isinstance(value, str):
            return False
        text = value.strip()
        if not text:
            return False
        if re.search('["\\\']', text):
            return False
        if text.find('\n\n') != -1:
            return False
        keyword_count = len(re.findall('\\bبيئة\\b', text))
        if keyword_count < 6:
            return False
        sentence_terminator_count = text.count('.') + text.count('!') + text.count('?')
        if sentence_terminator_count != 8:
            return False
        return True



class DataIdx1483InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1483')

    def check_following(self, value):
        """
        Checks if the response contains exactly three paragraphs and if the second paragraph contains the word "اكتشاف".

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        paragraphs = value.split('\n\n')
        non_empty_paragraphs = [p.strip() for p in paragraphs if p.strip()]
        if len(non_empty_paragraphs) != 3:
            return False
        second_paragraph = non_empty_paragraphs[1]
        if 'اكتشاف' not in second_paragraph:
            return False
        return True



class DataIdx1484InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1484')

    def check_following(self, value):
        """Checks if the response is a report divided into three sections, with 'صحة' in each section.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        sections = [s.strip() for s in value.split('\n\n') if s.strip()]
        if len(sections) != 3:
            return False
        for section in sections:
            if 'صحة' not in section:
                return False
        return True



class DataIdx1485InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1485')

    def check_following(self, value):
        """Checks if the response follows the instructions for question IDX 1485.
        The response must be an Arabic poem about the homeland with:
        1. A title on the first line enclosed in double horizontal lines (═Title═).
        2. Exactly 7 verses (lines) after the title line.
        3. Exactly 2 question marks (?) in the entire response.

        Args:
            value: A string representing the response (the poem).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.strip().split('\n')
        if len(lines) != 8:
            return False
        title_line = lines[0]
        if not (title_line.startswith('═') and title_line.endswith('═')):
            return False
        if title_line.count('═') != 2:
            return False
        question_mark_count = value.count('?')
        if question_mark_count != 2:
            return False
        return True



class DataIdx1486InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1486')

    def check_following(self, value):
        """Checks if the response compares paper and electronic books in two sentences,
        using the word 'بين' exactly once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        temp_value = value.replace('؟', '.').replace('!', '.')
        sentences = [s.strip() for s in temp_value.split('.') if s.strip()]
        two_sentences = len(sentences) == 2
        count_bayn = value.count('بين')
        one_bayn = count_bayn == 1
        return two_sentences and one_bayn



class DataIdx1487InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1487')

    def check_following(self, value):
        """Checks if the response is a message enclosed in single quotes and contains the word 'مساء'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not (value.startswith("'") and value.endswith("'")):
            return False
        message_content = value[1:-1]
        if 'مساء' not in message_content:
            return False
        return True



class DataIdx1488InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1488')

    def check_following(self, value):
        """Checks if the total count of words inside bold sections is exactly 3.

        This checker identifies text segments marked with markdown bold (**word**, __word__)
        or HTML bold (<b>text</b>, <strong>text</strong>). It then counts the total
        number of words (split by whitespace) found across all identified bold segments.
        The response is considered following the instruction if this total word count is exactly 3.

        Args:
            value: A string representing the response.

        Returns:
            True if the total word count inside bold is 3, False otherwise.
        """
        pattern = '(?:\\*\\*|__)(.+?)(?:\\*\\*|__)|(?:<b>|<strong>)(.*?)(?:<\\/b>|<\\/strong>)'
        try:
            bold_matches = re.findall(pattern, value)
        except NameError:
            return False
        total_word_count = 0
        for match_tuple in bold_matches:
            md_content = match_tuple[0]
            html_content = match_tuple[1]
            content = md_content if md_content else html_content
            words_in_segment = content.split()
            total_word_count += len(words_in_segment)
        return total_word_count == 3



class DataIdx1489InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1489')

    def check_following(self, value):
        """Checks if the response follows the constraints for IDX 1489.
        Constraints:
        1. At least 150 words.
        2. Instructions are numbered (check for multiple lines starting with numbers).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instructions, False otherwise.
        """
        words = value.split()
        word_count = len(words)
        if word_count < 150:
            return False
        lines = value.strip().split('\n')
        numbered_line_count = 0
        min_numbered_lines = 3
        for line in lines:
            stripped_line = line.strip()
            if not stripped_line:
                continue
            i = 0
            while i < len(stripped_line) and stripped_line[i].isdigit():
                i += 1
            if i > 0:
                if i < len(stripped_line):
                    char_after_digits = stripped_line[i]
                    if char_after_digits in ['.', ')', ' ']:
                        numbered_line_count += 1
                elif i == len(stripped_line):
                    numbered_line_count += 1
        if numbered_line_count < min_numbered_lines:
            return False
        return True



class DataIdx1490InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1490')
        self.ingredient_keywords_single = {'خس', 'طماطم', 'خيار', 'بصل', 'فلفل', 'جزر', 'ليمون', 'خل', 'ملح', 'نعناع', 'بقدونس', 'سماق', 'صلصة', 'بهارات', 'زيت'}
        self.ingredient_keywords_multi = {'زيت زيتون', 'فلفل أسود', 'خبز محمص'}

    def check_following(self, value):
        """Checks if the response is a simple green salad recipe description
           with at least five ingredients and no 'و' character.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if 'و' in value:
            return False
        found_ingredients = set()
        for keyword in self.ingredient_keywords_single:
            pattern_base = '\\b' + re.escape(keyword) + '\\b'
            pattern_with_al = '\\bال' + re.escape(keyword) + '\\b'
            if re.search(pattern_base, value) or re.search(pattern_with_al, value):
                found_ingredients.add(keyword)
        for phrase in self.ingredient_keywords_multi:
            if re.search(re.escape(phrase), value):
                found_ingredients.add(phrase)
        if len(found_ingredients) < 5:
            return False
        return True



class DataIdx1491InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1491')

    def check_following(self, value):
        """Checks if the response contains three fruit names starting with 'م', separated by '*'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        parts = value.split('*')
        if len(parts) != 3:
            return False
        for part in parts:
            cleaned_part = part.strip()
            if not cleaned_part:
                return False
            if not cleaned_part.startswith('م'):
                return False
        return True



class DataIdx1492InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1492')

    def check_following(self, value):
        """Checks if the response follows the constraints for question 1492.
        Constraints:
        1. Less than 18 sentences.
        2. Includes keywords 'ضوء الشمس' and 'الكلوروفيل'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if not value.strip():
            return False
        sentences = [s.strip() for s in re.split('[.!?]', value) if s.strip()]
        sentence_count = len(sentences)
        if sentence_count >= 18:
            return False
        keyword_sunlight = 'ضوء الشمس'
        keyword_chlorophyll = 'الكلوروفيل'
        if keyword_sunlight not in value:
            return False
        if keyword_chlorophyll not in value:
            return False
        return True



class DataIdx1493InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1493')

    def check_following(self, value):
        """Checks if the response follows the constraints:
        1. Contains only allowed characters (letters, digits, space, double quote).
        2. Contains at least two sections of text enclosed in double quotes (implying dialogue between at least two turns/characters).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        allowed_chars_pattern = re.compile('^[\\s\\w"٠-٩]+$', re.UNICODE)
        explicit_allowed_chars_pattern = re.compile('^[\\u0621-\\u064Aa-zA-Z0-9\\s"]*$', re.UNICODE)
        if not explicit_allowed_chars_pattern.fullmatch(value):
            return False
        quoted_sections = re.findall('"[^"]+"', value)
        if len(quoted_sections) < 2:
            return False
        return True



class DataIdx1494InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1494')

    def check_following(self, value):
        """
        Checks if the response is a non-empty string, assuming a slogan should be text.
        Without explicit constraints in the question, this checks the most basic validity.

        Args:
            value: A string representing the response (the proposed slogan).

        Returns:
            True if the value is a non-empty string, False otherwise.
        """
        if isinstance(value, str) and value.strip():
            return True
        return False



class DataIdx1495InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1495')

    def check_following(self, value):
        """Checks if the response is a thank you letter mentioning the gift and the occasion.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        text = value.lower()
        thank_you_kws = ['شكرا', 'اشكرك', 'ممتن', 'ممنون', 'شكري']
        gift_kws = ['هدية', 'الهدية', 'هديتك', 'هدايا']
        occasion_kws = ['بمناسبة', 'مناسبة', 'المناسبة', 'عيد ميلاد', 'تخرج', 'زواج', 'نجاح', 'عيد', 'رمضان', 'الخطوبة']
        contains_thank_you = any((kw in text for kw in thank_you_kws))
        contains_gift = any((kw in text for kw in gift_kws))
        contains_occasion = any((kw in text for kw in occasion_kws))
        return contains_thank_you and contains_gift and contains_occasion



class DataIdx1496InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1496')

    def check_following(self, value):
        """Checks if the response is a single sentence and contains 15 to 20 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        sentence_enders = ['.', '!', '?']
        end_chars_count = sum((cleaned_value.count(end) for end in sentence_enders))
        is_single_sentence = end_chars_count == 1 and cleaned_value[-1] in sentence_enders if cleaned_value else False
        words = cleaned_value.split()
        word_count = len(words)
        is_word_count_correct = 15 <= word_count <= 20
        return is_single_sentence and is_word_count_correct



class DataIdx1497InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1497')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if 'تواصل' not in value:
            return False
        words = value.split()
        if len(words) <= 10:
            return False
        sentence_enders = ['.', '!', '?']
        end_punctuation_count = 0
        for char in value:
            if char in sentence_enders:
                end_punctuation_count += 1
        if end_punctuation_count != 1:
            return False
        cleaned_value = value.rstrip()
        if not cleaned_value or cleaned_value[-1] not in sentence_enders:
            return False
        return True



class DataIdx1498InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1498')

    def check_following(self, value: str) -> bool:
        """Checks if the response meets the structural requirements:
        - Is a string and not empty/whitespace.
        - Contains at least 6 sentences (approximated by splitting on ., !, ?).
        - Contains at least 2 question marks (as a proxy for rhetorical questions).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the quantifiable instructions or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        cleaned_value = value.strip()
        sentences = re.split('[.!?]+(?:\\s+|$)', cleaned_value)
        valid_sentences = [s.strip() for s in sentences if s.strip()]
        sentence_count = len(valid_sentences)
        question_mark_count = cleaned_value.count('?')
        has_enough_sentences = sentence_count >= 6
        has_enough_questions = question_mark_count >= 2
        return has_enough_sentences and has_enough_questions



class DataIdx1499InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1499')

    def check_following(self, value):
        """Checks if the response is likely a riddle whose answer is 'الشمس'.
        This uses a heuristic based on keywords and the absence of the answer.

        Args:
            value: A string representing the response (the riddle).

        Returns:
            True if the heuristic passes, False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        text = value.strip()
        sun_clues = ['نور', 'ضوء', 'حرارة', 'دفء', 'تشرق', 'تغرب', 'يشرق', 'يغرب', 'نهار', 'نجم', 'كرة', 'ذهبية', 'أصفر', 'سماء', 'فضاء', 'كوكب', 'تضيء', 'تسخن', 'عين السماء']
        explicit_answer = 'الشمس'
        if explicit_answer in text:
            return False
        has_sun_clue = any((clue in text for clue in sun_clues))
        return has_sun_clue



class DataIdx1500InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1500')

    def check_following(self, value):
        """Checks if the response is a single verse about friendship including 'صديق', 'وفاء', and 'إخلاص'.
        Note: Only the inclusion of the specific words is programmatically checked.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains the required words, False otherwise.
        """
        has_sadeeq = 'صديق' in value
        has_wafaa = 'وفاء' in value
        has_ikhlas = 'إخلاص' in value
        return has_sadeeq and has_wafaa and has_ikhlas



class DataIdx1501InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1501')

    def check_following(self, value):
        """Checks if the response includes at least one illustrative example.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response appears to contain at least one illustrative example,
            based on the presence of explicit markers or common example phrases.
            False otherwise.
        """
        if not isinstance(value, str):
            return False
        example_indicators = ['مثال', 'على سبيل المثال', 'فمثلاً', 'من أمثلة ذلك', 'على سبيل الذكر لا الحصر', 'مثل']
        for indicator in example_indicators:
            if indicator in value:
                return True
        common_example_keywords = ['نباتات', 'يزرع', 'زراعة', 'شرب', 'يشرب', 'هضم', 'يهضم', 'دورة دموية', 'تنفس', 'يتنفس', 'درجة حرارة', 'مذيب']
        explicit_indicators_only = ['مثال', 'على سبيل المثال', 'فمثلاً', 'من أمثلة ذلك', 'على سبيل الذكر لا الحصر']
        for indicator in explicit_indicators_only:
            if indicator in value:
                return True
        return False



class DataIdx1502InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1502')

    def check_following(self, value):
        """Checks if the response (slogan) consists of exactly 7 words.

        Args:
            value: A string representing the response (the slogan).

        Returns:
            True if the slogan contains exactly 7 words, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        return len(words) == 7



class DataIdx1503InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1503')

    def check_following(self, value):
        """Checks if the response is formatted as bullet points (basic check) and contains a reasonable number of points.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (is formatted as basic bullet points) or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        bullet_lines = [line.strip() for line in lines if line.strip()]
        if len(bullet_lines) < 4:
            return False
        for line in bullet_lines:
            is_bullet = False
            if line.startswith('-') or line.startswith('*') or line.startswith('•'):
                if len(line) > 1 and line[1:].strip():
                    is_bullet = True
                elif len(line) == 1:
                    pass
                elif len(line) > 1 and (not line[1:].strip()):
                    pass
                else:
                    pass
            if not is_bullet and line and line[0].isdigit():
                first_nondigit_idx = -1
                for i, char in enumerate(line):
                    if not char.isdigit():
                        first_nondigit_idx = i
                        break
                if first_nondigit_idx != -1:
                    marker_char = line[first_nondigit_idx]
                    if marker_char in '.)':
                        if len(line) > first_nondigit_idx + 1 and line[first_nondigit_idx + 1:].strip():
                            is_bullet = True
                        elif len(line) == first_nondigit_idx + 1:
                            is_bullet = True
                    elif marker_char == ' ':
                        if len(line) > first_nondigit_idx + 1 and line[first_nondigit_idx + 1:].strip():
                            is_bullet = True
                        elif len(line) == first_nondigit_idx + 1:
                            is_bullet = True
            if not is_bullet:
                return False
        return True



class DataIdx1504InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1504')

    def check_following(self, value):
        """Checks if the response is a single sentence with no punctuation.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        punctuation = set('.,;:!?-()[]{}"\'“”‘’…،؛؟')
        for char in value:
            if char in punctuation:
                return False
        return len(value.strip()) > 0



class DataIdx1505InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1505')

    def check_following(self, value):
        """Checks if the response uses the word 'طفلك' at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains 'طفلك', False otherwise.
        """
        required_word = 'طفلك'
        return required_word in value



class DataIdx1506InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1506')

    def check_following(self, value):
        """Checks if the response mentions 2 advantages and 2 disadvantages of renewable energy,
           is short, and is in JSON format.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        try:
            data = json.loads(value)
        except json.JSONDecodeError:
            return False
        if not isinstance(data, dict):
            return False
        list_len_2_count = 0
        for item_value in data.values():
            if isinstance(item_value, list) and len(item_value) == 2:
                list_len_2_count += 1
        if list_len_2_count != 2:
            return False
        MAX_LENGTH = 400
        if len(value) > MAX_LENGTH:
            return False
        return True



class DataIdx1507InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1507')

    def check_following(self, value):
        """Checks if the response contains the word 'حصري' exactly once as a whole word.
        Other subjective constraints from the question (e.g., targeting youth, attractive style)
        are not reliably checkable programmatically and are therefore not enforced here.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains the word 'حصري' exactly once as a whole word,
            False otherwise.
        """
        pattern = '\\bحصري\\b'
        matches = re.findall(pattern, value)
        return len(matches) == 1



class DataIdx1508InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1508')

    def check_following(self, value):
        """Checks if the response has a serious tone by looking for markers of non-seriousness.

        Args:
            value: A string representing the response.

        Returns:
            True if the response appears to maintain a serious tone, False otherwise.
        """
        if not isinstance(value, str):
            return False
        emoji_ranges = [(128512, 128591), (127744, 128511), (128640, 128767), (129280, 129535), (9728, 9983), (9984, 10175)]
        common_specific_emojis = set(['😂', '👍', '😭', '😊', '💔', '❤️', '🙏', '😅', '😉', '🤔', '😎', '✨', '👋', '👇', '👆', '👉', '👈', '👌', '👏', '🙌'])
        for char in value:
            char_code = ord(char)
            if char in common_specific_emojis:
                return False
            for start, end in emoji_ranges:
                if start <= char_code <= end:
                    if char_code in [9786, 9785]:
                        continue
                    return False
        consecutive_count = 0
        last_char = None
        for char in value:
            if char == last_char:
                consecutive_count += 1
            else:
                consecutive_count = 1
                last_char = char
            if consecutive_count > 3:
                return False
        punctuation_marks = '!؟.'
        consecutive_punc_count = 0
        last_punc = None
        for char in value:
            if char in punctuation_marks:
                if char == last_punc:
                    consecutive_punc_count += 1
                else:
                    consecutive_punc_count = 1
                    last_punc = char
                if consecutive_punc_count > 3:
                    return False
            else:
                consecutive_punc_count = 0
                last_punc = None
        if 'هههه' in value:
            return False
        return True



class DataIdx1509InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1509')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1509.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        contains_asif = 'آسف' in value
        contains_izdiham = 'ازدحام' in value
        words = value.split()
        word_count = len(words)
        within_word_limit = word_count <= 25
        return contains_asif and contains_izdiham and within_word_limit



class DataIdx1510InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1510')

    def check_following(self, value):
        """Checks if the response describes a favorite city in less than 50 words
        and mentions the word 'مدينة' at least three times.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        word_count_ok = word_count < 50
        city_mentions = value.count('مدينة')
        city_mentions_ok = city_mentions >= 3
        return word_count_ok and city_mentions_ok



class DataIdx1511InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1511')

    def check_following(self, value):
        """Checks if the response follows the constraints for IDX 1511.
        Constraints:
        1. Starts with 'ما أجمل'.
        2. Ends with '!'.
        3. Less than 15 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows all constraints, False otherwise.
        """
        if not isinstance(value, str):
            return False
        trimmed_value = value.strip()
        if not trimmed_value.startswith('ما أجمل'):
            return False
        if not trimmed_value.endswith('!'):
            return False
        words = trimmed_value.split()
        if len(words) >= 15:
            return False
        return True



class DataIdx1512InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1512')

    def check_following(self, value):
        """Checks if the response is a short Arabic message encouraging someone to learn Arabic,
        does not exceed 25 words, and ends with an exclamation mark.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        word_count_ok = word_count <= 25
        ends_with_exclamation = value.strip().endswith('!')
        return word_count_ok and ends_with_exclamation



class DataIdx1513InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1513')

    def check_following(self, value):
        """
        Checks if the response contains exactly three tips, each starting with a common Arabic imperative verb.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        imperative_verbs = {'ادرس', 'راجع', 'نظم', 'احضر', 'اسأل', 'تمرن', 'ركز', 'اقرأ', 'اكتب', 'استرح', 'كن', 'افعل', 'ابدأ', 'انتبه', 'حدد', 'خصص', 'استغل', 'خطط', 'تابع', 'ابتعد', 'حرص', 'اهتم', 'استفد'}
        lines = value.strip().split('\n')
        non_empty_lines = [line.strip() for line in lines if line.strip()]
        if len(non_empty_lines) != 3:
            return False
        for line in non_empty_lines:
            words = line.split()
            if not words:
                return False
            first_word = words[0]
            first_word = first_word.rstrip('.,!?;')
            if first_word not in imperative_verbs:
                return False
        return True



class DataIdx1514InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1514')

    def check_following(self, value):
        """Checks if the response is a very short story about an animal that avoids mentioning cats or dogs.
        Args:
            value: A string representing the response (the story).

        Returns:
            True if the response avoids mentioning 'القطط' or 'الكلاب', False otherwise.
        """
        if not isinstance(value, str):
            return False
        contains_cats = 'القطط' in value
        contains_dogs = 'الكلاب' in value
        return not contains_cats and (not contains_dogs)



class DataIdx1515InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1515')

    def check_following(self, value):
        """Checks if the response is a conditional sentence starting with 'إذا' and containing 'النجاح'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        starts_with_itha = value.strip().startswith('إذا')
        contains_alnajah = 'النجاح' in value
        return starts_with_itha and contains_alnajah



class DataIdx1516InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1516')

    def check_following(self, value):
        """
        Checks if the response is an Arabic birthday invitation with a Markdown numbered list schedule.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction, False otherwise.
        """
        if not isinstance(value, str):
            return False
        arabic_chars_present = bool(re.search('[\\u0600-\\u06FF\\uFB50-\\uFDFF\\uFE70-\\uFEFF]', value))
        lines = value.splitlines()
        numbered_list_items_found = []
        for line in lines:
            stripped_line = line.strip()
            if re.match('^\\d+\\. ', stripped_line):
                numbered_list_items_found.append(stripped_line)
        markdown_list_present = len(numbered_list_items_found) >= 2
        return arabic_chars_present and markdown_list_present



class DataIdx1517InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1517')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        required_word = 'تواصل'
        return required_word in value



class DataIdx1518InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1518')

    def check_following(self, value):
        """Checks if the response is a single sentence, contains 'التعاون',
        and refers to its importance in achieving common goals by
        checking for keywords 'تحقيق', 'الأهداف', 'المشتركة'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        response = value.strip()
        if not response:
            return False
        sentence_enders = ['.', '!', '?']
        if not response.endswith(tuple(sentence_enders)):
            return False
        terminator_count = sum((response.count(end) for end in sentence_enders))
        if terminator_count != 1:
            return False
        if 'التعاون' not in response:
            return False
        if 'تحقيق' not in response or 'الأهداف' not in response or 'المشتركة' not in response:
            return False
        return True



class DataIdx1519InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1519')
        self.weather_keywords = {'طقس', 'جو', 'شمس', 'مشمس', 'غيوم', 'غائم', 'مطر', 'ممطر', 'ثلج', 'مثلج', 'عاصفة', 'رياح', 'بارد', 'حار', 'دافئ', 'حرارة', 'رطوبة', 'سماء', 'صافية', 'ضباب', 'رعد', 'برق', 'جميل', 'سيء', 'تتساقط'}

    def check_following(self, value):
        """Checks if the response is a dialogue about the weather and is at least four sentences long.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        sentences = re.split('[.!?]+(?:\\s|\\n|$)', value.strip())
        valid_sentences = [s for s in sentences if s.strip()]
        sentence_count_ok = len(valid_sentences) >= 4
        text_cleaned = value.replace('.', '').replace('!', '').replace('?', '').replace(',', '')
        words = text_cleaned.split()
        found_keywords = {word for word in words if word in self.weather_keywords}
        weather_check_ok = len(found_keywords) >= 2
        return sentence_count_ok and weather_check_ok



class DataIdx1520InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1520')

    def check_following(self, value):
        """Checks if the response starts with 'في الصورة نرى...' and has less than 40 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        required_start = 'في الصورة نرى...'
        if not value.strip().startswith(required_start):
            return False
        words = value.strip().split()
        if len(words) >= 40:
            return False
        return True



class DataIdx1521InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1521')

    def check_following(self, value):
        """
        Checks if the input string contains exactly 5 sentences based on terminal punctuation.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains exactly 5 sentences, False otherwise.
        """
        if not isinstance(value, str):
            return False
        sentences = re.split('[.!?]', value)
        valid_sentences = [s.strip() for s in sentences if s.strip()]
        return len(valid_sentences) == 5



class DataIdx1522InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1522')

    def check_following(self, value):
        """Checks if the response is a short story around 100 words.
        Args:
            value: A string representing the response.

        Returns:
            True if the response is around 100 words, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        min_word_count = 80
        max_word_count = 120
        if min_word_count <= word_count <= max_word_count:
            return True
        else:
            return False



class DataIdx1523InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1523')

    def check_following(self, value):
        """Checks if the response uses the word 'عظيم' at least twice.

        Args:
            value: A string representing the response.

        Returns:
            True if the word 'عظيم' appears at least twice, False otherwise.
        """
        count = value.count('عظيم')
        return count >= 2



class DataIdx1524InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1524')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """

        def count_objects_recursive(data):
            count = 0
            if isinstance(data, dict):
                count += 1
                for value in data.values():
                    count += count_objects_recursive(value)
            elif isinstance(data, list):
                for item in data:
                    count += count_objects_recursive(item)
            return count
        try:
            parsed_json = json.loads(value)
            if not isinstance(parsed_json, dict):
                return False
            object_count = count_objects_recursive(parsed_json)
            return object_count >= 2
        except json.JSONDecodeError:
            return False
        except Exception:
            return False



class DataIdx1525InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1525')

    def check_following(self, value):
        """Checks if the response follows the constraints:
        1. It is a short paragraph about the favorite hobby. (Cannot check programmatically)
        2. It does not exceed 40 words. (Checkable)
        3. The name of the hobby must be mentioned in the first sentence. (Cannot check programmatically without knowing the hobby)

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the checkable constraint (word count) or False otherwise.
        """
        words = value.split()
        word_count = len(words)
        return word_count <= 40



class DataIdx1526InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1526')

    def check_following(self, value):
        """Checks if the response mentions a year exactly once and distinguishes an event name.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        years = re.findall('\\b\\d{4}\\b', value)
        year_count = len(years)
        year_constraint_met = year_count == 1
        distinguished_pattern = re.compile('\\".*?\\"|\\(.*?\\)|\\*\\*.*?\\*\\*')
        distinguished_found = distinguished_pattern.search(value) is not None
        return year_constraint_met and distinguished_found



class DataIdx1527InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1527')

    def check_following(self, value):
        """Checks if the response ends with an exclamation mark.
        Args:
            value: A string representing the response.

        Returns:
            True if the response is a string and ends with '!', False otherwise.
        """
        return value.endswith('!')



class DataIdx1528InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1528')

    def check_following(self, value):
        """Checks if the response mentions the phone's battery life as required.

        Args:
            value: A string representing the response (the advertisement text).

        Returns:
            True if the response mentions battery life, False otherwise.
        """
        battery_keyword = 'بطارية'
        duration_keywords = ['عمر', 'مدة', 'تدوم', 'أيام', 'ساعات', 'طويل', 'طويلة', 'طويلاً']
        mentions_battery = battery_keyword in value
        mentions_duration = any((keyword in value for keyword in duration_keywords))
        return mentions_battery and mentions_duration



class DataIdx1529InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1529')

    def check_following(self, value):
        """Checks if the response follows the instruction: concise (less than 10 words).
        Args:
            value: A string representing the response (the proposed title).

        Returns:
            True if the response is a string with less than 10 words, False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        words = cleaned_value.split()
        word_count = len(words)
        return word_count < 10



class DataIdx1530InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1530')

    def check_following(self, value):
        """Checks if the response is exactly three sentences long based on sentence-ending punctuation.
        Args:
            value: A string representing the response.

        Returns:
            True if the response contains exactly 3 sentences (parts separated by .!? followed by stripping) or False otherwise.
        """
        if not isinstance(value, str):
            return False
        parts = re.split('[.!?]', value)
        sentences = [part for part in parts if part.strip()]
        return len(sentences) == 3



class DataIdx1531InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1531')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1531.

        Constraints:
        1. Paragraph must have at least three sentences.
        2. Must not use any numbers.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if any((char.isdigit() for char in value)):
            return False
        sentence_enders = ['.', '!', '؟']
        sentence_count = sum((value.count(ender) for ender in sentence_enders))
        if sentence_count < 3:
            return False
        return True



class DataIdx1532InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1532')

    def check_following(self, value):
        """Checks if the response is a single Arabic sentence containing 'ق' at least 7 times.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        text = value.strip()
        if not text:
            return False
        qaf_count = text.count('ق')
        if qaf_count < 7:
            return False
        sentence_terminators = ['.', '؟', '!']
        ends_with_terminator = any((text.endswith(term) for term in sentence_terminators))
        if not ends_with_terminator:
            return False
        last_char_index = len(text) - 1
        for i in range(last_char_index):
            if text[i] in sentence_terminators:
                return False
        return True



class DataIdx1533InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1533')

    def check_following(self, value):
        """Checks if the response uses the word "ركن" at least twice.

        Args:
            value: A string representing the response.

        Returns:
            True if the response uses "ركن" 2 or more times, False otherwise.
        """
        if not isinstance(value, str):
            return False
        count_of_rokn = value.count('ركن')
        return count_of_rokn >= 2



class DataIdx1534InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1534')

    def check_following(self, value):
        """Checks if the response provides a list of three items numbered with parentheses (1), (2), (3).
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        found_item_1 = False
        found_item_2 = False
        found_item_3 = False
        for line in lines:
            trimmed_line = line.strip()
            if trimmed_line.startswith('(1)'):
                found_item_1 = True
            elif trimmed_line.startswith('(2)'):
                found_item_2 = True
            elif trimmed_line.startswith('(3)'):
                found_item_3 = True
        return found_item_1 and found_item_2 and found_item_3



class DataIdx1535InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1535')

    def check_following(self, value):
        """Checks if the response follows the instructions for baking a cake in 6 steps,
        using '===' separator, containing 'فرن', and ending with 'استمتع بالكعكة!'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not value.strip().endswith('استمتع بالكعكة!'):
            return False
        if 'فرن' not in value:
            return False
        parts = value.split('===')
        if len(parts) != 6:
            return False
        return True



class DataIdx1536InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1536')

    def check_following(self, value):
        """Checks if the response is a single Arabic sentence about teamwork importance
           containing the words 'تعاون' and 'نجاح'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        text = value.strip()
        has_taawun = 'تعاون' in text
        has_najah = 'نجاح' in text
        if not has_taawun or not has_najah:
            return False
        terminators = ['.', '!', '?']
        terminator_count = sum((text.count(term) for term in terminators))
        if terminator_count > 1:
            return False
        return True



class DataIdx1537InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1537')

    def check_following(self, value):
        """Checks if the response is a recipe for mint tea and is less than 45 words.
        The primary constraint check here is the word count.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (less than 45 words), False otherwise.
        """
        words = value.split()
        word_count = len(words)
        return word_count < 45



class DataIdx1538InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1538')

    def check_following(self, value):
        """Checks if the response starts with the Arabic word 'نعم'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response starts with 'نعم', False otherwise.
        """
        if isinstance(value, str):
            return value.strip().startswith('نعم')
        return False



class DataIdx1539InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1539')

    def check_following(self, value):
        """Checks if the response meets the constraints for question IDX 1539.
        Constraints:
        - Minimum 50 words.
        - Use the word 'إصرار' at least twice.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value:
            return False
        words = value.split()
        actual_words = [word for word in words if word]
        word_count = len(actual_words)
        min_words = 50
        word_count_ok = word_count >= min_words
        keyword = 'إصرار'
        min_keyword_count = 2
        keyword_count = value.count(keyword)
        keyword_count_ok = keyword_count >= min_keyword_count
        return word_count_ok and keyword_count_ok



class DataIdx1540InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1540')

    def check_following(self, value):
        """Checks if the response is a valid Arabic title for an article.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        max_title_length = 100
        if len(value) > max_title_length:
            return False
        has_arabic_char = False
        for char in value:
            if '\u0600' <= char <= 'ۿ':
                has_arabic_char = True
                break
        if not has_arabic_char:
            return False
        return True



class DataIdx1541InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1541')

    def check_following(self, value):
        """Checks if the response (email) does not contain exclamation marks.

        Args:
            value: A string representing the response (email content).

        Returns:
            True if the response does not contain '!', False otherwise.
        """
        return '!' not in value



class DataIdx1542InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1542')

    def check_following(self, value):
        """
        Checks if the response is a single paragraph according to the instruction.
        The instruction requires the critique to be in "one paragraph".
        A single paragraph is defined as a string that contains non-whitespace
        content and does not contain a blank line (two or more consecutive newlines,
        possibly separated by whitespace).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (is one paragraph with content),
            False otherwise.
        """
        if not value or not value.strip():
            return False
        normalized_value = value.replace('\r\n', '\n').replace('\r', '\n')
        if re.search('\\n\\s*\\n', normalized_value):
            return False
        return True



class DataIdx1543InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1543')

    def check_following(self, value):
        """Checks if the response is a list containing exactly 14 strings,
        where each string is in title case (first letter of each word capitalized).

        Args:
            value: A string representing the response (expected to be a list string).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        try:
            data = ast.literal_eval(value)
        except (ValueError, SyntaxError):
            return False
        if not isinstance(data, list):
            return False
        if len(data) != 14:
            return False
        for item in data:
            if not isinstance(item, str):
                return False
            if not item.istitle():
                return False
        return True



class DataIdx1544InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1544')

    def check_following(self, value):
        """Checks if the response is a comma-separated list of exactly 10 items.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        items = value.split(',')
        if not items:
            return False
        num_items = len([item.strip() for item in items if item.strip()])
        return num_items == 10



class DataIdx1545InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1545')

    def check_following(self, value):
        """
        Checks if the response follows the instructions for question 1545:
        - Is a short congratulatory message for Eid al-Fitr. (Style is subjective, check structure)
        - Uses 'تهنئة' as a keyword.
        - Is enclosed completely in square brackets [].
        - Is divided into two sections: 'التحية' and 'التهنئة'. (Assumes JSON list with one dict)
        """
        stripped_value = value.strip()
        if not (stripped_value.startswith('[') and stripped_value.endswith(']')):
            return False
        if 'تهنئة' not in value:
            return False
        try:
            data = json.loads(stripped_value)
            if not isinstance(data, list) or len(data) != 1:
                return False
            content = data[0]
            if not isinstance(content, dict):
                return False
            if 'التحية' not in content or 'التهنئة' not in content:
                return False
        except json.JSONDecodeError:
            return False
        except Exception:
            return False
        return True



class DataIdx1546InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1546')

    def check_following(self, value):
        """Checks if the response includes the word 'اقتراح' at least three times.

        Args:
            value: A string representing the response.

        Returns:
            True if the response includes 'اقتراح' >= 3 times, False otherwise.
        """
        word_to_count = 'اقتراح'
        count = value.count(word_to_count)
        return count >= 3



class DataIdx1547InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1547')

    def check_following(self, value):
        """Checks if the response includes the required words with the specified counts.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response contains 'تكنولوجيا' at least twice and 'تطور' at least once, False otherwise.
        """
        if not isinstance(value, str):
            return False
        tech_count = value.count('تكنولوجيا')
        dev_count = value.count('تطور')
        return tech_count >= 2 and dev_count >= 1



class DataIdx1548InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1548')

    def check_following(self, value):
        """Checks if the response explains solving the equation from a third-person perspective."""
        if not isinstance(value, str):
            return False
        text = value
        relevant_terms = ['x', 'س', '2', '5', '11', '6', '3', '٢', '٥', '١١', '٦', '٣', 'المعادلة', 'حل', 'قيمة', 'اطرح', 'طرح', 'أضف', 'إضافة', 'قسمة', 'اقسم', 'ضرب', 'اضرب', 'طرفي', 'الطرفين', 'الطرف', 'انقل', 'نقل', 'يساوي']
        discusses_topic = any((term in text for term in relevant_terms))
        has_variable_or_number = 'x' in text or 'س' in text or any((num in text for num in ['2', '5', '11', '6', '3', '٢', '٥', '١١', '٦', '٣']))
        has_operation_or_side = any((term in text for term in ['اطرح', 'طرح', 'أضف', 'إضافة', 'قسمة', 'اقسم', 'ضرب', 'اضرب', 'طرفي', 'الطرفين', 'الطرف', 'انقل', 'نقل']))
        explains_how = has_variable_or_number and has_operation_or_side
        if not explains_how:
            return False
        first_person_indicators = ['أنا', 'نحن', 'أقوم', 'نقوم', 'أبدأ', 'نبدأ', 'أرى', 'نرى', 'عليّ', 'علينا', 'يمكنني', 'يمكننا', 'أستطيع', 'نستطيع', 'لي', 'لنا', 'مني', 'مننا']
        contains_first_person = any((term in text for term in first_person_indicators))
        if contains_first_person:
            return False
        return True



class DataIdx1549InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1549')

    def check_following(self, value):
        """Checks if the response is a simple tea recipe in four sentences with 'ماء' appearing at least twice.

        Args:
            value: A string representing the response (the recipe).

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        water_count = value.count('ماء')
        if water_count < 2:
            return False
        sentence_terminators = ['.', '!', '؟']
        sentences = []
        current_sentence = ''
        for char in value:
            current_sentence += char
            if char in sentence_terminators:
                if current_sentence.strip():
                    sentences.append(current_sentence.strip())
                current_sentence = ''
        if current_sentence.strip():
            sentences.append(current_sentence.strip())
        sentence_count = len(sentences)
        return sentence_count == 4



class DataIdx1550InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1550')

    def check_following(self, value):
        """Checks if the response is a paragraph with more than 60 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response has more than 60 words, False otherwise.
        """
        words = value.split()
        return len(words) > 60



punctuation_chars = '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~،؛؟'

def clean_word(word):
    """Removes leading/trailing punctuation from a word."""
    while word and word[0] in punctuation_chars:
        word = word[1:]
    while word and word[-1] in punctuation_chars:
        word = word[:-1]
    return word

class DataIdx1551InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1551')

    def check_following(self, value):
        """Checks if the response follows the instructions.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if value.count('\n') >= 3:
            return False
        if 'أزهار' not in value:
            return False
        words = value.split()
        for word in words:
            cleaned = clean_word(word)
            if cleaned.startswith('الم'):
                return False
        return True



class DataIdx1552InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1552')

    def check_following(self, value):
        """
        Checks if the response mentions exactly three items separated by ',' or 'و'
         and contains the word 'ماء' at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if 'ماء' not in value:
            return False
        items = re.split('[,\\u0648]', value)
        cleaned_items = [item.strip() for item in items if item.strip()]
        if len(cleaned_items) != 3:
            return False
        return True



class DataIdx1553InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1553')

    def check_following(self, value):
        """
        Checks if the response contains a question starting with 'لماذا'
        and an answer starting with 'لأن' which is a single sentence ending with '.'
        (Cannot check if related to the topic of study).
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the checkable instructions or False otherwise.
        """
        if not isinstance(value, str):
            return False
        value_normalized = ' '.join(value.split()).strip()
        if not value_normalized:
            return False
        idx_lemaza = value.find('لماذا')
        idx_leana = value.find('لأن')
        if idx_lemaza == -1 or idx_leana == -1:
            return False
        if idx_lemaza >= idx_leana:
            return False
        idx_dot = value.find('.', idx_leana + len('لأن'))
        if idx_dot == -1:
            return False
        if value.find('.', idx_leana + len('لأن'), idx_dot) != -1:
            return False
        if value[idx_dot + 1:].strip():
            return False
        return True



class DataIdx1554InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1554')

    def check_following(self, value):
        """Checks if the response is the fruit name 'التفاح' based on the constraint 'starts with التفاح'.
        The question asks for a single fruit name in Arabic that starts with 'التفاح'.
        Given that 'التفاح' is a fruit name itself, the only plausible answer that starts with 'التفاح' is 'التفاح'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is exactly 'التفاح' (case-sensitive, ignoring leading/trailing whitespace), False otherwise.
        """
        cleaned_value = value.strip()
        expected_answer = 'التفاح'
        return cleaned_value == expected_answer



class DataIdx1555InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1555')

    def check_following(self, value):
        """Checks if the response includes at least one hashtag and at least one emoji.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction, False otherwise.
        """
        if not isinstance(value, str):
            return False
        has_hashtag = '#' in value

        def is_emoji(char):
            code = ord(char)
            return 128512 <= code <= 128591 or 127744 <= code <= 128511 or 128640 <= code <= 128767 or (129280 <= code <= 129535) or (9728 <= code <= 9983) or (9984 <= code <= 10175) or (65024 <= code <= 65039) or (8205 == code) or (8419 == code) or (127462 <= code <= 127487) or (57344 <= code <= 63743) or (8960 <= code <= 9215) or (11088 == code) or (11093 == code)
        has_emoji = any((is_emoji(char) for char in value))
        return has_hashtag and has_emoji



class DataIdx1556InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1556')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1556.
        Constraints:
        - Single sentence
        - At least 15 words
        - Does not use conjunctions (و, أو, ثم, لكن)

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        processed_value = value.strip()
        words = processed_value.split()
        word_count = len(words)
        if word_count < 15:
            return False
        forbidden_patterns_regex = re.compile('\\b(و|أو|ثم|لكن)\\b')
        if forbidden_patterns_regex.search(processed_value):
            return False
        terminal_punctuations = ['.', '!', '?']
        last_non_punc_idx = len(processed_value) - 1
        while last_non_punc_idx >= 0 and processed_value[last_non_punc_idx] in terminal_punctuations:
            last_non_punc_idx -= 1
        text_before_last_punc_block = processed_value[:last_non_punc_idx + 1]
        internal_punc_count = 0
        for char in text_before_last_punc_block:
            if char in terminal_punctuations:
                internal_punc_count += 1
        if internal_punc_count > 0:
            return False
        return True



class DataIdx1557InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1557')

    def check_following(self, value):
        """Checks if the response follows the instruction constraints.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the word count is 60 words or less, False otherwise.
        """
        words = value.split()
        return len(words) <= 60



class DataIdx1558InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1558')

    def check_following(self, value):
        """Checks if the response expresses gratitude in Arabic.
        Args:
            value: A string representing the response.

        Returns:
            True if the response expresses gratitude, False otherwise.
        """
        gratitude_indicators = ['شكرا', 'ممتن', 'بارك الله', 'جزاك الله', 'ممنون']
        return any((indicator in value for indicator in gratitude_indicators))



class DataIdx1559InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1559')

    def check_following(self, value):
        """
        Checks if the response is a single Arabic sentence in the past perfect
        describing an action before another, containing at least two verbs.
        Uses heuristic checks based on sentence structure and keywords.

        Args:
            value: A string representing the response.

        Returns:
            True if the response plausibly follows the instruction, False otherwise.
        """
        if not isinstance(value, str):
            return False
        trimmed_value = value.strip()
        terminal_punctuations = ['.', '?', '!', '؟']
        punc_count = sum((trimmed_value.count(p) for p in terminal_punctuations))
        ends_with_punc = trimmed_value.endswith(tuple(terminal_punctuations))
        if punc_count != 1 or not ends_with_punc:
            return False
        cleaned_value = trimmed_value
        for p in terminal_punctuations:
            if cleaned_value.endswith(p):
                cleaned_value = cleaned_value[:-1].strip()
                break
        if 'كان' not in cleaned_value and 'كانت' not in cleaned_value:
            return False
        words = cleaned_value.split()
        if len(words) < 5:
            return False
        return True



class DataIdx1560InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1560')

    def check_following(self, value):
        """Checks if the response contains the word 'نجاح' exactly four times
        in a single sentence structure (defined as ending with . ! or ? and
        not containing these characters internally before the end).
        Skips checking if the sentence specifically talks about *achieving* success
        as this is subjective and not reliably verifiable by simple code.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        count = len(re.findall('\\bنجاح\\b', value))
        if count != 4:
            return False
        if '\n' in value:
            return False
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        terminators = ['.', '!', '?']
        ends_with_terminator = cleaned_value.endswith(tuple(terminators))
        if not ends_with_terminator:
            return False
        last_char_index = len(cleaned_value) - 1
        for i in range(last_char_index):
            if cleaned_value[i] in terminators:
                return False
        return True



class DataIdx1561InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1561')

    def check_following(self, value):
        """Checks if the response is a single sentence and contains exactly two words
           that start with common Arabic present-tense prefixes (ي, ت, أ, ن) after punctuation stripping.
           Note: This uses a simple heuristic for verb identification based on prefixes, which is not linguistically perfect.
           It also checks for single sentence structure based on terminal punctuation.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        value = value.strip()
        if not value:
            return False
        terminal_punctuation = ['.', '!', '?']
        term_punct_count = sum((value.count(p) for p in terminal_punctuation))
        if term_punct_count != 1:
            return False
        if value[-1] not in terminal_punctuation:
            return False
        words = value[:-1].split()
        potential_verb_count = 0
        verb_prefixes = {'ي', 'ت', 'أ', 'ن'}
        word_punctuation_to_strip = '.,!?;:"\'()[]{}«»،؛'
        for word in words:
            cleaned_word = word.strip(word_punctuation_to_strip)
            if cleaned_word and cleaned_word[0] in verb_prefixes:
                potential_verb_count += 1
        return potential_verb_count == 2



class DataIdx1562InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1562')

    def check_following(self, value):
        """Checks if the response describes a futuristic city with tech, using future tense.
        This check uses heuristics based on keyword presence and future tense indicators,
        as strict verification of all constraints (like counting tech elements) is
        not reliably possible with simple methods."""
        if not isinstance(value, str) or not value.strip():
            return False
        text = value.strip()
        city_keywords = ['مدينة', 'شوارع', 'مباني', 'سكان', 'طرق', 'أحياء', 'منطقة', 'مركز', 'حي', 'عمارات', 'ناقلات', 'أبراج']
        tech_keywords = ['مستقبل', 'تكنولوجيا', 'آلي', 'ذكي', 'طائر', 'روبوت', 'رقمي', 'افتراضي', 'مركبة ذاتية', 'طائرة بدون طيار', 'شبكة', 'بيانات', 'تحكم', 'طاقة نظيفة', 'افتراضي', 'ثلاثي الأبعاد', 'هولوغرافي', 'صناعي', 'ذاتية القيادة', 'ذكاء اصطناعي', 'حساسات', 'شاشات', 'طاقة شمسية', 'نظام مركزي']
        future_prefixes_and_sowfa = ['سوف', 'سأ', 'ست', 'سي', 'سن']
        has_city_keyword = any((kw in text for kw in city_keywords))
        has_tech_keyword = any((kw in text for kw in tech_keywords))
        has_future_tense = False
        if 'سوف' in text:
            has_future_tense = True
        if not has_future_tense:
            if re.search('\\b(سأ|ست|سي|سن)[\\u0600-\\u06FF]+', text):
                has_future_tense = True
        if not has_future_tense:
            if re.search('\\bس[ييتان][\\u0600-\\u06FF]+', text):
                has_future_tense = True
        return has_city_keyword and has_tech_keyword and has_future_tense



class DataIdx1563InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1563')

    def check_following(self, value):
        """Checks if the value is a simple Arabic nominal sentence (مبتدأ وخبر فقط).
        This is a heuristic check based on sentence structure and length,
        as full Arabic grammar parsing or semantic analysis is not feasible
        without external libraries and domain-specific knowledge (Arabic NLP).

        The check assumes a simple example will be provided,
        consisting of 2 to 6 words, representing the مبتدأ and the خبر
        (which might be a single word or a short phrase).

        Args:
            value: A string representing the response.

        Returns:
            True if the response heuristically matches the criteria, False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        sentence = value.strip()
        words = sentence.split()
        words = [word for word in words if word]
        min_words = 2
        max_words = 6
        if len(words) < min_words or len(words) > max_words:
            return False
        return True



class DataIdx1564InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1564')

    def check_following(self, value):
        """Checks if the value contains the Arabic letters 'ي' and 'ت'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response contains both 'ي' and 'ت', False otherwise.
        """
        if not isinstance(value, str):
            return False
        has_ya = 'ي' in value
        has_ta = 'ت' in value
        return has_ya and has_ta



class DataIdx1565InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1565')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1565.

        Instructions:
        - Write one paragraph. (Implicitly checked by sentence count within a single block)
        - Consists of at least five sentences.
        - Must contain the word 'المعرفة' at least three times.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not value:
            return False
        sentences = [s.strip() for s in re.split('[.?!]', value) if s.strip()]
        sentence_count = len(sentences)
        sentence_constraint_met = sentence_count >= 5
        word_count = len(re.findall('\\bالمعرفة\\b', value))
        word_constraint_met = word_count >= 3
        return sentence_constraint_met and word_constraint_met



class DataIdx1566InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1566')

    def check_following(self, value):
        """Checks if the response is a short apology message for being late for an appointment,
           includes the reason for the delay, and a sincere apology.
           Criteria:
           1. Is a string.
           2. Word count is within a reasonable limit for "short" (e.g., <= 60 words).
           3. Contains terms related to apology.
           4. Contains terms related to lateness or appointment.
           5. Contains terms indicating a reason for the delay.
        """
        if not isinstance(value, str):
            return False
        punctuation_and_digits = '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~' + '،؛؟٪٬٫' + '0123456789'
        translator = str.maketrans('', '', punctuation_and_digits)
        cleaned_value = value.translate(translator)
        words = cleaned_value.split()
        words = [word for word in words if word]
        max_word_count = 60
        if len(words) > max_word_count:
            return False
        apology_keywords = {'اعتذر', 'اسف', 'معذرة', 'عذرا', 'آسف'}
        lateness_keywords = {'تاخير', 'متاخر', 'موعد', 'تاخرت', 'ميعاد', 'جيت', 'اتيت', 'التاخير', 'الموعد', 'تأخرت', 'تأخير'}
        reason_indicators = {'بسبب', 'لاني', 'لانني', 'عطل', 'طارئ', 'ظرف', 'مشكلة', 'زحمة', 'حادث', 'لان', 'بأن'}
        word_set = set(words)
        has_apology = any((keyword in word_set for keyword in apology_keywords))
        has_topic = any((keyword in word_set for keyword in lateness_keywords))
        has_reason = any((keyword in word_set for keyword in reason_indicators))
        return len(words) > 0 and has_apology and has_topic and has_reason



class DataIdx1567InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1567')

    def check_following(self, value):
        """Checks if the response follows the instruction to write a sentence that asks a question without using a question mark.
        This checker primarily verifies the explicit constraint: the absence of a question mark.
        Determining if a sentence truly "asks a question" without standard interrogative markers is complex
        and depends on context and structure not easily verifiable programmatically in a simple checker.
        Therefore, this check focuses on the negative constraint.

        Args:
            value: A string representing the response.

        Returns:
            True if the response does not contain a question mark, False otherwise.
        """
        return '?' not in value



class DataIdx1568InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1568')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1568
           using only built-in string methods as requested.

        Constraints:
        1. Use the word 'خطوة' at least 4 times.
        2. Less than 5 sentences.
        3. Place ingredients in parentheses (). (Check if any content is in ())

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        step_word_count = value.count('خطوة')
        if step_word_count < 4:
            return False
        temp_value = value.replace('!', '.').replace('?', '.')
        sentences = [s for s in temp_value.split('.') if s.strip()]
        sentence_count = len(sentences)
        if sentence_count >= 5:
            return False
        has_parentheses_with_content = False
        i = 0
        while i < len(value):
            if value[i] == '(':
                j = i + 1
                while j < len(value) and value[j] != ')':
                    j += 1
                if j < len(value) and value[j] == ')':
                    content = value[i + 1:j].strip()
                    if content:
                        has_parentheses_with_content = True
                        break
                    i = j + 1
                else:
                    i += 1
            else:
                i += 1
        if not has_parentheses_with_content:
            return False
        return True



class DataIdx1569InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1569')

    def check_following(self, value):
        """Checks if the response is a single sentence starting with 'أشك', contains 'المعلومة', and has 6-11 words.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value.startswith('أشك'):
            return False
        if 'المعلومة' not in cleaned_value:
            return False
        words = cleaned_value.split()
        word_count = len(words)
        if not 6 <= word_count <= 11:
            return False
        return True



class DataIdx1570InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1570')

    def check_following(self, value):
        """Checks if the response is a sentence about the importance of time,
        does not exceed three words, and uses the word 'ثمين'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        contains_thameen = 'ثمين' in value
        words = value.split()
        word_count = len(words)
        length_check = word_count <= 3
        return contains_thameen and length_check



class DataIdx1571InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1571')

    def check_following(self, value):
        """Checks if the response is a string placed within single quotes and does not contain semicolons.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        starts_with_single_quote = value.startswith("'")
        ends_with_single_quote = value.endswith("'")
        contains_semicolon = ';' in value
        return starts_with_single_quote and ends_with_single_quote and (not contains_semicolon)



class DataIdx1572InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1572')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1572.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        separator = '$$$$'
        parts = value.split(separator)
        if len(parts) != 2:
            return False
        part1 = parts[0]
        part2 = parts[1]
        if 'تسهيل' not in part1:
            return False
        if 'تطور' not in part2:
            return False
        return True



class DataIdx1573InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1573')

    def check_following(self, value):
        """Checks if the response follows the constraints:
        1. Contains exactly two items.
        2. Items are separated by a comma.
        3. Items are in a numbered list format (1, 2).

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        parts = value.split(',')
        if len(parts) != 2:
            return False
        part1 = parts[0].strip()
        if not (part1.startswith('1.') or part1.startswith('1)')):
            return False
        part2 = parts[1].strip()
        if not (part2.startswith('2.') or part2.startswith('2)')):
            return False
        return True



class DataIdx1574InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1574')

    def check_following(self, value):
        """Checks if the response contains a season name in bold Markdown format.

        Args:
            value: A string representing the response.

        Returns:
            True if a bold season name is found, False otherwise.
        """
        arabic_seasons = ['الربيع', 'الصيف', 'الخريف', 'الشتاء']
        for season in arabic_seasons:
            bold_season = f'**{season}**'
            if bold_season in value:
                return True
        return False



class DataIdx1575InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('1575')

    def check_following(self, value):
        """Checks if the response is a single sentence about coffee containing 'لذيذ' and exactly one quotation mark.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the explicit constraints, False otherwise.
        """
        contains_delicious = 'لذيذ' in value
        total_quotes = value.count("'") + value.count('"')
        has_exactly_one_quote = total_quotes == 1
        return contains_delicious and has_exactly_one_quote



class DataIdx1576InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1576')

    def check_following(self, value):
        """Checks if the response contains three bullet points where the second is strictly longer than the first and third.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        lines = value.strip().split('\n')
        bullet_points_text = []
        bullet_markers = ['* ', '- ', '+ ']
        for line in lines:
            stripped_line = line.strip()
            found_marker = False
            for marker in bullet_markers:
                if stripped_line.startswith(marker):
                    if len(stripped_line) > len(marker):
                        bullet_points_text.append(stripped_line[len(marker):])
                        found_marker = True
                    break
        if len(bullet_points_text) != 3:
            return False
        point1_text = bullet_points_text[0]
        point2_text = bullet_points_text[1]
        point3_text = bullet_points_text[2]
        len1 = len(point1_text)
        len2 = len(point2_text)
        len3 = len(point3_text)
        if len2 > len1 and len2 > len3:
            return True
        else:
            return False



class DataIdx1577InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1577')

    def check_following(self, value):
        """Checks if the response is a non-empty string, contains Arabic characters, and meets a minimum length to approximate a paragraph.
        Note: Cannot reliably check for 'persuasive', 'defending a POV', or 'strong verbs' purely algorithmically.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        contains_arabic = False
        for char in value:
            if '\u0600' <= char <= 'ۿ':
                contains_arabic = True
                break
        if not contains_arabic:
            pass
        if not contains_arabic:
            return False
        min_length = 100
        if len(value) < min_length:
            return False
        return True



class DataIdx1578InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1578')

    def check_following(self, value):
        """Checks if the response contains all required short vowels (Fatha, Kasra, Damma, Sukun).
        Args:
            value: A string representing the response (expected to be an Arabic sentence).

        Returns:
            True if the response contains all required diacritics or False otherwise.
        """
        fatha = 'َ'
        kasra = 'ِ'
        damma = 'ُ'
        sukun = 'ْ'
        has_fatha = fatha in value
        has_kasra = kasra in value
        has_damma = damma in value
        has_sukun = sukun in value
        return has_fatha and has_kasra and has_damma and has_sukun



class DataIdx1579InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1579')

    def check_following(self, value):
        """
        Checks if the response is a thank-you letter to a teacher
        mentioning at least two specific things.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        if len(value.strip()) < 80:
            return False
        gratitude_keywords = ['شكرا', 'ممتن', 'أقدر', 'شكر', 'امتنان', 'تقدير', 'بفضل']
        reason_indicators_regex = ['\\bعلى\\b', '\\bلـ\\b', '\\bفي\\b', '\\bبـ\\b', '\\bمن\\b', 'علمتني', 'ساعدتني', 'نصيحتك', 'شرحك', 'أسلوبك', 'وقوفك', 'دعمك', 'تشجيعك', 'توجيهك', 'اهتمامك', 'صبرك', 'كيف أنك', 'عندما']
        if not any((keyword in value for keyword in gratitude_keywords)):
            return False
        clause_delimiters = '[.!?؛،]\\s*'
        clauses = re.split(clause_delimiters, value.strip())
        clauses = [c.strip() for c in clauses if c.strip()]
        specific_points_count = 0
        for clause in clauses:
            has_gratitude_in_clause = any((keyword in clause for keyword in gratitude_keywords))
            has_reason_in_clause = any((re.search(pattern, clause) for pattern in reason_indicators_regex))
            if has_gratitude_in_clause and has_reason_in_clause:
                specific_points_count += 1
        return specific_points_count >= 2



class DataIdx1580InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1580')

    def check_following(self, value):
        """Checks if the response contains two pet names separated by exactly six hash symbols.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        separator = '######'
        if value.count(separator) != 1:
            return False
        parts = value.split(separator)
        if len(parts) == 2 and parts[0].strip() and parts[1].strip():
            return True
        else:
            return False



class DataIdx1581InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1581')

    def check_following(self, value):
        """Checks if the response is at least 100 words long.
        Args:
            value: A string representing the response.

        Returns:
            True if the response is 100 words or more, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        return len(words) >= 100



class DataIdx1582InstructionChecker(IFevalSynArInstructions):
    common_adverbs = {'جداً', 'قليلاً', 'كثيراً', 'سريعاً', 'بطيئاً', 'دائماً', 'أبداً', 'غالباً', 'أحياناً', 'نادراً', 'فوراً', 'حالاً', 'لاحقاً', 'قديماً', 'حديثاً', 'أمس', 'غداً', 'اليوم', 'الآن', 'صباحاً', 'مساءً', 'ليلاً', 'نهاراً', 'هنا', 'هناك', 'حيث', 'فوق', 'تحت', 'أمام', 'خلف', 'يميناً', 'شمالاً', 'شرقاً', 'غرباً', 'بعيداً', 'قريباً', 'حول', 'بين', 'معاً', 'سوية', 'تماماً', 'كلياً', 'جزئياً', 'نسبياً', 'مطلقاً', 'هادئاً', 'قوياً', 'ضعيفاً', 'فقط', 'أيضاً', 'حتماً', 'قطعاً', 'تدريجياً'}

    def __init__(self):
        super().__init__('idx_1582')

    def check_following(self, value):
        """You will implement the logic of the function here to see if the response is correct or not.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        cleaned_value = re.sub('[^\\w\\s]', '', value).lower()
        words = cleaned_value.split()
        adverb_count = 0
        for word in words:
            if word in self.common_adverbs:
                adverb_count += 1
        return adverb_count >= 2



class DataIdx1583InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1583')

    def check_following(self, value):
        """Checks if the response mentions at least two Cairo landmarks.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        cairo_landmarks = ['الأهرامات', 'أبو الهول', 'المتحف المصري', 'برج القاهرة', 'خان الخليلي', 'قلعة صلاح الدين الأيوبي', 'مسجد محمد علي', 'الأزهر', 'شارع المعز', 'النيل', 'كنيسة المعلقة', 'مصر القديمة']
        found_landmarks_count = 0
        found_landmarks = set()
        for landmark in cairo_landmarks:
            if landmark in value:
                found_landmarks.add(landmark)
        return len(found_landmarks) >= 2



class DataIdx1584InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1584')

    def check_following(self, value):
        """Checks if the response is a description of a historical city in exactly two sentences,
        with the first sentence having at least 6 words and the second at least 4 words.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not value or not isinstance(value, str):
            return False
        sentences = re.split('[.!?]\\s*', value)
        sentences = [s.strip() for s in sentences if s.strip()]
        if len(sentences) != 2:
            return False
        sentence1 = sentences[0]
        words1 = re.split('\\s+', sentence1)
        words1 = [w for w in words1 if w]
        word_count1 = len(words1)
        if word_count1 < 6:
            return False
        sentence2 = sentences[1]
        words2 = re.split('\\s+', sentence2)
        words2 = [w for w in words2 if w]
        word_count2 = len(words2)
        if word_count2 < 4:
            return False
        return True



class DataIdx1585InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1585')

    def check_following(self, value):
        """
        Checks if the response is a numbered list of exactly three items,
        where each item starts with the Arabic letter 'ا'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        lines = value.strip().split('\n')
        extracted_items = []
        list_item_pattern = re.compile('^\\s*(\\d+)[\\.\\-\\)]\\s*(.+)$')
        found_numbers = set()
        for line in lines:
            match = list_item_pattern.match(line)
            if match:
                item_number = int(match.group(1))
                item_text = match.group(2).strip()
                if 1 <= item_number <= 3 and item_number not in found_numbers:
                    found_numbers.add(item_number)
                    if item_text:
                        extracted_items.append((item_number, item_text))
                elif item_number in found_numbers:
                    return False
        extracted_items.sort()
        if len(extracted_items) != 3 or set((item[0] for item in extracted_items)) != {1, 2, 3}:
            return False
        for item_number, item_text in extracted_items:
            if not item_text or item_text[0] != 'ا':
                return False
        return True



class DataIdx1586InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1586')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1586.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value.startswith('<<') or (not value.endswith('>>')):
            return False
        inner_value = value[2:-2]
        valid_answers = ['نعم', 'لا']
        if inner_value not in valid_answers:
            return False
        expected_length = len('<<') + len(inner_value) + len('>>')
        if len(value) != expected_length:
            return False
        return True



class DataIdx1587InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1587')

    def check_following(self, value):
        """Checks if the response is a summary within 150 words.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the word count instruction or False otherwise.
        """
        words = value.split()
        return len(words) <= 150



class DataIdx1588InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1588')

    def check_following(self, value):
        """Checks if the response follows the instruction.
        The response must be 'نعم' or 'لا' followed by a period.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        return value == 'نعم.' or value == 'لا.'



class DataIdx1589InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1589')

    def check_following(self, value):
        """
        Checks if the response is a single sentence based on the presence and placement of sentence terminators.
        A single sentence is considered valid if it contains at least one terminator (., !, ?)
        and there are no non-whitespace, non-terminator characters after the first terminator found.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (is structurally a single sentence) or False otherwise.
        """
        if not isinstance(value, str):
            return False
        stripped_value = value.strip()
        if not stripped_value:
            return False
        terminators = {'.', '!', '?'}
        first_term_idx = -1
        for i, char in enumerate(stripped_value):
            if char in terminators:
                first_term_idx = i
                break
        if first_term_idx == -1:
            return False
        for i in range(first_term_idx + 1, len(stripped_value)):
            if stripped_value[i] not in terminators and (not stripped_value[i].isspace()):
                return False
        return True



class DataIdx1590InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1590')

    def check_following(self, value):
        """Checks if the response is a dialogue in three paragraphs and contains no exclamation marks.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        if '!' in value:
            return False
        cleaned_value = value.strip()
        paragraphs = cleaned_value.split('\n\n')
        non_empty_paragraphs = [p.strip() for p in paragraphs if p.strip()]
        if len(non_empty_paragraphs) != 3:
            return False
        return True



class DataIdx1591InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1591')

    def check_following(self, value):
        """Checks if the response is a single sentence explaining 'السلام عليكم'
           and includes the word 'تحية'.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        ends_with_terminator = cleaned_value.endswith('.') or cleaned_value.endswith('!') or cleaned_value.endswith('?')
        contains_tahia = 'تحية' in cleaned_value
        if len(cleaned_value) < len('تحية') + 5:
            return False
        return ends_with_terminator and contains_tahia



class DataIdx1592InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1592')

    def check_following(self, value):
        """Checks if the response is a short, non-empty text tagline.

        Args:
            value: A string representing the response.

        Returns:
            True if the response is a non-empty string with at most 10 words,
            False otherwise.
        """
        if not isinstance(value, str) or not value.strip():
            return False
        words = value.strip().split()
        word_count = len(words)
        if 1 <= word_count <= 10:
            return True
        else:
            return False



class DataIdx1593InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1593')

    def check_following(self, value):
        """Checks if the response lists three things, each in uppercase."""
        items = value.strip().split('\n')
        items = [item.strip() for item in items if item.strip()]
        if len(items) != 3:
            return False
        for item in items:
            if item.upper() != item:
                return False
        return True



class DataIdx1594InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1594')

    def is_single_sentence(self, text):
        """Checks if the text looks like a single sentence ending with terminal punctuation."""
        text = text.strip()
        if not text:
            return False
        terminal_punctuation = ['.', '!', '?']
        if not text.endswith(tuple(terminal_punctuation)):
            return False
        text_without_end = text[:-1].rstrip()
        if re.search('[.!?]\\s', text_without_end):
            return False
        if not text_without_end.strip():
            return False
        return True

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1594.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not value.strip().endswith('شكرًا'):
            return False
        thank_you_index = value.rfind('شكرًا')
        if thank_you_index == -1:
            return False
        list_content = value[:thank_you_index]
        if 'أحب' in list_content:
            return False
        numbered_matches = list(re.finditer('\\d+\\.\\s*', list_content))
        if len(numbered_matches) != 2:
            return False
        match1 = numbered_matches[0]
        match2 = numbered_matches[1]
        num1_text = match1.group(0).strip()
        num2_text = match2.group(0).strip()
        if num1_text != '1.' or num2_text != '2.':
            return False
        remaining_content_after_item2 = value[match2.end():thank_you_index]
        if re.search('\\d+\\.\\s*', remaining_content_after_item2):
            return False
        item1_start_idx = match1.end()
        item1_end_idx = match2.start()
        text_item1_raw = value[item1_start_idx:item1_end_idx]
        item2_start_idx = match2.end()
        item2_end_idx = thank_you_index
        text_item2_raw = value[item2_start_idx:item2_end_idx]
        if not self.is_single_sentence(text_item1_raw):
            return False
        if not self.is_single_sentence(text_item2_raw):
            return False
        return True



class DataIdx1595InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1595')

    def check_following(self, value):
        """Checks if the response is a single word.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction (is a single word), False otherwise.
        """
        words = value.strip().split()
        return len(words) == 1



class DataIdx1596InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1596')
        self.required_phrase = 'بشكل ملحوظ'
        self.original_replaced_phrase = 'بشكل كبير'

    def check_following(self, value):
        """Checks if the response rewrites the sentence using synonyms for key words and includes 'بشكل ملحوظ'.
        Specifically checks for the presence of 'بشكل ملحوظ' and the absence of 'بشكل كبير'.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        contains_required_phrase = self.required_phrase in value
        does_not_contain_original_phrase = self.original_replaced_phrase not in value
        return contains_required_phrase and does_not_contain_original_phrase



class DataIdx1597InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1597')

    def check_following(self, value):
        """Checks if the response follows the instructions for IDX 1597.
        
        The instructions require:
        1. A simple fruit salad recipe description. (Difficult to check programmatically)
        2. Inclusion of an ingredients list. (Check for keyword 'المكونات')
        3. Inclusion of preparation steps. (Check for keyword 'خطوات التحضير')
        4. Inclusion of the word 'لذيذ' at least once.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the checkable instructions, False otherwise.
        """
        has_delicious_keyword = 'لذيذ' in value
        has_ingredients_section = 'المكونات' in value
        has_steps_section = 'خطوات التحضير' in value
        return has_delicious_keyword and has_ingredients_section and has_steps_section



class DataIdx1598InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1598')

    def check_following(self, value):
        """Checks if the response is a single Arabic predatory animal name starting with 'ل',
        enclosed in double quotes, and written as a single word.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not value.startswith('"') or not value.endswith('"'):
            return False
        inner_value = value[1:-1]
        if not inner_value:
            return False
        if ' ' in inner_value.strip():
            return False
        if ' ' in inner_value:
            return False
        if not inner_value.startswith('ل'):
            return False
        arabic_chars = '0123456789\u0600-ۿݐ-ݿࢠ-ࣿﭐ-﷿ﹰ-\ufeff\u200c\u200d'
        if any((c not in arabic_chars for c in inner_value)):
            pass
        return True



class DataIdx1599InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1599')

    def check_following(self, value):
        """Checks if the response is one sentence in colloquial Arabic, not exceeding ten words,
        expressing an opinion on reading importance, with no punctuation except a question mark at the end.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str) or not value:
            return False
        if not value.endswith('؟'):
            return False
        word_list = value.split()
        if len(word_list) > 10:
            return False
        for i in range(len(value) - 1):
            char = value[i]
            if unicodedata.category(char).startswith('P'):
                return False
        return True



class DataIdx1600InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1600')

    def check_following(self, value):
        """Checks if the response follows the constraints:
        - The description must not exceed 60 words.
        - The description must mention the word 'جميل' at least once.

        Args:
            value: A string representing the response in Arabic.

        Returns:
            True if the response follows the instructions, False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        if word_count > 60:
            return False
        if 'جميل' not in value:
            return False
        return True



class DataIdx1601InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1601')

    def check_following(self, value):
        if not isinstance(value, str):
            return False
        value_trimmed = value.strip()
        if not value_trimmed:
            return False
        terminal_punctuation = {'.', '!', '?'}
        if not value_trimmed[-1] in terminal_punctuation:
            return False
        if any((char in terminal_punctuation for char in value_trimmed[:-1])):
            return False
        future_word_count = len(re.findall('\\bمستقبل\\b', value_trimmed))
        if future_word_count != 1:
            return False
        wishing_pattern = '\\b(أتمنى|ليت|لعل)\\b'
        has_wishing_marker = re.search(wishing_pattern, value_trimmed) is not None
        if not has_wishing_marker:
            return False
        return True



class DataIdx1602InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1602')

    def check_following(self, value):
        """Checks if the response is a simple tea recipe in three numbered steps (1, 2, 3)
           and does not contain any commas.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if ',' in value:
            return False
        lines = value.strip().splitlines()
        if len(lines) != 3:
            return False
        try:
            line1_starts_correctly = lines[0].strip().startswith('1.')
            line2_starts_correctly = lines[1].strip().startswith('2.')
            line3_starts_correctly = lines[2].strip().startswith('3.')
        except IndexError:
            return False
        return line1_starts_correctly and line2_starts_correctly and line3_starts_correctly



class DataIdx1603InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1603')

    def check_following(self, value):
        """Checks if the response follows the constraints for IDX 1603.
        Constraints:
        1. Must start with "الكتاب هو".
        2. Is a single sentence (implicit from "في جملة واحدة").
        3. Contains no more than 15 words.

        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value.startswith('الكتاب هو'):
            return False
        words = cleaned_value.split()
        if len(words) > 15:
            return False
        return True



class DataIdx1604InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1604')

    def check_following(self, value):
        """Checks if the response is between 75 and 95 words.
        Args:
            value: A string representing the response.

        Returns:
            True if the response follows the instruction or False otherwise.
        """
        if not isinstance(value, str):
            return False
        words = value.split()
        word_count = len(words)
        return 75 <= word_count <= 95



class DataIdx1605InstructionChecker(IFevalSynArInstructions):

    def __init__(self):
        super().__init__('idx_1605')

    def check_following(self, value):
        """Checks if the response lists exactly three items, potentially in a list format.
        Assumes newline or comma separated lists are valid formats for representing a ranked list of three items.
        It checks for exactly three non-empty items after splitting by newline or comma.
        It does NOT check if the items are actually things that make the person happy,
        nor if the ranking from least to most important is subjectively correct.
        It strictly checks the structural constraints: a list containing exactly three items.

        Args:
            value: A string representing the response.

        Returns:
            True if the response appears to list exactly three items in a common list format, False otherwise.
        """
        if not isinstance(value, str):
            return False
        cleaned_value = value.strip()
        if not cleaned_value:
            return False
        items_nl = [item.strip() for item in cleaned_value.split('\n') if item.strip()]
        if len(items_nl) == 3:
            return True
        items_comma = [item.strip() for item in cleaned_value.split(',') if item.strip()]
        if len(items_comma) == 3:
            return True
        return False

